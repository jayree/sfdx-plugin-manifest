#!/usr/bin/env node
'use strict';
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) =>
  function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
var __export = (target, all) => {
  for (var name in all) __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === 'object') || typeof from === 'function') {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
        });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, 'default', { value: mod, enumerable: true }) : target,
    mod,
  )
);
var __toCommonJS = (mod) => __copyProps(__defProp({}, '__esModule', { value: true }), mod);

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  'node_modules/semver/internal/constants.js'(exports2, module2) {
    var SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER /* istanbul ignore next */ || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = ['major', 'premajor', 'minor', 'preminor', 'patch', 'prepatch', 'prerelease'];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2,
    };
  },
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  'node_modules/semver/internal/debug.js'(exports2, module2) {
    var debug =
      typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)
        ? (...args) => console.error('SEMVER', ...args)
        : () => {};
    module2.exports = debug;
  },
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  'node_modules/semver/internal/re.js'(exports2, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = (exports2.re = []);
    var safeRe = (exports2.safeRe = []);
    var src = (exports2.src = []);
    var safeSrc = (exports2.safeSrc = []);
    var t = (exports2.t = {});
    var R = 0;
    var LETTERDASHNUMBER = '[a-zA-Z0-9-]';
    var safeRegexReplacements = [
      ['\\s', 1],
      ['\\d', MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? 'g' : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? 'g' : void 0);
    };
    createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
    createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
    createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken(
      'MAINVERSION',
      `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`,
    );
    createToken(
      'MAINVERSIONLOOSE',
      `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`,
    );
    createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken(
      'PRERELEASELOOSE',
      `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`,
    );
    createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
    createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken('FULL', `^${src[t.FULLPLAIN]}$`);
    createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
    createToken('GTLT', '((?:<|>)?=?)');
    createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken(
      'XRANGEPLAIN',
      `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`,
    );
    createToken(
      'XRANGEPLAINLOOSE',
      `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`,
    );
    createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken(
      'COERCEPLAIN',
      `${'(^|[^\\d])(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`,
    );
    createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken('COERCEFULL', src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken('COERCERTL', src[t.COERCE], true);
    createToken('COERCERTLFULL', src[t.COERCEFULL], true);
    createToken('LONETILDE', '(?:~>?)');
    createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = '$1~';
    createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken('LONECARET', '(?:\\^)');
    createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = '$1^';
    createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = '$1$2$3';
    createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken('STAR', '(<|>)?=?\\s*\\*');
    createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
    createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
  },
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  'node_modules/semver/internal/parse-options.js'(exports2, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options2) => {
      if (!options2) {
        return emptyOpts;
      }
      if (typeof options2 !== 'object') {
        return looseOption;
      }
      return options2;
    };
    module2.exports = parseOptions;
  },
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  'node_modules/semver/internal/identifiers.js'(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers,
    };
  },
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  'node_modules/semver/classes/semver.js'(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, safeSrc: src, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options2) {
        options2 = parseOptions(options2);
        if (version instanceof _SemVer) {
          if (version.loose === !!options2.loose && version.includePrerelease === !!options2.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== 'string') {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug('SemVer', version, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        const m = version.trim().match(options2.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError('Invalid major version');
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError('Invalid minor version');
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError('Invalid patch version');
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split('.').map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split('.') : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join('.')}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug('SemVer.compare', this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === 'string' && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return (
          compareIdentifiers(this.major, other.major) ||
          compareIdentifiers(this.minor, other.minor) ||
          compareIdentifiers(this.patch, other.patch)
        );
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug('prerelease compare', i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug('build compare', i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith('pre')) {
          if (!identifier && identifierBase === false) {
            throw new Error('invalid increment argument: identifier is empty');
          }
          if (identifier) {
            const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
            const match = `-${identifier}`.match(r);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case 'premajor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc('pre', identifier, identifierBase);
            break;
          case 'preminor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc('pre', identifier, identifierBase);
            break;
          case 'prepatch':
            this.prerelease.length = 0;
            this.inc('patch', identifier, identifierBase);
            this.inc('pre', identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case 'prerelease':
            if (this.prerelease.length === 0) {
              this.inc('patch', identifier, identifierBase);
            }
            this.inc('pre', identifier, identifierBase);
            break;
          case 'release':
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case 'major':
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case 'minor':
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case 'patch':
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case 'pre': {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === 'number') {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join('.') && identifierBase === false) {
                  throw new Error('invalid increment argument: identifier already exists');
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join('.')}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  },
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  'node_modules/semver/functions/parse.js'(exports2, module2) {
    var SemVer = require_semver();
    var parse2 = (version, options2, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options2);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse2;
  },
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  'node_modules/semver/functions/valid.js'(exports2, module2) {
    var parse2 = require_parse();
    var valid = (version, options2) => {
      const v = parse2(version, options2);
      return v ? v.version : null;
    };
    module2.exports = valid;
  },
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  'node_modules/semver/functions/clean.js'(exports2, module2) {
    var parse2 = require_parse();
    var clean = (version, options2) => {
      const s = parse2(version.trim().replace(/^[=v]+/, ''), options2);
      return s ? s.version : null;
    };
    module2.exports = clean;
  },
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  'node_modules/semver/functions/inc.js'(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version, release, options2, identifier, identifierBase) => {
      if (typeof options2 === 'string') {
        identifierBase = identifier;
        identifier = options2;
        options2 = void 0;
      }
      try {
        return new SemVer(version instanceof SemVer ? version.version : version, options2).inc(
          release,
          identifier,
          identifierBase,
        ).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  },
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  'node_modules/semver/functions/diff.js'(exports2, module2) {
    var parse2 = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse2(version1, null, true);
      const v2 = parse2(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return 'major';
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return 'minor';
          }
          return 'patch';
        }
      }
      const prefix = highHasPre ? 'pre' : '';
      if (v1.major !== v2.major) {
        return prefix + 'major';
      }
      if (v1.minor !== v2.minor) {
        return prefix + 'minor';
      }
      if (v1.patch !== v2.patch) {
        return prefix + 'patch';
      }
      return 'prerelease';
    };
    module2.exports = diff;
  },
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  'node_modules/semver/functions/major.js'(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  },
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  'node_modules/semver/functions/minor.js'(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  },
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  'node_modules/semver/functions/patch.js'(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  },
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  'node_modules/semver/functions/prerelease.js'(exports2, module2) {
    var parse2 = require_parse();
    var prerelease = (version, options2) => {
      const parsed = parse2(version, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  },
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  'node_modules/semver/functions/compare.js'(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  },
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  'node_modules/semver/functions/rcompare.js'(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  },
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  'node_modules/semver/functions/compare-loose.js'(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  },
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  'node_modules/semver/functions/compare-build.js'(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  },
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  'node_modules/semver/functions/sort.js'(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  },
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  'node_modules/semver/functions/rsort.js'(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  },
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  'node_modules/semver/functions/gt.js'(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  },
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  'node_modules/semver/functions/lt.js'(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  },
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  'node_modules/semver/functions/eq.js'(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  },
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  'node_modules/semver/functions/neq.js'(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  },
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  'node_modules/semver/functions/gte.js'(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  },
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  'node_modules/semver/functions/lte.js'(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  },
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  'node_modules/semver/functions/cmp.js'(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case '===':
          if (typeof a === 'object') {
            a = a.version;
          }
          if (typeof b === 'object') {
            b = b.version;
          }
          return a === b;
        case '!==':
          if (typeof a === 'object') {
            a = a.version;
          }
          if (typeof b === 'object') {
            b = b.version;
          }
          return a !== b;
        case '':
        case '=':
        case '==':
          return eq(a, b, loose);
        case '!=':
          return neq(a, b, loose);
        case '>':
          return gt(a, b, loose);
        case '>=':
          return gte(a, b, loose);
        case '<':
          return lt(a, b, loose);
        case '<=':
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  },
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  'node_modules/semver/functions/coerce.js'(exports2, module2) {
    var SemVer = require_semver();
    var parse2 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options2) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === 'number') {
        version = String(version);
      }
      if (typeof version !== 'string') {
        return null;
      }
      options2 = options2 || {};
      let match = null;
      if (!options2.rtl) {
        match = version.match(options2.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options2.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || '0';
      const patch = match[4] || '0';
      const prerelease = options2.includePrerelease && match[5] ? `-${match[5]}` : '';
      const build = options2.includePrerelease && match[6] ? `+${match[6]}` : '';
      return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options2);
    };
    module2.exports = coerce;
  },
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  'node_modules/semver/internal/lrucache.js'(exports2, module2) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  },
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  'node_modules/semver/classes/range.js'(exports2, module2) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options2) {
        options2 = parseOptions(options2);
        if (range instanceof _Range) {
          if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options2);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
        this.set = this.raw
          .split('||')
          .map((r) => this.parseRange(r.trim()))
          .filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = '';
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += '||';
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += ' ';
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts =
          (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ':' + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug('hyphen replace', range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug('comparator trim', range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug('tilde trim', range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug('caret trim', range);
        let rangeList = range
          .split(' ')
          .map((comp) => parseComparator(comp, this.options))
          .join(' ')
          .split(/\s+/)
          .map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug('loose invalid filter', comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug('range list', rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has('')) {
          rangeMap.delete('');
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options2) {
        if (!(range instanceof _Range)) {
          throw new TypeError('a Range is required');
        }
        return this.set.some((thisComparators) => {
          return (
            isSatisfiable(thisComparators, options2) &&
            range.set.some((rangeComparators) => {
              return (
                isSatisfiable(rangeComparators, options2) &&
                thisComparators.every((thisComparator) => {
                  return rangeComparators.every((rangeComparator) => {
                    return thisComparator.intersects(rangeComparator, options2);
                  });
                })
              );
            })
          );
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === 'string') {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === '<0.0.0-0';
    var isAny = (c) => c.value === '';
    var isSatisfiable = (comparators, options2) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options2) => {
      debug('comp', comp, options2);
      comp = replaceCarets(comp, options2);
      debug('caret', comp);
      comp = replaceTildes(comp, options2);
      debug('tildes', comp);
      comp = replaceXRanges(comp, options2);
      debug('xrange', comp);
      comp = replaceStars(comp, options2);
      debug('stars', comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === 'x' || id === '*';
    var replaceTildes = (comp, options2) => {
      return comp
        .trim()
        .split(/\s+/)
        .map((c) => replaceTilde(c, options2))
        .join(' ');
    };
    var replaceTilde = (comp, options2) => {
      const r = options2.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug('tilde', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug('replaceTilde pr', pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug('tilde return', ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options2) => {
      return comp
        .trim()
        .split(/\s+/)
        .map((c) => replaceCaret(c, options2))
        .join(' ');
    };
    var replaceCaret = (comp, options2) => {
      debug('caret', comp, options2);
      const r = options2.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options2.includePrerelease ? '-0' : '';
      return comp.replace(r, (_, M, m, p, pr) => {
        debug('caret', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === '0') {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug('replaceCaret pr', pr);
          if (M === '0') {
            if (m === '0') {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug('no pr');
          if (M === '0') {
            if (m === '0') {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug('caret return', ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options2) => {
      debug('replaceXRanges', comp, options2);
      return comp
        .split(/\s+/)
        .map((c) => replaceXRange(c, options2))
        .join(' ');
    };
    var replaceXRange = (comp, options2) => {
      comp = comp.trim();
      const r = options2.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === '=' && anyX) {
          gtlt = '';
        }
        pr = options2.includePrerelease ? '-0' : '';
        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            ret = '<0.0.0-0';
          } else {
            ret = '*';
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === '>') {
            gtlt = '>=';
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            gtlt = '<';
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === '<') {
            pr = '-0';
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug('xRange return', ret);
        return ret;
      });
    };
    var replaceStars = (comp, options2) => {
      debug('replaceStars', comp, options2);
      return comp.trim().replace(re[t.STAR], '');
    };
    var replaceGTE0 = (comp, options2) => {
      debug('replaceGTE0', comp, options2);
      return comp.trim().replace(re[options2.includePrerelease ? t.GTE0PRE : t.GTE0], '');
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? '-0' : ''}`;
      }
      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options2) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options2.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  },
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  'node_modules/semver/classes/comparator.js'(exports2, module2) {
    var ANY = Symbol('SemVer ANY');
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options2) {
        options2 = parseOptions(options2);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options2.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(' ');
        debug('comparator', comp, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = '';
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug('comp', this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : '';
        if (this.operator === '=') {
          this.operator = '';
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug('Comparator.test', version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === 'string') {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options2) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError('a Comparator is required');
        }
        if (this.operator === '') {
          if (this.value === '') {
            return true;
          }
          return new Range(comp.value, options2).test(this.value);
        } else if (comp.operator === '') {
          if (comp.value === '') {
            return true;
          }
          return new Range(this.value, options2).test(comp.semver);
        }
        options2 = parseOptions(options2);
        if (options2.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
          return false;
        }
        if (!options2.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
          return false;
        }
        if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
          return true;
        }
        if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) {
          return true;
        }
        if (
          cmp(this.semver, '<', comp.semver, options2) &&
          this.operator.startsWith('>') &&
          comp.operator.startsWith('<')
        ) {
          return true;
        }
        if (
          cmp(this.semver, '>', comp.semver, options2) &&
          this.operator.startsWith('<') &&
          comp.operator.startsWith('>')
        ) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  },
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  'node_modules/semver/functions/satisfies.js'(exports2, module2) {
    var Range = require_range();
    var satisfies = (version, range, options2) => {
      try {
        range = new Range(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  },
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  'node_modules/semver/ranges/to-comparators.js'(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options2) =>
      new Range(range, options2).set.map((comp) =>
        comp
          .map((c) => c.value)
          .join(' ')
          .trim()
          .split(' '),
      );
    module2.exports = toComparators;
  },
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  'node_modules/semver/ranges/max-satisfying.js'(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options2) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  },
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  'node_modules/semver/ranges/min-satisfying.js'(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options2) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  },
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  'node_modules/semver/ranges/min-version.js'(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer('0.0.0');
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer('0.0.0-0');
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case '':
            case '>=':
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case '<':
            case '<=':
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  },
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  'node_modules/semver/ranges/valid.js'(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options2) => {
      try {
        return new Range(range, options2).range || '*';
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  },
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  'node_modules/semver/ranges/outside.js'(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options2) => {
      version = new SemVer(version, options2);
      range = new Range(range, options2);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;
        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options2)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  },
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  'node_modules/semver/ranges/gtr.js'(exports2, module2) {
    var outside = require_outside();
    var gtr = (version, range, options2) => outside(version, range, '>', options2);
    module2.exports = gtr;
  },
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  'node_modules/semver/ranges/ltr.js'(exports2, module2) {
    var outside = require_outside();
    var ltr = (version, range, options2) => outside(version, range, '<', options2);
    module2.exports = ltr;
  },
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  'node_modules/semver/ranges/intersects.js'(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options2) => {
      r1 = new Range(r1, options2);
      r2 = new Range(r2, options2);
      return r1.intersects(r2, options2);
    };
    module2.exports = intersects;
  },
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  'node_modules/semver/ranges/simplify.js'(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options2) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options2));
      for (const version of v) {
        const included = satisfies(version, range, options2);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push('*');
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(' || ');
      const original = typeof range.raw === 'string' ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  },
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  'node_modules/semver/ranges/subset.js'(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options2 = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options2);
      dom = new Range(dom, options2);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options2);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
    var minimumVersion = [new Comparator('>=0.0.0')];
    var simpleSubset = (sub, dom, options2) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options2.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options2.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === '>' || c.operator === '>=') {
          gt = higherGT(gt, c, options2);
        } else if (c.operator === '<' || c.operator === '<=') {
          lt = lowerLT(lt, c, options2);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options2);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options2)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options2)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options2)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options2.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options2.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (
        needDomLTPre &&
        needDomLTPre.prerelease.length === 1 &&
        lt.operator === '<' &&
        needDomLTPre.prerelease[0] === 0
      ) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
        hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
        if (gt) {
          if (needDomGTPre) {
            if (
              c.semver.prerelease &&
              c.semver.prerelease.length &&
              c.semver.major === needDomGTPre.major &&
              c.semver.minor === needDomGTPre.minor &&
              c.semver.patch === needDomGTPre.patch
            ) {
              needDomGTPre = false;
            }
          }
          if (c.operator === '>' || c.operator === '>=') {
            higher = higherGT(gt, c, options2);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options2)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (
              c.semver.prerelease &&
              c.semver.prerelease.length &&
              c.semver.major === needDomLTPre.major &&
              c.semver.minor === needDomLTPre.minor &&
              c.semver.patch === needDomLTPre.patch
            ) {
              needDomLTPre = false;
            }
          }
          if (c.operator === '<' || c.operator === '<=') {
            lower = lowerLT(lt, c, options2);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options2)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options2);
      return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
    };
    var lowerLT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options2);
      return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
    };
    module2.exports = subset;
  },
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  'node_modules/semver/index.js'(exports2, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers,
    };
  },
});

// node_modules/ini/ini.js
var require_ini = __commonJS({
  'node_modules/ini/ini.js'(exports2) {
    exports2.parse = exports2.decode = decode;
    exports2.stringify = exports2.encode = encode;
    exports2.safe = safe;
    exports2.unsafe = unsafe;
    var eol = typeof process !== 'undefined' && process.platform === 'win32' ? '\r\n' : '\n';
    function encode(obj, opt) {
      var children = [];
      var out = '';
      if (typeof opt === 'string') {
        opt = {
          section: opt,
          whitespace: false,
        };
      } else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
      }
      var separator = opt.whitespace ? ' = ' : '=';
      Object.keys(obj).forEach(function (k, _, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) {
          val.forEach(function (item) {
            out += safe(k + '[]') + separator + safe(item) + '\n';
          });
        } else if (val && typeof val === 'object') children.push(k);
        else out += safe(k) + separator + safe(val) + eol;
      });
      if (opt.section && out.length) out = '[' + safe(opt.section) + ']' + eol + out;
      children.forEach(function (k, _, __) {
        var nk = dotSplit(k).join('\\.');
        var section = (opt.section ? opt.section + '.' : '') + nk;
        var child = encode(obj[k], {
          section,
          whitespace: opt.whitespace,
        });
        if (out.length && child.length) out += eol;
        out += child;
      });
      return out;
    }
    function dotSplit(str) {
      return str
        .replace(/\1/g, 'LITERAL\\1LITERAL')
        .replace(/\\\./g, '')
        .split(/\./)
        .map(function (part) {
          return part.replace(/\1/g, '\\.').replace(/\2LITERAL\\1LITERAL\2/g, '');
        });
    }
    function decode(str) {
      var out = {};
      var p = out;
      var section = null;
      var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      var lines = str.split(/[\r\n]+/g);
      lines.forEach(function (line, _, __) {
        if (!line || line.match(/^\s*[;#]/)) return;
        var match = line.match(re);
        if (!match) return;
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          if (section === '__proto__') {
            p = {};
            return;
          }
          p = out[section] = out[section] || {};
          return;
        }
        var key = unsafe(match[2]);
        if (key === '__proto__') return;
        var value = match[3] ? unsafe(match[4]) : true;
        switch (value) {
          case 'true':
          case 'false':
          case 'null':
            value = JSON.parse(value);
        }
        if (key.length > 2 && key.slice(-2) === '[]') {
          key = key.substring(0, key.length - 2);
          if (key === '__proto__') return;
          if (!p[key]) p[key] = [];
          else if (!Array.isArray(p[key])) p[key] = [p[key]];
        }
        if (Array.isArray(p[key])) p[key].push(value);
        else p[key] = value;
      });
      Object.keys(out)
        .filter(function (k, _, __) {
          if (!out[k] || typeof out[k] !== 'object' || Array.isArray(out[k])) return false;
          var parts = dotSplit(k);
          var p2 = out;
          var l = parts.pop();
          var nl = l.replace(/\\\./g, '.');
          parts.forEach(function (part, _2, __2) {
            if (part === '__proto__') return;
            if (!p2[part] || typeof p2[part] !== 'object') p2[part] = {};
            p2 = p2[part];
          });
          if (p2 === out && nl === l) return false;
          p2[nl] = out[k];
          return true;
        })
        .forEach(function (del, _, __) {
          delete out[del];
        });
      return out;
    }
    function isQuoted(val) {
      return (val.charAt(0) === '"' && val.slice(-1) === '"') || (val.charAt(0) === "'" && val.slice(-1) === "'");
    }
    function safe(val) {
      return typeof val !== 'string' ||
        val.match(/[=\r\n]/) ||
        val.match(/^\[/) ||
        (val.length > 1 && isQuoted(val)) ||
        val !== val.trim()
        ? JSON.stringify(val)
        : val.replace(/;/g, '\\;').replace(/#/g, '\\#');
    }
    function unsafe(val, doUnesc) {
      val = (val || '').trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'") val = val.substr(1, val.length - 2);
        try {
          val = JSON.parse(val);
        } catch (_) {}
      } else {
        var esc = false;
        var unesc = '';
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i);
          if (esc) {
            if ('\\;#'.indexOf(c) !== -1) unesc += c;
            else unesc += '\\' + c;
            esc = false;
          } else if (';#'.indexOf(c) !== -1) break;
          else if (c === '\\') esc = true;
          else unesc += c;
        }
        if (esc) unesc += '\\';
        return unesc.trim();
      }
      return val;
    }
  },
});

// node_modules/rc/node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS({
  'node_modules/rc/node_modules/strip-json-comments/index.js'(exports2, module2) {
    'use strict';
    var singleComment = 1;
    var multiComment = 2;
    function stripWithoutWhitespace() {
      return '';
    }
    function stripWithWhitespace(str, start, end) {
      return str.slice(start, end).replace(/\S/g, ' ');
    }
    module2.exports = function (str, opts) {
      opts = opts || {};
      var currentChar;
      var nextChar;
      var insideString = false;
      var insideComment = false;
      var offset = 0;
      var ret = '';
      var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
      for (var i = 0; i < str.length; i++) {
        currentChar = str[i];
        nextChar = str[i + 1];
        if (!insideComment && currentChar === '"') {
          var escaped = str[i - 1] === '\\' && str[i - 2] !== '\\';
          if (!escaped) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          continue;
        }
        if (!insideComment && currentChar + nextChar === '//') {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = singleComment;
          i++;
        } else if (insideComment === singleComment && currentChar + nextChar === '\r\n') {
          i++;
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
          continue;
        } else if (insideComment === singleComment && currentChar === '\n') {
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
        } else if (!insideComment && currentChar + nextChar === '/*') {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = multiComment;
          i++;
          continue;
        } else if (insideComment === multiComment && currentChar + nextChar === '*/') {
          i++;
          insideComment = false;
          ret += strip(str, offset, i + 1);
          offset = i + 1;
          continue;
        }
      }
      return ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
    };
  },
});

// node_modules/rc/lib/utils.js
var require_utils = __commonJS({
  'node_modules/rc/lib/utils.js'(exports2) {
    'use strict';
    var fs2 = require('fs');
    var ini = require_ini();
    var path = require('path');
    var stripJsonComments = require_strip_json_comments();
    var parse2 = (exports2.parse = function (content) {
      if (/^\s*{/.test(content)) return JSON.parse(stripJsonComments(content));
      return ini.parse(content);
    });
    var file = (exports2.file = function () {
      var args = [].slice.call(arguments).filter(function (arg) {
        return arg != null;
      });
      for (var i in args) if ('string' !== typeof args[i]) return;
      var file2 = path.join.apply(null, args);
      var content;
      try {
        return fs2.readFileSync(file2, 'utf-8');
      } catch (err) {
        return;
      }
    });
    var json = (exports2.json = function () {
      var content = file.apply(null, arguments);
      return content ? parse2(content) : null;
    });
    var env2 = (exports2.env = function (prefix, env3) {
      env3 = env3 || process.env;
      var obj = {};
      var l = prefix.length;
      for (var k in env3) {
        if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
          var keypath = k.substring(l).split('__');
          var _emptyStringIndex;
          while ((_emptyStringIndex = keypath.indexOf('')) > -1) {
            keypath.splice(_emptyStringIndex, 1);
          }
          var cursor = obj;
          keypath.forEach(function _buildSubObj(_subkey, i) {
            if (!_subkey || typeof cursor !== 'object') return;
            if (i === keypath.length - 1) cursor[_subkey] = env3[k];
            if (cursor[_subkey] === void 0) cursor[_subkey] = {};
            cursor = cursor[_subkey];
          });
        }
      }
      return obj;
    });
    var find = (exports2.find = function () {
      var rel = path.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file2 = path.join(start, rel2);
        try {
          fs2.statSync(file2);
          return file2;
        } catch (err) {
          if (path.dirname(start) !== start) return find2(path.dirname(start), rel2);
        }
      }
      return find2(process.cwd(), rel);
    });
  },
});

// node_modules/deep-extend/lib/deep-extend.js
var require_deep_extend = __commonJS({
  'node_modules/deep-extend/lib/deep-extend.js'(exports2, module2) {
    'use strict';
    function isSpecificValue(val) {
      return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
    }
    function cloneSpecificValue(val) {
      if (val instanceof Buffer) {
        var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
        val.copy(x);
        return x;
      } else if (val instanceof Date) {
        return new Date(val.getTime());
      } else if (val instanceof RegExp) {
        return new RegExp(val);
      } else {
        throw new Error('Unexpected situation');
      }
    }
    function deepCloneArray(arr) {
      var clone = [];
      arr.forEach(function (item, index) {
        if (typeof item === 'object' && item !== null) {
          if (Array.isArray(item)) {
            clone[index] = deepCloneArray(item);
          } else if (isSpecificValue(item)) {
            clone[index] = cloneSpecificValue(item);
          } else {
            clone[index] = deepExtend({}, item);
          }
        } else {
          clone[index] = item;
        }
      });
      return clone;
    }
    function safeGetProperty(object, property) {
      return property === '__proto__' ? void 0 : object[property];
    }
    var deepExtend = (module2.exports = function () {
      if (arguments.length < 1 || typeof arguments[0] !== 'object') {
        return false;
      }
      if (arguments.length < 2) {
        return arguments[0];
      }
      var target = arguments[0];
      var args = Array.prototype.slice.call(arguments, 1);
      var val, src, clone;
      args.forEach(function (obj) {
        if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
          return;
        }
        Object.keys(obj).forEach(function (key) {
          src = safeGetProperty(target, key);
          val = safeGetProperty(obj, key);
          if (val === target) {
            return;
          } else if (typeof val !== 'object' || val === null) {
            target[key] = val;
            return;
          } else if (Array.isArray(val)) {
            target[key] = deepCloneArray(val);
            return;
          } else if (isSpecificValue(val)) {
            target[key] = cloneSpecificValue(val);
            return;
          } else if (typeof src !== 'object' || src === null || Array.isArray(src)) {
            target[key] = deepExtend({}, val);
            return;
          } else {
            target[key] = deepExtend(src, val);
            return;
          }
        });
      });
      return target;
    });
  },
});

// node_modules/minimist/index.js
var require_minimist = __commonJS({
  'node_modules/minimist/index.js'(exports2, module2) {
    'use strict';
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function (key2) {
        o = o[key2] || {};
      });
      var key = keys[keys.length - 1];
      return key in o;
    }
    function isNumber(x) {
      if (typeof x === 'number') {
        return true;
      }
      if (/^0x[0-9a-f]+$/i.test(x)) {
        return true;
      }
      return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function isConstructorOrProto(obj, key) {
      return (key === 'constructor' && typeof obj[key] === 'function') || key === '__proto__';
    }
    module2.exports = function (args, opts) {
      if (!opts) {
        opts = {};
      }
      var flags = {
        bools: {},
        strings: {},
        unknownFn: null,
      };
      if (typeof opts.unknown === 'function') {
        flags.unknownFn = opts.unknown;
      }
      if (typeof opts.boolean === 'boolean' && opts.boolean) {
        flags.allBools = true;
      } else {
        []
          .concat(opts.boolean)
          .filter(Boolean)
          .forEach(function (key2) {
            flags.bools[key2] = true;
          });
      }
      var aliases = {};
      function aliasIsBoolean(key2) {
        return aliases[key2].some(function (x) {
          return flags.bools[x];
        });
      }
      Object.keys(opts.alias || {}).forEach(function (key2) {
        aliases[key2] = [].concat(opts.alias[key2]);
        aliases[key2].forEach(function (x) {
          aliases[x] = [key2].concat(
            aliases[key2].filter(function (y) {
              return x !== y;
            }),
          );
        });
      });
      []
        .concat(opts.string)
        .filter(Boolean)
        .forEach(function (key2) {
          flags.strings[key2] = true;
          if (aliases[key2]) {
            [].concat(aliases[key2]).forEach(function (k) {
              flags.strings[k] = true;
            });
          }
        });
      var defaults = opts.default || {};
      var argv = { _: [] };
      function argDefined(key2, arg2) {
        return (flags.allBools && /^--[^=]+$/.test(arg2)) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
      }
      function setKey(obj, keys, value2) {
        var o = obj;
        for (var i2 = 0; i2 < keys.length - 1; i2++) {
          var key2 = keys[i2];
          if (isConstructorOrProto(o, key2)) {
            return;
          }
          if (o[key2] === void 0) {
            o[key2] = {};
          }
          if (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype) {
            o[key2] = {};
          }
          if (o[key2] === Array.prototype) {
            o[key2] = [];
          }
          o = o[key2];
        }
        var lastKey = keys[keys.length - 1];
        if (isConstructorOrProto(o, lastKey)) {
          return;
        }
        if (o === Object.prototype || o === Number.prototype || o === String.prototype) {
          o = {};
        }
        if (o === Array.prototype) {
          o = [];
        }
        if (o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] === 'boolean') {
          o[lastKey] = value2;
        } else if (Array.isArray(o[lastKey])) {
          o[lastKey].push(value2);
        } else {
          o[lastKey] = [o[lastKey], value2];
        }
      }
      function setArg(key2, val, arg2) {
        if (arg2 && flags.unknownFn && !argDefined(key2, arg2)) {
          if (flags.unknownFn(arg2) === false) {
            return;
          }
        }
        var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
        setKey(argv, key2.split('.'), value2);
        (aliases[key2] || []).forEach(function (x) {
          setKey(argv, x.split('.'), value2);
        });
      }
      Object.keys(flags.bools).forEach(function (key2) {
        setArg(key2, defaults[key2] === void 0 ? false : defaults[key2]);
      });
      var notFlags = [];
      if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--') + 1);
        args = args.slice(0, args.indexOf('--'));
      }
      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        var key;
        var next;
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          key = m[1];
          var value = m[2];
          if (flags.bools[key]) {
            value = value !== 'false';
          }
          setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg)) {
          key = arg.match(/^--no-(.+)/)[1];
          setArg(key, false, arg);
        } else if (/^--.+/.test(arg)) {
          key = arg.match(/^--(.+)/)[1];
          next = args[i + 1];
          if (
            next !== void 0 &&
            !/^(-|--)[^-]/.test(next) &&
            !flags.bools[key] &&
            !flags.allBools &&
            (aliases[key] ? !aliasIsBoolean(key) : true)
          ) {
            setArg(key, next, arg);
            i += 1;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next === 'true', arg);
            i += 1;
          } else {
            setArg(key, flags.strings[key] ? '' : true, arg);
          }
        } else if (/^-[^-]+/.test(arg)) {
          var letters = arg.slice(1, -1).split('');
          var broken = false;
          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (next === '-') {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && next[0] === '=') {
              setArg(letters[j], next.slice(1), arg);
              broken = true;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg);
              broken = true;
              break;
            } else {
              setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
            }
          }
          key = arg.slice(-1)[0];
          if (!broken && key !== '-') {
            if (
              args[i + 1] &&
              !/^(-|--)[^-]/.test(args[i + 1]) &&
              !flags.bools[key] &&
              (aliases[key] ? !aliasIsBoolean(key) : true)
            ) {
              setArg(key, args[i + 1], arg);
              i += 1;
            } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
              setArg(key, args[i + 1] === 'true', arg);
              i += 1;
            } else {
              setArg(key, flags.strings[key] ? '' : true, arg);
            }
          }
        } else {
          if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
            argv._.push(flags.strings._ || !isNumber(arg) ? arg : Number(arg));
          }
          if (opts.stopEarly) {
            argv._.push.apply(argv._, args.slice(i + 1));
            break;
          }
        }
      }
      Object.keys(defaults).forEach(function (k) {
        if (!hasKey(argv, k.split('.'))) {
          setKey(argv, k.split('.'), defaults[k]);
          (aliases[k] || []).forEach(function (x) {
            setKey(argv, x.split('.'), defaults[k]);
          });
        }
      });
      if (opts['--']) {
        argv['--'] = notFlags.slice();
      } else {
        notFlags.forEach(function (k) {
          argv._.push(k);
        });
      }
      return argv;
    };
  },
});

// node_modules/rc/index.js
var require_rc = __commonJS({
  'node_modules/rc/index.js'(exports2, module2) {
    var cc = require_utils();
    var join = require('path').join;
    var deepExtend = require_deep_extend();
    var etc = '/etc';
    var win = process.platform === 'win32';
    var home = win ? process.env.USERPROFILE : process.env.HOME;
    module2.exports = function (name, defaults, argv, parse2) {
      if ('string' !== typeof name) throw new Error('rc(name): name *must* be string');
      if (!argv) argv = require_minimist()(process.argv.slice(2));
      defaults = ('string' === typeof defaults ? cc.json(defaults) : defaults) || {};
      parse2 = parse2 || cc.parse;
      var env2 = cc.env(name + '_');
      var configs = [defaults];
      var configFiles = [];
      function addConfigFile(file) {
        if (configFiles.indexOf(file) >= 0) return;
        var fileConfig = cc.file(file);
        if (fileConfig) {
          configs.push(parse2(fileConfig));
          configFiles.push(file);
        }
      }
      if (!win) [join(etc, name, 'config'), join(etc, name + 'rc')].forEach(addConfigFile);
      if (home)
        [
          join(home, '.config', name, 'config'),
          join(home, '.config', name),
          join(home, '.' + name, 'config'),
          join(home, '.' + name + 'rc'),
        ].forEach(addConfigFile);
      addConfigFile(cc.find('.' + name + 'rc'));
      if (env2.config) addConfigFile(env2.config);
      if (argv.config) addConfigFile(argv.config);
      return deepExtend.apply(
        null,
        configs.concat([
          env2,
          argv,
          configFiles.length ? { configs: configFiles, config: configFiles[configFiles.length - 1] } : void 0,
        ]),
      );
    };
  },
});

// node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  'node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/polyfills.js'(exports2, module2) {
    var constants = require('constants');
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function () {
      if (!cwd) cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {}
    if (typeof process.chdir === 'function') {
      chdir = process.chdir;
      process.chdir = function (d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs2) {
      if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      fs2.stat = statFix(fs2.stat);
      fs2.fstat = statFix(fs2.fstat);
      fs2.lstat = statFix(fs2.lstat);
      fs2.statSync = statFixSync(fs2.statSync);
      fs2.fstatSync = statFixSync(fs2.fstatSync);
      fs2.lstatSync = statFixSync(fs2.lstatSync);
      if (fs2.chmod && !fs2.lchmod) {
        fs2.lchmod = function (path, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs2.lchmodSync = function () {};
      }
      if (fs2.chown && !fs2.lchown) {
        fs2.lchown = function (path, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs2.lchownSync = function () {};
      }
      if (platform === 'win32') {
        fs2.rename =
          typeof fs2.rename !== 'function'
            ? fs2.rename
            : (function (fs$rename) {
                function rename(from, to, cb) {
                  var start = Date.now();
                  var backoff = 0;
                  fs$rename(from, to, function CB(er) {
                    if (er && (er.code === 'EACCES' || er.code === 'EPERM') && Date.now() - start < 6e4) {
                      setTimeout(function () {
                        fs2.stat(to, function (stater, st) {
                          if (stater && stater.code === 'ENOENT') fs$rename(from, to, CB);
                          else cb(er);
                        });
                      }, backoff);
                      if (backoff < 100) backoff += 10;
                      return;
                    }
                    if (cb) cb(er);
                  });
                }
                if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
                return rename;
              })(fs2.rename);
      }
      fs2.read =
        typeof fs2.read !== 'function'
          ? fs2.read
          : (function (fs$read) {
              function read(fd, buffer, offset, length, position, callback_) {
                var callback;
                if (callback_ && typeof callback_ === 'function') {
                  var eagCounter = 0;
                  callback = function (er, _, __) {
                    if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                      eagCounter++;
                      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
                    }
                    callback_.apply(this, arguments);
                  };
                }
                return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
              }
              if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
              return read;
            })(fs2.read);
      fs2.readSync =
        typeof fs2.readSync !== 'function'
          ? fs2.readSync
          : /* @__PURE__ */ (function (fs$readSync) {
              return function (fd, buffer, offset, length, position) {
                var eagCounter = 0;
                while (true) {
                  try {
                    return fs$readSync.call(fs2, fd, buffer, offset, length, position);
                  } catch (er) {
                    if (er.code === 'EAGAIN' && eagCounter < 10) {
                      eagCounter++;
                      continue;
                    }
                    throw er;
                  }
                }
              };
            })(fs2.readSync);
      function patchLchmod(fs3) {
        fs3.lchmod = function (path, mode, callback) {
          fs3.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
            if (err) {
              if (callback) callback(err);
              return;
            }
            fs3.fchmod(fd, mode, function (err2) {
              fs3.close(fd, function (err22) {
                if (callback) callback(err2 || err22);
              });
            });
          });
        };
        fs3.lchmodSync = function (path, mode) {
          var fd = fs3.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs3.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {}
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs3) {
        if (constants.hasOwnProperty('O_SYMLINK') && fs3.futimes) {
          fs3.lutimes = function (path, at, mt, cb) {
            fs3.open(path, constants.O_SYMLINK, function (er, fd) {
              if (er) {
                if (cb) cb(er);
                return;
              }
              fs3.futimes(fd, at, mt, function (er2) {
                fs3.close(fd, function (er22) {
                  if (cb) cb(er2 || er22);
                });
              });
            });
          };
          fs3.lutimesSync = function (path, at, mt) {
            var fd = fs3.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs3.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs3.closeSync(fd);
                } catch (er) {}
              } else {
                fs3.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs3.futimes) {
          fs3.lutimes = function (_a, _b, _c, cb) {
            if (cb) process.nextTick(cb);
          };
          fs3.lutimesSync = function () {};
        }
      }
      function chmodFix(orig) {
        if (!orig) return orig;
        return function (target, mode, cb) {
          return orig.call(fs2, target, mode, function (er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig) return orig;
        return function (target, mode) {
          try {
            return orig.call(fs2, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig) return orig;
        return function (target, uid, gid, cb) {
          return orig.call(fs2, target, uid, gid, function (er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig) return orig;
        return function (target, uid, gid) {
          try {
            return orig.call(fs2, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig) return orig;
        return function (target, options2, cb) {
          if (typeof options2 === 'function') {
            cb = options2;
            options2 = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 4294967296;
              if (stats.gid < 0) stats.gid += 4294967296;
            }
            if (cb) cb.apply(this, arguments);
          }
          return options2 ? orig.call(fs2, target, options2, callback) : orig.call(fs2, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig) return orig;
        return function (target, options2) {
          var stats = options2 ? orig.call(fs2, target, options2) : orig.call(fs2, target);
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er) return true;
        if (er.code === 'ENOSYS') return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === 'EINVAL' || er.code === 'EPERM') return true;
        }
        return false;
      }
    }
  },
});

// node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  'node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/legacy-streams.js'(exports2, module2) {
    var Stream = require('stream').Stream;
    module2.exports = legacy;
    function legacy(fs2) {
      return {
        ReadStream,
        WriteStream,
      };
      function ReadStream(path, options2) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options2);
        Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = 'r';
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options2 = options2 || {};
        var keys = Object.keys(options2);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options2[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ('number' !== typeof this.start) {
            throw TypeError('start must be a Number');
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ('number' !== typeof this.end) {
            throw TypeError('end must be a Number');
          }
          if (this.start > this.end) {
            throw new Error('start must be <= end');
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function () {
            self._read();
          });
          return;
        }
        fs2.open(this.path, this.flags, this.mode, function (err, fd) {
          if (err) {
            self.emit('error', err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit('open', fd);
          self._read();
        });
      }
      function WriteStream(path, options2) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options2);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = 'w';
        this.encoding = 'binary';
        this.mode = 438;
        this.bytesWritten = 0;
        options2 = options2 || {};
        var keys = Object.keys(options2);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options2[key];
        }
        if (this.start !== void 0) {
          if ('number' !== typeof this.start) {
            throw TypeError('start must be a Number');
          }
          if (this.start < 0) {
            throw new Error('start must be >= zero');
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs2.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  },
});

// node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  'node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/clone.js'(exports2, module2) {
    'use strict';
    module2.exports = clone;
    var getPrototypeOf =
      Object.getPrototypeOf ||
      function (obj) {
        return obj.__proto__;
      };
    function clone(obj) {
      if (obj === null || typeof obj !== 'object') return obj;
      if (obj instanceof Object) var copy = { __proto__: getPrototypeOf(obj) };
      else var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function (key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  },
});

// node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  'node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/graceful-fs.js'(exports2, module2) {
    var fs2 = require('fs');
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require('util');
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
      gracefulQueue = Symbol.for('graceful-fs.queue');
      previousSymbol = Symbol.for('graceful-fs.previous');
    } else {
      gracefulQueue = '___graceful-fs.queue';
      previousSymbol = '___graceful-fs.previous';
    }
    function noop2() {}
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function () {
          return queue2;
        },
      });
    }
    var debug = noop2;
    if (util.debuglog) debug = util.debuglog('gfs4');
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
      debug = function () {
        var m = util.format.apply(util, arguments);
        m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
        console.error(m);
      };
    if (!fs2[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs2, queue);
      fs2.close = (function (fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs2, fd, function (err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === 'function') cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close,
        });
        return close;
      })(fs2.close);
      fs2.closeSync = (function (fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs2, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync,
        });
        return closeSync;
      })(fs2.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
        process.on('exit', function () {
          debug(fs2[gracefulQueue]);
          require('assert').equal(fs2[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs2[gracefulQueue]);
    }
    module2.exports = patch(clone(fs2));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
      module2.exports = patch(fs2);
      fs2.__patched = true;
    }
    function patch(fs3) {
      polyfills(fs3);
      fs3.gracefulify = patch;
      fs3.createReadStream = createReadStream;
      fs3.createWriteStream = createWriteStream;
      var fs$readFile = fs3.readFile;
      fs3.readFile = readFile;
      function readFile(path, options2, cb) {
        if (typeof options2 === 'function') (cb = options2), (options2 = null);
        return go$readFile(path, options2, cb);
        function go$readFile(path2, options3, cb2, startTime) {
          return fs$readFile(path2, options3, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$readFile, [path2, options3, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === 'function') cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs3.writeFile;
      fs3.writeFile = writeFile;
      function writeFile(path, data, options2, cb) {
        if (typeof options2 === 'function') (cb = options2), (options2 = null);
        return go$writeFile(path, data, options2, cb);
        function go$writeFile(path2, data2, options3, cb2, startTime) {
          return fs$writeFile(path2, data2, options3, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$writeFile, [path2, data2, options3, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === 'function') cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs3.appendFile;
      if (fs$appendFile) fs3.appendFile = appendFile;
      function appendFile(path, data, options2, cb) {
        if (typeof options2 === 'function') (cb = options2), (options2 = null);
        return go$appendFile(path, data, options2, cb);
        function go$appendFile(path2, data2, options3, cb2, startTime) {
          return fs$appendFile(path2, data2, options3, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$appendFile, [path2, data2, options3, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === 'function') cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs3.copyFile;
      if (fs$copyFile) fs3.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === 'function') {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === 'function') cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs3.readdir;
      fs3.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options2, cb) {
        if (typeof options2 === 'function') (cb = options2), (options2 = null);
        var go$readdir = noReaddirOptionVersions.test(process.version)
          ? function go$readdir2(path2, options3, cb2, startTime) {
              return fs$readdir(path2, fs$readdirCallback(path2, options3, cb2, startTime));
            }
          : function go$readdir2(path2, options3, cb2, startTime) {
              return fs$readdir(path2, options3, fs$readdirCallback(path2, options3, cb2, startTime));
            };
        return go$readdir(path, options2, cb);
        function fs$readdirCallback(path2, options3, cb2, startTime) {
          return function (err, files) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$readdir, [path2, options3, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (files && files.sort) files.sort();
              if (typeof cb2 === 'function') cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === 'v0.8') {
        var legStreams = legacy(fs3);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs3.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs3.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs3, 'ReadStream', {
        get: function () {
          return ReadStream;
        },
        set: function (val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true,
      });
      Object.defineProperty(fs3, 'WriteStream', {
        get: function () {
          return WriteStream;
        },
        set: function (val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true,
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs3, 'FileReadStream', {
        get: function () {
          return FileReadStream;
        },
        set: function (val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true,
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs3, 'FileWriteStream', {
        get: function () {
          return FileWriteStream;
        },
        set: function (val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true,
      });
      function ReadStream(path, options2) {
        if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
        else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            if (that.autoClose) that.destroy();
            that.emit('error', err);
          } else {
            that.fd = fd;
            that.emit('open', fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options2) {
        if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
        else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            that.destroy();
            that.emit('error', err);
          } else {
            that.fd = fd;
            that.emit('open', fd);
          }
        });
      }
      function createReadStream(path, options2) {
        return new fs3.ReadStream(path, options2);
      }
      function createWriteStream(path, options2) {
        return new fs3.WriteStream(path, options2);
      }
      var fs$open = fs3.open;
      fs3.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === 'function') (cb = mode), (mode = null);
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function (err, fd) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === 'function') cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs3;
    }
    function enqueue(elem) {
      debug('ENQUEUE', elem[0].name, elem[1]);
      fs2[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs2[gracefulQueue].length; ++i) {
        if (fs2[gracefulQueue][i].length > 2) {
          fs2[gracefulQueue][i][3] = now;
          fs2[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs2[gracefulQueue].length === 0) return;
      var elem = fs2[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug('RETRY', fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug('TIMEOUT', fn.name, args);
        var cb = args.pop();
        if (typeof cb === 'function') cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug('RETRY', fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs2[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  },
});

// node_modules/@pnpm/network.ca-file/dist/ca-file.js
var require_ca_file = __commonJS({
  'node_modules/@pnpm/network.ca-file/dist/ca-file.js'(exports2) {
    'use strict';
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, '__esModule', { value: true });
    exports2.readCAFileSync = void 0;
    var graceful_fs_1 = __importDefault(require_graceful_fs());
    function readCAFileSync(filePath) {
      try {
        const contents = graceful_fs_1.default.readFileSync(filePath, 'utf8');
        const delim = '-----END CERTIFICATE-----';
        const output = contents
          .split(delim)
          .filter((ca) => Boolean(ca.trim()))
          .map((ca) => `${ca.trimLeft()}${delim}`);
        return output;
      } catch (err) {
        if (err.code === 'ENOENT') return void 0;
        throw err;
      }
    }
    exports2.readCAFileSync = readCAFileSync;
  },
});

// node_modules/@pnpm/network.ca-file/dist/index.js
var require_dist = __commonJS({
  'node_modules/@pnpm/network.ca-file/dist/index.js'(exports2) {
    'use strict';
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (p !== 'default' && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
      };
    Object.defineProperty(exports2, '__esModule', { value: true });
    __exportStar(require_ca_file(), exports2);
  },
});

// node_modules/proto-list/proto-list.js
var require_proto_list = __commonJS({
  'node_modules/proto-list/proto-list.js'(exports2, module2) {
    module2.exports = ProtoList;
    function setProto(obj, proto2) {
      if (typeof Object.setPrototypeOf === 'function') return Object.setPrototypeOf(obj, proto2);
      else obj.__proto__ = proto2;
    }
    function ProtoList() {
      this.list = [];
      var root = null;
      Object.defineProperty(this, 'root', {
        get: function () {
          return root;
        },
        set: function (r) {
          root = r;
          if (this.list.length) {
            setProto(this.list[this.list.length - 1], r);
          }
        },
        enumerable: true,
        configurable: true,
      });
    }
    ProtoList.prototype = {
      get length() {
        return this.list.length;
      },
      get keys() {
        var k = [];
        for (var i in this.list[0]) k.push(i);
        return k;
      },
      get snapshot() {
        var o = {};
        this.keys.forEach(function (k) {
          o[k] = this.get(k);
        }, this);
        return o;
      },
      get store() {
        return this.list[0];
      },
      push: function (obj) {
        if (typeof obj !== 'object') obj = { valueOf: obj };
        if (this.list.length >= 1) {
          setProto(this.list[this.list.length - 1], obj);
        }
        setProto(obj, this.root);
        return this.list.push(obj);
      },
      pop: function () {
        if (this.list.length >= 2) {
          setProto(this.list[this.list.length - 2], this.root);
        }
        return this.list.pop();
      },
      unshift: function (obj) {
        setProto(obj, this.list[0] || this.root);
        return this.list.unshift(obj);
      },
      shift: function () {
        if (this.list.length === 1) {
          setProto(this.list[0], this.root);
        }
        return this.list.shift();
      },
      get: function (key) {
        return this.list[0][key];
      },
      set: function (key, val, save) {
        if (!this.length) this.push({});
        if (save && this.list[0].hasOwnProperty(key)) this.push({});
        return (this.list[0][key] = val);
      },
      forEach: function (fn, thisp) {
        for (var key in this.list[0]) fn.call(thisp, key, this.list[0][key]);
      },
      slice: function () {
        return this.list.slice.apply(this.list, arguments);
      },
      splice: function () {
        var ret = this.list.splice.apply(this.list, arguments);
        for (var i = 0, l = this.list.length; i < l; i++) {
          setProto(this.list[i], this.list[i + 1] || this.root);
        }
        return ret;
      },
    };
  },
});

// node_modules/config-chain/index.js
var require_config_chain = __commonJS({
  'node_modules/config-chain/index.js'(exports2, module2) {
    var ProtoList = require_proto_list();
    var path = require('path');
    var fs2 = require('fs');
    var ini = require_ini();
    var EE = require('events').EventEmitter;
    var url = require('url');
    var http = require('http');
    var exports2 = (module2.exports = function () {
      var args = [].slice.call(arguments),
        conf = new ConfigChain();
      while (args.length) {
        var a = args.shift();
        if (a) conf.push('string' === typeof a ? json(a) : a);
      }
      return conf;
    });
    var find = (exports2.find = function () {
      var rel = path.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file = path.join(start, rel2);
        try {
          fs2.statSync(file);
          return file;
        } catch (err) {
          if (path.dirname(start) !== start) return find2(path.dirname(start), rel2);
        }
      }
      return find2(__dirname, rel);
    });
    var parse2 = (exports2.parse = function (content, file, type) {
      content = '' + content;
      if (!type) {
        try {
          return JSON.parse(content);
        } catch (er) {
          return ini.parse(content);
        }
      } else if (type === 'json') {
        if (this.emit) {
          try {
            return JSON.parse(content);
          } catch (er) {
            this.emit('error', er);
          }
        } else {
          return JSON.parse(content);
        }
      } else {
        return ini.parse(content);
      }
    });
    var json = (exports2.json = function () {
      var args = [].slice.call(arguments).filter(function (arg) {
        return arg != null;
      });
      var file = path.join.apply(null, args);
      var content;
      try {
        content = fs2.readFileSync(file, 'utf-8');
      } catch (err) {
        return;
      }
      return parse2(content, file, 'json');
    });
    var env2 = (exports2.env = function (prefix, env3) {
      env3 = env3 || process.env;
      var obj = {};
      var l = prefix.length;
      for (var k in env3) {
        if (k.indexOf(prefix) === 0) obj[k.substring(l)] = env3[k];
      }
      return obj;
    });
    exports2.ConfigChain = ConfigChain;
    function ConfigChain() {
      EE.apply(this);
      ProtoList.apply(this, arguments);
      this._awaiting = 0;
      this._saving = 0;
      this.sources = {};
    }
    var extras = {
      constructor: { value: ConfigChain },
    };
    Object.keys(EE.prototype).forEach(function (k) {
      extras[k] = Object.getOwnPropertyDescriptor(EE.prototype, k);
    });
    ConfigChain.prototype = Object.create(ProtoList.prototype, extras);
    ConfigChain.prototype.del = function (key, where) {
      if (where) {
        var target = this.sources[where];
        target = target && target.data;
        if (!target) {
          return this.emit('error', new Error('not found ' + where));
        }
        delete target[key];
      } else {
        for (var i = 0, l = this.list.length; i < l; i++) {
          delete this.list[i][key];
        }
      }
      return this;
    };
    ConfigChain.prototype.set = function (key, value, where) {
      var target;
      if (where) {
        target = this.sources[where];
        target = target && target.data;
        if (!target) {
          return this.emit('error', new Error('not found ' + where));
        }
      } else {
        target = this.list[0];
        if (!target) {
          return this.emit('error', new Error('cannot set, no confs!'));
        }
      }
      target[key] = value;
      return this;
    };
    ConfigChain.prototype.get = function (key, where) {
      if (where) {
        where = this.sources[where];
        if (where) where = where.data;
        if (where && Object.hasOwnProperty.call(where, key)) return where[key];
        return void 0;
      }
      return this.list[0][key];
    };
    ConfigChain.prototype.save = function (where, type, cb) {
      if (typeof type === 'function') (cb = type), (type = null);
      var target = this.sources[where];
      if (!target || !(target.path || target.source) || !target.data) {
        return this.emit('error', new Error('bad save target: ' + where));
      }
      if (target.source) {
        var pref = target.prefix || '';
        Object.keys(target.data).forEach(function (k) {
          target.source[pref + k] = target.data[k];
        });
        return this;
      }
      var type = type || target.type;
      var data = target.data;
      if (target.type === 'json') {
        data = JSON.stringify(data);
      } else {
        data = ini.stringify(data);
      }
      this._saving++;
      fs2.writeFile(
        target.path,
        data,
        'utf8',
        function (er) {
          this._saving--;
          if (er) {
            if (cb) return cb(er);
            else return this.emit('error', er);
          }
          if (this._saving === 0) {
            if (cb) cb();
            this.emit('save');
          }
        }.bind(this),
      );
      return this;
    };
    ConfigChain.prototype.addFile = function (file, type, name) {
      name = name || file;
      var marker = { __source__: name };
      this.sources[name] = { path: file, type };
      this.push(marker);
      this._await();
      fs2.readFile(
        file,
        'utf8',
        function (er, data) {
          if (er) this.emit('error', er);
          this.addString(data, file, type, marker);
        }.bind(this),
      );
      return this;
    };
    ConfigChain.prototype.addEnv = function (prefix, env3, name) {
      name = name || 'env';
      var data = exports2.env(prefix, env3);
      this.sources[name] = { data, source: env3, prefix };
      return this.add(data, name);
    };
    ConfigChain.prototype.addUrl = function (req, type, name) {
      this._await();
      var href = url.format(req);
      name = name || href;
      var marker = { __source__: name };
      this.sources[name] = { href, type };
      this.push(marker);
      http
        .request(
          req,
          function (res) {
            var c = [];
            var ct = res.headers['content-type'];
            if (!type) {
              type =
                ct.indexOf('json') !== -1
                  ? 'json'
                  : ct.indexOf('ini') !== -1
                    ? 'ini'
                    : href.match(/\.json$/)
                      ? 'json'
                      : href.match(/\.ini$/)
                        ? 'ini'
                        : null;
              marker.type = type;
            }
            res
              .on('data', c.push.bind(c))
              .on(
                'end',
                function () {
                  this.addString(Buffer.concat(c), href, type, marker);
                }.bind(this),
              )
              .on('error', this.emit.bind(this, 'error'));
          }.bind(this),
        )
        .on('error', this.emit.bind(this, 'error'))
        .end();
      return this;
    };
    ConfigChain.prototype.addString = function (data, file, type, marker) {
      data = this.parse(data, file, type);
      this.add(data, marker);
      return this;
    };
    ConfigChain.prototype.add = function (data, marker) {
      if (marker && typeof marker === 'object') {
        var i = this.list.indexOf(marker);
        if (i === -1) {
          return this.emit('error', new Error('bad marker'));
        }
        this.splice(i, 1, data);
        marker = marker.__source__;
        this.sources[marker] = this.sources[marker] || {};
        this.sources[marker].data = data;
        this._resolve();
      } else {
        if (typeof marker === 'string') {
          this.sources[marker] = this.sources[marker] || {};
          this.sources[marker].data = data;
        }
        this._await();
        this.push(data);
        process.nextTick(this._resolve.bind(this));
      }
      return this;
    };
    ConfigChain.prototype.parse = exports2.parse;
    ConfigChain.prototype._await = function () {
      this._awaiting++;
    };
    ConfigChain.prototype._resolve = function () {
      this._awaiting--;
      if (this._awaiting === 0) this.emit('load', this);
    };
  },
});

// node_modules/@pnpm/npm-conf/lib/envKeyToSetting.js
var require_envKeyToSetting = __commonJS({
  'node_modules/@pnpm/npm-conf/lib/envKeyToSetting.js'(exports2, module2) {
    module2.exports = function (x) {
      const colonIndex = x.indexOf(':');
      if (colonIndex === -1) {
        return normalize(x);
      }
      const firstPart = x.substr(0, colonIndex);
      const secondPart = x.substr(colonIndex + 1);
      return `${normalize(firstPart)}:${normalize(secondPart)}`;
    };
    function normalize(s) {
      s = s.toLowerCase();
      if (s === '_authtoken') return '_authToken';
      let r = s[0];
      for (let i = 1; i < s.length; i++) {
        r += s[i] === '_' ? '-' : s[i];
      }
      return r;
    }
  },
});

// node_modules/@pnpm/config.env-replace/dist/env-replace.js
var require_env_replace = __commonJS({
  'node_modules/@pnpm/config.env-replace/dist/env-replace.js'(exports2) {
    'use strict';
    Object.defineProperty(exports2, '__esModule', { value: true });
    exports2.envReplace = void 0;
    var ENV_EXPR = /(?<!\\)(\\*)\$\{([^${}]+)\}/g;
    function envReplace(settingValue, env2) {
      return settingValue.replace(ENV_EXPR, replaceEnvMatch.bind(null, env2));
    }
    exports2.envReplace = envReplace;
    function replaceEnvMatch(env2, orig, escape, name) {
      if (escape.length % 2) {
        return orig.slice((escape.length + 1) / 2);
      }
      const envValue = getEnvValue(env2, name);
      if (envValue === void 0) {
        throw new Error(`Failed to replace env in config: ${orig}`);
      }
      return `${escape.slice(escape.length / 2)}${envValue}`;
    }
    var ENV_VALUE = /([^:-]+)(:?)-(.+)/;
    function getEnvValue(env2, name) {
      const matched = name.match(ENV_VALUE);
      if (!matched) return env2[name];
      const [, variableName, colon, fallback2] = matched;
      if (Object.prototype.hasOwnProperty.call(env2, variableName)) {
        return !env2[variableName] && colon ? fallback2 : env2[variableName];
      }
      return fallback2;
    }
  },
});

// node_modules/@pnpm/config.env-replace/dist/index.js
var require_dist2 = __commonJS({
  'node_modules/@pnpm/config.env-replace/dist/index.js'(exports2) {
    'use strict';
    Object.defineProperty(exports2, '__esModule', { value: true });
    exports2.envReplace = void 0;
    var env_replace_1 = require_env_replace();
    Object.defineProperty(exports2, 'envReplace', {
      enumerable: true,
      get: function () {
        return env_replace_1.envReplace;
      },
    });
  },
});

// node_modules/@pnpm/npm-conf/lib/util.js
var require_util = __commonJS({
  'node_modules/@pnpm/npm-conf/lib/util.js'(exports2) {
    'use strict';
    var fs2 = require('fs');
    var path = require('path');
    var { envReplace } = require_dist2();
    var parseKey = (key) => {
      if (typeof key !== 'string') {
        return key;
      }
      return envReplace(key, process.env);
    };
    var parseField = (types, field, key) => {
      if (typeof field !== 'string') {
        return field;
      }
      const typeList = [].concat(types[key]);
      const isPath = typeList.indexOf(path) !== -1;
      const isBool = typeList.indexOf(Boolean) !== -1;
      const isString = typeList.indexOf(String) !== -1;
      const isNumber = typeList.indexOf(Number) !== -1;
      field = `${field}`.trim();
      if (/^".*"$/.test(field)) {
        try {
          field = JSON.parse(field);
        } catch (error) {
          throw new Error(`Failed parsing JSON config key ${key}: ${field}`);
        }
      }
      if (isBool && !isString && field === '') {
        return true;
      }
      switch (field) {
        // eslint-disable-line default-case
        case 'true': {
          return true;
        }
        case 'false': {
          return false;
        }
        case 'null': {
          return null;
        }
        case 'undefined': {
          return void 0;
        }
      }
      field = envReplace(field, process.env);
      if (isPath) {
        const regex2 = process.platform === 'win32' ? /^~(\/|\\)/ : /^~\//;
        if (regex2.test(field) && process.env.HOME) {
          field = path.resolve(process.env.HOME, field.substr(2));
        }
        field = path.resolve(field);
      }
      if (isNumber && !isNaN(field)) {
        field = Number(field);
      }
      return field;
    };
    var findPrefix = (name) => {
      name = path.resolve(name);
      let walkedUp = false;
      while (path.basename(name) === 'node_modules') {
        name = path.dirname(name);
        walkedUp = true;
      }
      if (walkedUp) {
        return name;
      }
      const find = (name2, original) => {
        const regex2 = /^[a-zA-Z]:(\\|\/)?$/;
        if (name2 === '/' || (process.platform === 'win32' && regex2.test(name2))) {
          return original;
        }
        try {
          const files = fs2.readdirSync(name2);
          if (
            files.includes('node_modules') ||
            files.includes('package.json') ||
            files.includes('package.json5') ||
            files.includes('package.yaml') ||
            files.includes('pnpm-workspace.yaml')
          ) {
            return name2;
          }
          const dirname = path.dirname(name2);
          if (dirname === name2) {
            return original;
          }
          return find(dirname, original);
        } catch (error) {
          if (name2 === original) {
            if (error.code === 'ENOENT') {
              return original;
            }
            throw error;
          }
          return original;
        }
      };
      return find(name, name);
    };
    exports2.envReplace = envReplace;
    exports2.findPrefix = findPrefix;
    exports2.parseField = parseField;
    exports2.parseKey = parseKey;
  },
});

// node_modules/@pnpm/npm-conf/lib/types.js
var require_types = __commonJS({
  'node_modules/@pnpm/npm-conf/lib/types.js'(exports2) {
    'use strict';
    var path = require('path');
    var Stream = require('stream').Stream;
    var url = require('url');
    var Umask = () => {};
    var getLocalAddresses = () => [];
    var semver3 = () => {};
    exports2.types = {
      access: [null, 'restricted', 'public'],
      'allow-same-version': Boolean,
      'always-auth': Boolean,
      also: [null, 'dev', 'development'],
      audit: Boolean,
      'auth-type': ['legacy', 'sso', 'saml', 'oauth'],
      'bin-links': Boolean,
      browser: [null, String],
      ca: [null, String, Array],
      cafile: path,
      cache: path,
      'cache-lock-stale': Number,
      'cache-lock-retries': Number,
      'cache-lock-wait': Number,
      'cache-max': Number,
      'cache-min': Number,
      cert: [null, String],
      cidr: [null, String, Array],
      color: ['always', Boolean],
      depth: Number,
      description: Boolean,
      dev: Boolean,
      'dry-run': Boolean,
      editor: String,
      'engine-strict': Boolean,
      force: Boolean,
      'fetch-retries': Number,
      'fetch-retry-factor': Number,
      'fetch-retry-mintimeout': Number,
      'fetch-retry-maxtimeout': Number,
      git: String,
      'git-tag-version': Boolean,
      'commit-hooks': Boolean,
      global: Boolean,
      globalconfig: path,
      'global-style': Boolean,
      group: [Number, String],
      'https-proxy': [null, url],
      'user-agent': String,
      'ham-it-up': Boolean,
      heading: String,
      'if-present': Boolean,
      'ignore-prepublish': Boolean,
      'ignore-scripts': Boolean,
      'init-module': path,
      'init-author-name': String,
      'init-author-email': String,
      'init-author-url': ['', url],
      'init-license': String,
      'init-version': semver3,
      json: Boolean,
      key: [null, String],
      'legacy-bundling': Boolean,
      link: Boolean,
      // local-address must be listed as an IP for a local network interface
      // must be IPv4 due to node bug
      'local-address': getLocalAddresses(),
      loglevel: ['silent', 'error', 'warn', 'notice', 'http', 'timing', 'info', 'verbose', 'silly'],
      logstream: Stream,
      'logs-max': Number,
      long: Boolean,
      maxsockets: Number,
      message: String,
      'metrics-registry': [null, String],
      'node-options': [null, String],
      'node-version': [null, semver3],
      'no-proxy': [null, String, Array],
      offline: Boolean,
      'onload-script': [null, String],
      only: [null, 'dev', 'development', 'prod', 'production'],
      optional: Boolean,
      'package-lock': Boolean,
      otp: [null, String],
      'package-lock-only': Boolean,
      parseable: Boolean,
      'prefer-offline': Boolean,
      'prefer-online': Boolean,
      prefix: path,
      production: Boolean,
      progress: Boolean,
      proxy: [null, false, url],
      provenance: Boolean,
      // allow proxy to be disabled explicitly
      'read-only': Boolean,
      'rebuild-bundle': Boolean,
      registry: [null, url],
      rollback: Boolean,
      save: Boolean,
      'save-bundle': Boolean,
      'save-dev': Boolean,
      'save-exact': Boolean,
      'save-optional': Boolean,
      'save-prefix': String,
      'save-prod': Boolean,
      scope: String,
      'script-shell': [null, String],
      'scripts-prepend-node-path': [false, true, 'auto', 'warn-only'],
      searchopts: String,
      searchexclude: [null, String],
      searchlimit: Number,
      searchstaleness: Number,
      'send-metrics': Boolean,
      shell: String,
      shrinkwrap: Boolean,
      'sign-git-tag': Boolean,
      'sso-poll-frequency': Number,
      'sso-type': [null, 'oauth', 'saml'],
      'strict-ssl': Boolean,
      tag: String,
      timing: Boolean,
      tmp: path,
      unicode: Boolean,
      'unsafe-perm': Boolean,
      usage: Boolean,
      user: [Number, String],
      userconfig: path,
      umask: Umask,
      version: Boolean,
      'tag-version-prefix': String,
      versions: Boolean,
      viewer: String,
      _exit: Boolean,
    };
  },
});

// node_modules/@pnpm/npm-conf/lib/conf.js
var require_conf = __commonJS({
  'node_modules/@pnpm/npm-conf/lib/conf.js'(exports2, module2) {
    'use strict';
    var { readCAFileSync } = require_dist();
    var fs2 = require('fs');
    var path = require('path');
    var { ConfigChain } = require_config_chain();
    var envKeyToSetting = require_envKeyToSetting();
    var util = require_util();
    var Conf = class extends ConfigChain {
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L203-L217
      constructor(base, types) {
        super(base);
        this.root = base;
        this._parseField = util.parseField.bind(null, types || require_types());
      }
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L326-L338
      add(data, marker) {
        try {
          for (const [key, value] of Object.entries(data)) {
            const substKey = util.parseKey(key);
            if (substKey !== key) {
              delete data[key];
            }
            data[substKey] = this._parseField(value, substKey);
          }
        } catch (error) {
          throw error;
        }
        return super.add(data, marker);
      }
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L306-L319
      addFile(file, name) {
        name = name || file;
        const marker = { __source__: name };
        this.sources[name] = { path: file, type: 'ini' };
        this.push(marker);
        this._await();
        try {
          const contents = fs2.readFileSync(file, 'utf8');
          this.addString(contents, file, 'ini', marker);
        } catch (error) {
          if (error.code === 'ENOENT') {
            this.add({}, marker);
          } else if (error.code !== 'EISDIR') {
            return `Issue while reading "${file}". ${error.message}`;
          }
        }
      }
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L341-L357
      addEnv(env2) {
        env2 = env2 || process.env;
        const conf = {};
        Object.keys(env2)
          .filter((x) => /^npm_config_/i.test(x))
          .forEach((x) => {
            if (!env2[x]) {
              return;
            }
            const key = envKeyToSetting(x.substr(11));
            const rawVal = env2[x];
            conf[key] = deserializeEnvVal(key, rawVal);
          });
        return super.addEnv('', conf, 'env');
      }
      // https://github.com/npm/cli/blob/latest/lib/config/load-prefix.js
      loadPrefix() {
        const cli = this.list[0];
        Object.defineProperty(this, 'prefix', {
          enumerable: true,
          set: (prefix) => {
            const g = this.get('global');
            this[g ? 'globalPrefix' : 'localPrefix'] = prefix;
          },
          get: () => {
            const g = this.get('global');
            return g ? this.globalPrefix : this.localPrefix;
          },
        });
        Object.defineProperty(this, 'globalPrefix', {
          enumerable: true,
          set: (prefix) => {
            this.set('prefix', prefix);
          },
          get: () => {
            return path.resolve(this.get('prefix'));
          },
        });
        let p;
        Object.defineProperty(this, 'localPrefix', {
          enumerable: true,
          set: (prefix) => {
            p = prefix;
          },
          get: () => {
            return p;
          },
        });
        if (Object.prototype.hasOwnProperty.call(cli, 'prefix')) {
          p = path.resolve(cli.prefix);
        } else {
          try {
            const prefix = util.findPrefix(process.cwd());
            p = prefix;
          } catch (error) {
            throw error;
          }
        }
        return p;
      }
      // https://github.com/npm/cli/blob/latest/lib/config/load-cafile.js
      loadCAFile(file) {
        if (!file) {
          return;
        }
        const ca = readCAFileSync(file);
        if (ca) {
          this.set('ca', ca);
        }
      }
      // https://github.com/npm/cli/blob/latest/lib/config/set-user.js
      loadUser() {
        const defConf = this.root;
        if (this.get('global')) {
          return;
        }
        if (process.env.SUDO_UID) {
          defConf.user = Number(process.env.SUDO_UID);
          return;
        }
        const prefix = path.resolve(this.get('prefix'));
        try {
          const stats = fs2.statSync(prefix);
          defConf.user = stats.uid;
        } catch (error) {
          if (error.code === 'ENOENT') {
            return;
          }
          throw error;
        }
      }
    };
    function deserializeEnvVal(envKey, envValue) {
      function deserializeList(envValue2) {
        const npmConfigSep = '\n\n';
        if (envValue2.indexOf(npmConfigSep)) {
          return envValue2.split(npmConfigSep);
        }
        return envValue2.split(',');
      }
      switch (envKey) {
        case 'hoist-pattern':
        case 'public-hoist-pattern':
          return deserializeList(envValue);
      }
      return envValue;
    }
    module2.exports = Conf;
  },
});

// node_modules/@pnpm/npm-conf/lib/defaults.js
var require_defaults = __commonJS({
  'node_modules/@pnpm/npm-conf/lib/defaults.js'(exports2) {
    'use strict';
    var os2 = require('os');
    var path = require('path');
    var temp = os2.tmpdir();
    var uidOrPid = process.getuid ? process.getuid() : process.pid;
    var hasUnicode = () => true;
    var isWindows = process.platform === 'win32';
    var osenv = {
      editor: () => process.env.EDITOR || process.env.VISUAL || (isWindows ? 'notepad.exe' : 'vi'),
      shell: () => (isWindows ? process.env.COMSPEC || 'cmd.exe' : process.env.SHELL || '/bin/bash'),
    };
    var umask = {
      fromString: () => process.umask(),
    };
    var home = os2.homedir();
    if (home) {
      process.env.HOME = home;
    } else {
      home = path.resolve(temp, 'npm-' + uidOrPid);
    }
    var cacheExtra = process.platform === 'win32' ? 'npm-cache' : '.npm';
    var cacheRoot = (process.platform === 'win32' && process.env.APPDATA) || home;
    var cache = path.resolve(cacheRoot, cacheExtra);
    var defaults;
    var globalPrefix;
    Object.defineProperty(exports2, 'defaults', {
      get: function () {
        if (defaults) return defaults;
        if (process.env.PREFIX) {
          globalPrefix = process.env.PREFIX;
        } else if (process.platform === 'win32') {
          globalPrefix = path.dirname(process.execPath);
        } else {
          globalPrefix = path.dirname(path.dirname(process.execPath));
          if (process.env.DESTDIR) {
            globalPrefix = path.join(process.env.DESTDIR, globalPrefix);
          }
        }
        defaults = {
          access: null,
          'allow-same-version': false,
          'always-auth': false,
          also: null,
          audit: true,
          'auth-type': 'legacy',
          'bin-links': true,
          browser: null,
          ca: null,
          cafile: null,
          cache,
          'cache-lock-stale': 6e4,
          'cache-lock-retries': 10,
          'cache-lock-wait': 1e4,
          'cache-max': Infinity,
          'cache-min': 10,
          cert: null,
          cidr: null,
          color: process.env.NO_COLOR == null,
          depth: Infinity,
          description: true,
          dev: false,
          'dry-run': false,
          editor: osenv.editor(),
          'engine-strict': false,
          force: false,
          'fetch-retries': 2,
          'fetch-retry-factor': 10,
          'fetch-retry-mintimeout': 1e4,
          'fetch-retry-maxtimeout': 6e4,
          git: 'git',
          'git-tag-version': true,
          'commit-hooks': true,
          global: false,
          globalconfig: path.resolve(globalPrefix, 'etc', 'npmrc'),
          'global-style': false,
          group: process.platform === 'win32' ? 0 : process.env.SUDO_GID || (process.getgid && process.getgid()),
          'ham-it-up': false,
          heading: 'npm',
          'if-present': false,
          'ignore-prepublish': false,
          'ignore-scripts': false,
          'init-module': path.resolve(home, '.npm-init.js'),
          'init-author-name': '',
          'init-author-email': '',
          'init-author-url': '',
          'init-version': '1.0.0',
          'init-license': 'ISC',
          json: false,
          key: null,
          'legacy-bundling': false,
          link: false,
          'local-address': void 0,
          loglevel: 'notice',
          logstream: process.stderr,
          'logs-max': 10,
          long: false,
          maxsockets: 50,
          message: '%s',
          'metrics-registry': null,
          'node-options': null,
          // We remove node-version to fix the issue described here: https://github.com/pnpm/pnpm/issues/4203#issuecomment-1133872769
          offline: false,
          'onload-script': false,
          only: null,
          optional: true,
          otp: null,
          'package-lock': true,
          'package-lock-only': false,
          parseable: false,
          'prefer-offline': false,
          'prefer-online': false,
          prefix: globalPrefix,
          production: process.env.NODE_ENV === 'production',
          progress: !process.env.TRAVIS && !process.env.CI,
          provenance: false,
          proxy: null,
          'https-proxy': null,
          'no-proxy': null,
          'user-agent': 'npm/{npm-version} node/{node-version} {platform} {arch}',
          'read-only': false,
          'rebuild-bundle': true,
          registry: 'https://registry.npmjs.org/',
          rollback: true,
          save: true,
          'save-bundle': false,
          'save-dev': false,
          'save-exact': false,
          'save-optional': false,
          'save-prefix': '^',
          'save-prod': false,
          scope: '',
          'script-shell': null,
          'scripts-prepend-node-path': 'warn-only',
          searchopts: '',
          searchexclude: null,
          searchlimit: 20,
          searchstaleness: 15 * 60,
          'send-metrics': false,
          shell: osenv.shell(),
          shrinkwrap: true,
          'sign-git-tag': false,
          'sso-poll-frequency': 500,
          'sso-type': 'oauth',
          'strict-ssl': true,
          tag: 'latest',
          'tag-version-prefix': 'v',
          timing: false,
          tmp: temp,
          unicode: hasUnicode(),
          'unsafe-perm':
            process.platform === 'win32' ||
            process.platform === 'cygwin' ||
            !(process.getuid && process.setuid && process.getgid && process.setgid) ||
            process.getuid() !== 0,
          usage: false,
          user: process.platform === 'win32' ? 0 : 'nobody',
          userconfig: path.resolve(home, '.npmrc'),
          umask: process.umask ? process.umask() : umask.fromString('022'),
          version: false,
          versions: false,
          viewer: process.platform === 'win32' ? 'browser' : 'man',
          _exit: true,
        };
        return defaults;
      },
    });
  },
});

// node_modules/@pnpm/npm-conf/index.js
var require_npm_conf = __commonJS({
  'node_modules/@pnpm/npm-conf/index.js'(exports2, module2) {
    'use strict';
    var path = require('path');
    var Conf = require_conf();
    var _defaults = require_defaults();
    module2.exports = (opts, types, defaults) => {
      const conf = new Conf(Object.assign({}, _defaults.defaults, defaults), types);
      conf.add(Object.assign({}, opts), 'cli');
      const warnings = [];
      let failedToLoadBuiltInConfig = false;
      if (require.resolve.paths) {
        const paths = require.resolve.paths('npm');
        let npmPath;
        try {
          npmPath = require.resolve('npm', { paths: paths.slice(-1) });
        } catch (error) {
          failedToLoadBuiltInConfig = true;
        }
        if (npmPath) {
          warnings.push(conf.addFile(path.resolve(path.dirname(npmPath), '..', 'npmrc'), 'builtin'));
        }
      }
      conf.addEnv();
      conf.loadPrefix();
      const projectConf = path.resolve(conf.localPrefix, '.npmrc');
      const userConf = conf.get('userconfig');
      if (!conf.get('global') && projectConf !== userConf) {
        warnings.push(conf.addFile(projectConf, 'project'));
      } else {
        conf.add({}, 'project');
      }
      if (conf.get('workspace-prefix') && conf.get('workspace-prefix') !== projectConf) {
        const workspaceConf = path.resolve(conf.get('workspace-prefix'), '.npmrc');
        warnings.push(conf.addFile(workspaceConf, 'workspace'));
      }
      warnings.push(conf.addFile(conf.get('userconfig'), 'user'));
      if (conf.get('prefix')) {
        const etc = path.resolve(conf.get('prefix'), 'etc');
        conf.root.globalconfig = path.resolve(etc, 'npmrc');
        conf.root.globalignorefile = path.resolve(etc, 'npmignore');
      }
      warnings.push(conf.addFile(conf.get('globalconfig'), 'global'));
      conf.loadUser();
      const caFile = conf.get('cafile');
      if (caFile) {
        conf.loadCAFile(caFile);
      }
      return {
        config: conf,
        warnings: warnings.filter(Boolean),
        failedToLoadBuiltInConfig,
      };
    };
    Object.defineProperty(module2.exports, 'defaults', {
      get() {
        return _defaults.defaults;
      },
      enumerable: true,
    });
  },
});

// node_modules/registry-auth-token/index.js
var require_registry_auth_token = __commonJS({
  'node_modules/registry-auth-token/index.js'(exports2, module2) {
    var npmConf = require_npm_conf();
    var tokenKey = ':_authToken';
    var legacyTokenKey = ':_auth';
    var userKey = ':username';
    var passwordKey = ':_password';
    module2.exports = function getRegistryAuthToken() {
      let checkUrl;
      let options2;
      if (arguments.length >= 2) {
        checkUrl = arguments[0];
        options2 = Object.assign({}, arguments[1]);
      } else if (typeof arguments[0] === 'string') {
        checkUrl = arguments[0];
      } else {
        options2 = Object.assign({}, arguments[0]);
      }
      options2 = options2 || {};
      const providedNpmrc = options2.npmrc;
      options2.npmrc = (
        options2.npmrc
          ? {
              config: {
                get: (key) => providedNpmrc[key],
              },
            }
          : npmConf()
      ).config;
      checkUrl = checkUrl || options2.npmrc.get('registry') || npmConf.defaults.registry;
      return getRegistryAuthInfo(checkUrl, options2) || getLegacyAuthInfo(options2.npmrc);
    };
    function urlResolve(from, to) {
      const resolvedUrl = new URL(to, new URL(from.startsWith('//') ? `./${from}` : from, 'resolve://'));
      if (resolvedUrl.protocol === 'resolve:') {
        const { pathname, search, hash } = resolvedUrl;
        return pathname + search + hash;
      }
      return resolvedUrl.toString();
    }
    function getRegistryAuthInfo(checkUrl, options2) {
      let parsed =
        checkUrl instanceof URL ? checkUrl : new URL(checkUrl.startsWith('//') ? `http:${checkUrl}` : checkUrl);
      let pathname;
      while (pathname !== '/' && parsed.pathname !== pathname) {
        pathname = parsed.pathname || '/';
        const regUrl = '//' + parsed.host + pathname.replace(/\/$/, '');
        const authInfo = getAuthInfoForUrl(regUrl, options2.npmrc);
        if (authInfo) {
          return authInfo;
        }
        if (!options2.recursive) {
          return /\/$/.test(checkUrl) ? void 0 : getRegistryAuthInfo(new URL('./', parsed), options2);
        }
        parsed.pathname = urlResolve(normalizePath(pathname), '..') || '/';
      }
      return void 0;
    }
    function getLegacyAuthInfo(npmrc) {
      if (!npmrc.get('_auth')) {
        return void 0;
      }
      const token = replaceEnvironmentVariable(npmrc.get('_auth'));
      return { token, type: 'Basic' };
    }
    function normalizePath(path) {
      return path[path.length - 1] === '/' ? path : path + '/';
    }
    function getAuthInfoForUrl(regUrl, npmrc) {
      const bearerAuth = getBearerToken(npmrc.get(regUrl + tokenKey) || npmrc.get(regUrl + '/' + tokenKey));
      if (bearerAuth) {
        return bearerAuth;
      }
      const username = npmrc.get(regUrl + userKey) || npmrc.get(regUrl + '/' + userKey);
      const password = npmrc.get(regUrl + passwordKey) || npmrc.get(regUrl + '/' + passwordKey);
      const basicAuth = getTokenForUsernameAndPassword(username, password);
      if (basicAuth) {
        return basicAuth;
      }
      const basicAuthWithToken = getLegacyAuthToken(
        npmrc.get(regUrl + legacyTokenKey) || npmrc.get(regUrl + '/' + legacyTokenKey),
      );
      if (basicAuthWithToken) {
        return basicAuthWithToken;
      }
      return void 0;
    }
    function replaceEnvironmentVariable(token) {
      return token.replace(/^\$\{?([^}]*)\}?$/, function (fullMatch, envVar) {
        return process.env[envVar];
      });
    }
    function getBearerToken(tok) {
      if (!tok) {
        return void 0;
      }
      const token = replaceEnvironmentVariable(tok);
      return { token, type: 'Bearer' };
    }
    function getTokenForUsernameAndPassword(username, password) {
      if (!username || !password) {
        return void 0;
      }
      const pass = Buffer.from(replaceEnvironmentVariable(password), 'base64').toString('utf8');
      const token = Buffer.from(username + ':' + pass, 'utf8').toString('base64');
      return {
        token,
        type: 'Basic',
        password: pass,
        username,
      };
    }
    function getLegacyAuthToken(tok) {
      if (!tok) {
        return void 0;
      }
      const token = replaceEnvironmentVariable(tok);
      return { token, type: 'Basic' };
    }
  },
});

// node_modules/fast-content-type-parse/index.js
var require_fast_content_type_parse = __commonJS({
  'node_modules/fast-content-type-parse/index.js'(exports2, module2) {
    'use strict';
    var NullObject = function NullObject2() {};
    NullObject.prototype = /* @__PURE__ */ Object.create(null);
    var paramRE =
      /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
    var quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
    var mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
    var defaultContentType = { type: '', parameters: new NullObject() };
    Object.freeze(defaultContentType.parameters);
    Object.freeze(defaultContentType);
    function parse2(header) {
      if (typeof header !== 'string') {
        throw new TypeError('argument header is required and must be a string');
      }
      let index = header.indexOf(';');
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        throw new TypeError('invalid media type');
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject(),
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while ((match = paramRE.exec(header))) {
        if (match.index !== index) {
          throw new TypeError('invalid parameter format');
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        throw new TypeError('invalid parameter format');
      }
      return result;
    }
    function safeParse2(header) {
      if (typeof header !== 'string') {
        return defaultContentType;
      }
      let index = header.indexOf(';');
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        return defaultContentType;
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject(),
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while ((match = paramRE.exec(header))) {
        if (match.index !== index) {
          return defaultContentType;
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        return defaultContentType;
      }
      return result;
    }
    module2.exports.default = { parse: parse2, safeParse: safeParse2 };
    module2.exports.parse = parse2;
    module2.exports.safeParse = safeParse2;
    module2.exports.defaultContentType = defaultContentType;
  },
});

// node_modules/commander/lib/error.js
var require_error = __commonJS({
  'node_modules/commander/lib/error.js'(exports2) {
    var CommanderError2 = class extends Error {
      /**
       * Constructs the CommanderError class
       * @param {number} exitCode suggested exit code which could be used with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       */
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      /**
       * Constructs the InvalidArgumentError class
       * @param {string} [message] explanation of why argument is invalid
       */
      constructor(message) {
        super(1, 'commander.invalidArgument', message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports2.CommanderError = CommanderError2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
  },
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  'node_modules/commander/lib/argument.js'(exports2) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument2 = class {
      /**
       * Initialize a new command argument with the given name and description.
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @param {string} name
       * @param {string} [description]
       */
      constructor(name, description) {
        this.description = description || '';
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case '<':
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case '[':
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === '...') {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      /**
       * Return argument name.
       *
       * @return {string}
       */
      name() {
        return this._name;
      }
      /**
       * @package
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Argument}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Set the custom handler for processing CLI command arguments into argument values.
       *
       * @param {Function} [fn]
       * @return {Argument}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Only allow argument value to be one of choices.
       *
       * @param {string[]} values
       * @return {Argument}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(', ')}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Make argument required.
       *
       * @returns {Argument}
       */
      argRequired() {
        this.required = true;
        return this;
      }
      /**
       * Make argument optional.
       *
       * @returns {Argument}
       */
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');
      return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
    }
    exports2.Argument = Argument2;
    exports2.humanReadableArgName = humanReadableArgName;
  },
});

// node_modules/commander/lib/help.js
var require_help = __commonJS({
  'node_modules/commander/lib/help.js'(exports2) {
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.minWidthToWrap = 40;
        this.sortSubcommands = false;
        this.sortOptions = false;
        this.showGlobalOptions = false;
      }
      /**
       * prepareContext is called by Commander after applying overrides from `Command.configureHelp()`
       * and just before calling `formatHelp()`.
       *
       * Commander just uses the helpWidth and the rest is provided for optional use by more complex subclasses.
       *
       * @param {{ error?: boolean, helpWidth?: number, outputHasColors?: boolean }} contextOptions
       */
      prepareContext(contextOptions) {
        this.helpWidth = this.helpWidth ?? contextOptions.helpWidth ?? 80;
      }
      /**
       * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
       *
       * @param {Command} cmd
       * @returns {Command[]}
       */
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        const helpCommand = cmd._getHelpCommand();
        if (helpCommand && !helpCommand._hidden) {
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      /**
       * Compare options for sort.
       *
       * @param {Option} a
       * @param {Option} b
       * @returns {number}
       */
      compareOptions(a, b) {
        const getSortKey = (option) => {
          return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');
        };
        return getSortKey(a).localeCompare(getSortKey(b));
      }
      /**
       * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const helpOption = cmd._getHelpOption();
        if (helpOption && !helpOption.hidden) {
          const removeShort = helpOption.short && cmd._findOption(helpOption.short);
          const removeLong = helpOption.long && cmd._findOption(helpOption.long);
          if (!removeShort && !removeLong) {
            visibleOptions.push(helpOption);
          } else if (helpOption.long && !removeLong) {
            visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description));
          } else if (helpOption.short && !removeShort) {
            visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description));
          }
        }
        if (this.sortOptions) {
          visibleOptions.sort(this.compareOptions);
        }
        return visibleOptions;
      }
      /**
       * Get an array of the visible global options. (Not including help.)
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleGlobalOptions(cmd) {
        if (!this.showGlobalOptions) return [];
        const globalOptions = [];
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
          globalOptions.push(...visibleOptions);
        }
        if (this.sortOptions) {
          globalOptions.sort(this.compareOptions);
        }
        return globalOptions;
      }
      /**
       * Get an array of the arguments if any have a description.
       *
       * @param {Command} cmd
       * @returns {Argument[]}
       */
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd.registeredArguments.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || '';
          });
        }
        if (cmd.registeredArguments.find((argument) => argument.description)) {
          return cmd.registeredArguments;
        }
        return [];
      }
      /**
       * Get the command term to show in the list of subcommands.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandTerm(cmd) {
        const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(' ');
        return (
          cmd._name +
          (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
          (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
          (args ? ' ' + args : '')
        );
      }
      /**
       * Get the option term to show in the list of options.
       *
       * @param {Option} option
       * @returns {string}
       */
      optionTerm(option) {
        return option.flags;
      }
      /**
       * Get the argument term to show in the list of arguments.
       *
       * @param {Argument} argument
       * @returns {string}
       */
      argumentTerm(argument) {
        return argument.name();
      }
      /**
       * Get the longest command term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, this.displayWidth(helper.styleSubcommandTerm(helper.subcommandTerm(command))));
        }, 0);
      }
      /**
       * Get the longest option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
        }, 0);
      }
      /**
       * Get the longest global option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestGlobalOptionTermLength(cmd, helper) {
        return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
          return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
        }, 0);
      }
      /**
       * Get the longest argument term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, this.displayWidth(helper.styleArgumentTerm(helper.argumentTerm(argument))));
        }, 0);
      }
      /**
       * Get the command usage to be displayed at the top of the built-in help.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + '|' + cmd._aliases[0];
        }
        let ancestorCmdNames = '';
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;
        }
        return ancestorCmdNames + cmdName + ' ' + cmd.usage();
      }
      /**
       * Get the description for the command.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandDescription(cmd) {
        return cmd.description();
      }
      /**
       * Get the subcommand summary to show in the list of subcommands.
       * (Fallback to description for backwards compatibility.)
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      /**
       * Get the option description to show in the list of options.
       *
       * @param {Option} option
       * @return {string}
       */
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault =
            option.required || option.optional || (option.isBoolean() && typeof option.defaultValue === 'boolean');
          if (showDefault) {
            extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(', ')})`;
        }
        return option.description;
      }
      /**
       * Get the argument description to show in the list of arguments.
       *
       * @param {Argument} argument
       * @return {string}
       */
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
        }
        if (extraInfo.length > 0) {
          const extraDescription = `(${extraInfo.join(', ')})`;
          if (argument.description) {
            return `${argument.description} ${extraDescription}`;
          }
          return extraDescription;
        }
        return argument.description;
      }
      /**
       * Generate the built-in help text.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {string}
       */
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth ?? 80;
        function callFormatItem(term, description) {
          return helper.formatItem(term, termWidth, description, helper);
        }
        let output = [`${helper.styleTitle('Usage:')} ${helper.styleUsage(helper.commandUsage(cmd))}`, ''];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([helper.boxWrap(helper.styleCommandDescription(commandDescription), helpWidth), '']);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return callFormatItem(
            helper.styleArgumentTerm(helper.argumentTerm(argument)),
            helper.styleArgumentDescription(helper.argumentDescription(argument)),
          );
        });
        if (argumentList.length > 0) {
          output = output.concat([helper.styleTitle('Arguments:'), ...argumentList, '']);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return callFormatItem(
            helper.styleOptionTerm(helper.optionTerm(option)),
            helper.styleOptionDescription(helper.optionDescription(option)),
          );
        });
        if (optionList.length > 0) {
          output = output.concat([helper.styleTitle('Options:'), ...optionList, '']);
        }
        if (helper.showGlobalOptions) {
          const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
            return callFormatItem(
              helper.styleOptionTerm(helper.optionTerm(option)),
              helper.styleOptionDescription(helper.optionDescription(option)),
            );
          });
          if (globalOptionList.length > 0) {
            output = output.concat([helper.styleTitle('Global Options:'), ...globalOptionList, '']);
          }
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return callFormatItem(
            helper.styleSubcommandTerm(helper.subcommandTerm(cmd2)),
            helper.styleSubcommandDescription(helper.subcommandDescription(cmd2)),
          );
        });
        if (commandList.length > 0) {
          output = output.concat([helper.styleTitle('Commands:'), ...commandList, '']);
        }
        return output.join('\n');
      }
      /**
       * Return display width of string, ignoring ANSI escape sequences. Used in padding and wrapping calculations.
       *
       * @param {string} str
       * @returns {number}
       */
      displayWidth(str) {
        return stripColor(str).length;
      }
      /**
       * Style the title for displaying in the help. Called with 'Usage:', 'Options:', etc.
       *
       * @param {string} str
       * @returns {string}
       */
      styleTitle(str) {
        return str;
      }
      styleUsage(str) {
        return str
          .split(' ')
          .map((word) => {
            if (word === '[options]') return this.styleOptionText(word);
            if (word === '[command]') return this.styleSubcommandText(word);
            if (word[0] === '[' || word[0] === '<') return this.styleArgumentText(word);
            return this.styleCommandText(word);
          })
          .join(' ');
      }
      styleCommandDescription(str) {
        return this.styleDescriptionText(str);
      }
      styleOptionDescription(str) {
        return this.styleDescriptionText(str);
      }
      styleSubcommandDescription(str) {
        return this.styleDescriptionText(str);
      }
      styleArgumentDescription(str) {
        return this.styleDescriptionText(str);
      }
      styleDescriptionText(str) {
        return str;
      }
      styleOptionTerm(str) {
        return this.styleOptionText(str);
      }
      styleSubcommandTerm(str) {
        return str
          .split(' ')
          .map((word) => {
            if (word === '[options]') return this.styleOptionText(word);
            if (word[0] === '[' || word[0] === '<') return this.styleArgumentText(word);
            return this.styleSubcommandText(word);
          })
          .join(' ');
      }
      styleArgumentTerm(str) {
        return this.styleArgumentText(str);
      }
      styleOptionText(str) {
        return str;
      }
      styleArgumentText(str) {
        return str;
      }
      styleSubcommandText(str) {
        return str;
      }
      styleCommandText(str) {
        return str;
      }
      /**
       * Calculate the pad width from the maximum term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestGlobalOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper),
        );
      }
      /**
       * Detect manually wrapped and indented strings by checking for line break followed by whitespace.
       *
       * @param {string} str
       * @returns {boolean}
       */
      preformatted(str) {
        return /\n[^\S\r\n]/.test(str);
      }
      /**
       * Format the "item", which consists of a term and description. Pad the term and wrap the description, indenting the following lines.
       *
       * So "TTT", 5, "DDD DDDD DD DDD" might be formatted for this.helpWidth=17 like so:
       *   TTT  DDD DDDD
       *        DD DDD
       *
       * @param {string} term
       * @param {number} termWidth
       * @param {string} description
       * @param {Help} helper
       * @returns {string}
       */
      formatItem(term, termWidth, description, helper) {
        const itemIndent = 2;
        const itemIndentStr = ' '.repeat(itemIndent);
        if (!description) return itemIndentStr + term;
        const paddedTerm = term.padEnd(termWidth + term.length - helper.displayWidth(term));
        const spacerWidth = 2;
        const helpWidth = this.helpWidth ?? 80;
        const remainingWidth = helpWidth - termWidth - spacerWidth - itemIndent;
        let formattedDescription;
        if (remainingWidth < this.minWidthToWrap || helper.preformatted(description)) {
          formattedDescription = description;
        } else {
          const wrappedDescription = helper.boxWrap(description, remainingWidth);
          formattedDescription = wrappedDescription.replace(/\n/g, '\n' + ' '.repeat(termWidth + spacerWidth));
        }
        return (
          itemIndentStr +
          paddedTerm +
          ' '.repeat(spacerWidth) +
          formattedDescription.replace(
            /\n/g,
            `
${itemIndentStr}`,
          )
        );
      }
      /**
       * Wrap a string at whitespace, preserving existing line breaks.
       * Wrapping is skipped if the width is less than `minWidthToWrap`.
       *
       * @param {string} str
       * @param {number} width
       * @returns {string}
       */
      boxWrap(str, width) {
        if (width < this.minWidthToWrap) return str;
        const rawLines = str.split(/\r\n|\n/);
        const chunkPattern = /[\s]*[^\s]+/g;
        const wrappedLines = [];
        rawLines.forEach((line) => {
          const chunks = line.match(chunkPattern);
          if (chunks === null) {
            wrappedLines.push('');
            return;
          }
          let sumChunks = [chunks.shift()];
          let sumWidth = this.displayWidth(sumChunks[0]);
          chunks.forEach((chunk) => {
            const visibleWidth = this.displayWidth(chunk);
            if (sumWidth + visibleWidth <= width) {
              sumChunks.push(chunk);
              sumWidth += visibleWidth;
              return;
            }
            wrappedLines.push(sumChunks.join(''));
            const nextChunk = chunk.trimStart();
            sumChunks = [nextChunk];
            sumWidth = this.displayWidth(nextChunk);
          });
          wrappedLines.push(sumChunks.join(''));
        });
        return wrappedLines.join('\n');
      }
    };
    function stripColor(str) {
      const sgrPattern = /\x1b\[\d*(;\d*)*m/g;
      return str.replace(sgrPattern, '');
    }
    exports2.Help = Help2;
    exports2.stripColor = stripColor;
  },
});

// node_modules/commander/lib/option.js
var require_option = __commonJS({
  'node_modules/commander/lib/option.js'(exports2) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      /**
       * Initialize a new `Option` with the given `flags` and `description`.
       *
       * @param {string} flags
       * @param {string} [description]
       */
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || '';
        this.required = flags.includes('<');
        this.optional = flags.includes('[');
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith('--no-');
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Option}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Preset to use when option used without option-argument, especially optional but also boolean and negated.
       * The custom processing (parseArg) is called.
       *
       * @example
       * new Option('--color').default('GREYSCALE').preset('RGB');
       * new Option('--donate [amount]').preset('20').argParser(parseFloat);
       *
       * @param {*} arg
       * @return {Option}
       */
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      /**
       * Add option name(s) that conflict with this option.
       * An error will be displayed if conflicting options are found during parsing.
       *
       * @example
       * new Option('--rgb').conflicts('cmyk');
       * new Option('--js').conflicts(['ts', 'jsx']);
       *
       * @param {(string | string[])} names
       * @return {Option}
       */
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      /**
       * Specify implied option values for when this option is set and the implied options are not.
       *
       * The custom processing (parseArg) is not called on the implied values.
       *
       * @example
       * program
       *   .addOption(new Option('--log', 'write logging information to file'))
       *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
       *
       * @param {object} impliedOptionValues
       * @return {Option}
       */
      implies(impliedOptionValues) {
        let newImplied = impliedOptionValues;
        if (typeof impliedOptionValues === 'string') {
          newImplied = { [impliedOptionValues]: true };
        }
        this.implied = Object.assign(this.implied || {}, newImplied);
        return this;
      }
      /**
       * Set environment variable to check for option value.
       *
       * An environment variable is only used if when processed the current option value is
       * undefined, or the source of the current value is 'default' or 'config' or 'env'.
       *
       * @param {string} name
       * @return {Option}
       */
      env(name) {
        this.envVar = name;
        return this;
      }
      /**
       * Set the custom handler for processing CLI option arguments into option values.
       *
       * @param {Function} [fn]
       * @return {Option}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Whether the option is mandatory and must have a value after parsing.
       *
       * @param {boolean} [mandatory=true]
       * @return {Option}
       */
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      /**
       * Hide option in help.
       *
       * @param {boolean} [hide=true]
       * @return {Option}
       */
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      /**
       * @package
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Only allow option value to be one of choices.
       *
       * @param {string[]} values
       * @return {Option}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(', ')}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Return option name.
       *
       * @return {string}
       */
      name() {
        if (this.long) {
          return this.long.replace(/^--/, '');
        }
        return this.short.replace(/^-/, '');
      }
      /**
       * Return option name, in a camelcase format that can be used
       * as an object attribute key.
       *
       * @return {string}
       */
      attributeName() {
        if (this.negate) {
          return camelcase(this.name().replace(/^no-/, ''));
        }
        return camelcase(this.name());
      }
      /**
       * Check if `arg` matches the short or long flag.
       *
       * @param {string} arg
       * @return {boolean}
       * @package
       */
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      /**
       * Return whether a boolean option.
       *
       * Options are one of boolean, negated, required argument, or optional argument.
       *
       * @return {boolean}
       * @package
       */
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      /**
       * @param {Option[]} options
       */
      constructor(options2) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options2.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      /**
       * Did the value come from the option, and not from possible matching dual option?
       *
       * @param {*} value
       * @param {Option} option
       * @returns {boolean}
       */
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey)) return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split('-').reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const shortFlagExp = /^-[^-]$/;
      const longFlagExp = /^--[^-]/;
      const flagParts = flags.split(/[ |,]+/).concat('guard');
      if (shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();
      if (longFlagExp.test(flagParts[0])) longFlag = flagParts.shift();
      if (!shortFlag && shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();
      if (!shortFlag && longFlagExp.test(flagParts[0])) {
        shortFlag = longFlag;
        longFlag = flagParts.shift();
      }
      if (flagParts[0].startsWith('-')) {
        const unsupportedFlag = flagParts[0];
        const baseError = `option creation failed due to '${unsupportedFlag}' in option flags '${flags}'`;
        if (/^-[^-][^-]/.test(unsupportedFlag))
          throw new Error(
            `${baseError}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`,
          );
        if (shortFlagExp.test(unsupportedFlag))
          throw new Error(`${baseError}
- too many short flags`);
        if (longFlagExp.test(unsupportedFlag))
          throw new Error(`${baseError}
- too many long flags`);
        throw new Error(`${baseError}
- unrecognised flag format`);
      }
      if (shortFlag === void 0 && longFlag === void 0)
        throw new Error(`option creation failed due to no flags found in '${flags}'.`);
      return { shortFlag, longFlag };
    }
    exports2.Option = Option2;
    exports2.DualOptions = DualOptions;
  },
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  'node_modules/commander/lib/suggestSimilar.js'(exports2) {
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);
      const d = [];
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(
            d[i - 1][j] + 1,
            // deletion
            d[i][j - 1] + 1,
            // insertion
            d[i - 1][j - 1] + cost,
            // substitution
          );
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0) return '';
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith('--');
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1) return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(', ')}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return '';
    }
    exports2.suggestSimilar = suggestSimilar;
  },
});

// node_modules/commander/lib/command.js
var require_command = __commonJS({
  'node_modules/commander/lib/command.js'(exports2) {
    var EventEmitter = require('node:events').EventEmitter;
    var childProcess = require('node:child_process');
    var path = require('node:path');
    var fs2 = require('node:fs');
    var process10 = require('node:process');
    var { Argument: Argument2, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2, stripColor } = require_help();
    var { Option: Option2, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class _Command extends EventEmitter {
      /**
       * Initialize a new `Command`.
       *
       * @param {string} [name]
       */
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = false;
        this.registeredArguments = [];
        this._args = this.registeredArguments;
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || '';
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = '';
        this._summary = '';
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._savedState = null;
        this._outputConfiguration = {
          writeOut: (str) => process10.stdout.write(str),
          writeErr: (str) => process10.stderr.write(str),
          outputError: (str, write) => write(str),
          getOutHelpWidth: () => (process10.stdout.isTTY ? process10.stdout.columns : void 0),
          getErrHelpWidth: () => (process10.stderr.isTTY ? process10.stderr.columns : void 0),
          getOutHasColors: () => useColor() ?? (process10.stdout.isTTY && process10.stdout.hasColors?.()),
          getErrHasColors: () => useColor() ?? (process10.stderr.isTTY && process10.stderr.hasColors?.()),
          stripColor: (str) => stripColor(str),
        };
        this._hidden = false;
        this._helpOption = void 0;
        this._addImplicitHelpCommand = void 0;
        this._helpCommand = void 0;
        this._helpConfiguration = {};
      }
      /**
       * Copy settings that are useful to have in common across root command and subcommands.
       *
       * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
       *
       * @param {Command} sourceCommand
       * @return {Command} `this` command for chaining
       */
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._helpOption = sourceCommand._helpOption;
        this._helpCommand = sourceCommand._helpCommand;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      /**
       * @returns {Command[]}
       * @private
       */
      _getCommandAndAncestors() {
        const result = [];
        for (let command = this; command; command = command.parent) {
          result.push(command);
        }
        return result;
      }
      /**
       * Define a command.
       *
       * There are two styles of command: pay attention to where to put the description.
       *
       * @example
       * // Command implemented using action handler (description is supplied separately to `.command`)
       * program
       *   .command('clone <source> [destination]')
       *   .description('clone a repository into a newly created directory')
       *   .action((source, destination) => {
       *     console.log('clone command called');
       *   });
       *
       * // Command implemented using separate executable file (description is second parameter to `.command`)
       * program
       *   .command('start <service>', 'start named service')
       *   .command('stop [service]', 'stop named service, or all if no name supplied');
       *
       * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
       * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
       * @param {object} [execOpts] - configuration options (for executable)
       * @return {Command} returns new command for action handler, or `this` for executable command
       */
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === 'object' && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args) cmd.arguments(args);
        this._registerCommand(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc) return this;
        return cmd;
      }
      /**
       * Factory routine to create a new unattached command.
       *
       * See .command() for creating an attached subcommand, which uses this routine to
       * create the command. You can override createCommand to customise subcommands.
       *
       * @param {string} [name]
       * @return {Command} new command
       */
      createCommand(name) {
        return new _Command(name);
      }
      /**
       * You can customise the help with a subclass of Help by overriding createHelp,
       * or by overriding Help properties using configureHelp().
       *
       * @return {Help}
       */
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      /**
       * You can customise the help by overriding Help properties using configureHelp(),
       * or with a subclass of Help by overriding createHelp().
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */
      configureHelp(configuration) {
        if (configuration === void 0) return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      /**
       * The default output goes to stdout and stderr. You can customise this for special
       * applications. You can also customise the display of errors by overriding outputError.
       *
       * The configuration properties are all functions:
       *
       *     // change how output being written, defaults to stdout and stderr
       *     writeOut(str)
       *     writeErr(str)
       *     // change how output being written for errors, defaults to writeErr
       *     outputError(str, write) // used for displaying errors and not used for displaying help
       *     // specify width for wrapping help
       *     getOutHelpWidth()
       *     getErrHelpWidth()
       *     // color support, currently only used with Help
       *     getOutHasColors()
       *     getErrHasColors()
       *     stripColor() // used to remove ANSI escape codes if output does not have colors
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */
      configureOutput(configuration) {
        if (configuration === void 0) return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      /**
       * Display the help or a custom message after an error occurs.
       *
       * @param {(boolean|string)} [displayHelp]
       * @return {Command} `this` command for chaining
       */
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      /**
       * Display suggestion of similar commands for unknown commands, or options for unknown options.
       *
       * @param {boolean} [displaySuggestion]
       * @return {Command} `this` command for chaining
       */
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      /**
       * Add a prepared subcommand.
       *
       * See .command() for creating an attached subcommand which inherits settings from its parent.
       *
       * @param {Command} cmd - new subcommand
       * @param {object} [opts] - configuration options
       * @return {Command} `this` command for chaining
       */
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden) cmd._hidden = true;
        this._registerCommand(cmd);
        cmd.parent = this;
        cmd._checkForBrokenPassThrough();
        return this;
      }
      /**
       * Factory routine to create a new unattached argument.
       *
       * See .argument() for creating an attached argument, which uses this routine to
       * create the argument. You can override createArgument to return a custom argument.
       *
       * @param {string} name
       * @param {string} [description]
       * @return {Argument} new argument
       */
      createArgument(name, description) {
        return new Argument2(name, description);
      }
      /**
       * Define argument syntax for command.
       *
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @example
       * program.argument('<input-file>');
       * program.argument('[output-file]');
       *
       * @param {string} name
       * @param {string} [description]
       * @param {(Function|*)} [fn] - custom argument processing function
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === 'function') {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      /**
       * Define argument syntax for command, adding multiple at once (without descriptions).
       *
       * See also .argument().
       *
       * @example
       * program.arguments('<cmd> [env]');
       *
       * @param {string} names
       * @return {Command} `this` command for chaining
       */
      arguments(names) {
        names
          .trim()
          .split(/ +/)
          .forEach((detail) => {
            this.argument(detail);
          });
        return this;
      }
      /**
       * Define argument syntax for command, adding a prepared argument.
       *
       * @param {Argument} argument
       * @return {Command} `this` command for chaining
       */
      addArgument(argument) {
        const previousArgument = this.registeredArguments.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
        }
        this.registeredArguments.push(argument);
        return this;
      }
      /**
       * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
       *
       * @example
       *    program.helpCommand('help [cmd]');
       *    program.helpCommand('help [cmd]', 'show help');
       *    program.helpCommand(false); // suppress default help command
       *    program.helpCommand(true); // add help command even if no subcommands
       *
       * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
       * @param {string} [description] - custom description
       * @return {Command} `this` command for chaining
       */
      helpCommand(enableOrNameAndArgs, description) {
        if (typeof enableOrNameAndArgs === 'boolean') {
          this._addImplicitHelpCommand = enableOrNameAndArgs;
          return this;
        }
        enableOrNameAndArgs = enableOrNameAndArgs ?? 'help [command]';
        const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
        const helpDescription = description ?? 'display help for command';
        const helpCommand = this.createCommand(helpName);
        helpCommand.helpOption(false);
        if (helpArgs) helpCommand.arguments(helpArgs);
        if (helpDescription) helpCommand.description(helpDescription);
        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;
        return this;
      }
      /**
       * Add prepared custom help command.
       *
       * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
       * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
       * @return {Command} `this` command for chaining
       */
      addHelpCommand(helpCommand, deprecatedDescription) {
        if (typeof helpCommand !== 'object') {
          this.helpCommand(helpCommand, deprecatedDescription);
          return this;
        }
        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;
        return this;
      }
      /**
       * Lazy create help command.
       *
       * @return {(Command|null)}
       * @package
       */
      _getHelpCommand() {
        const hasImplicitHelpCommand =
          this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand('help'));
        if (hasImplicitHelpCommand) {
          if (this._helpCommand === void 0) {
            this.helpCommand(void 0, void 0);
          }
          return this._helpCommand;
        }
        return null;
      }
      /**
       * Add hook for life cycle event.
       *
       * @param {string} event
       * @param {Function} listener
       * @return {Command} `this` command for chaining
       */
      hook(event, listener) {
        const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
       * @return {Command} `this` command for chaining
       */
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== 'commander.executeSubCommandAsync') {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      /**
       * Call process.exit, and _exitCallback if defined.
       *
       * @param {number} exitCode exit code for using with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @return never
       * @private
       */
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process10.exit(exitCode);
      }
      /**
       * Register callback `fn` for the command.
       *
       * @example
       * program
       *   .command('serve')
       *   .description('start service')
       *   .action(function() {
       *      // do work here
       *   });
       *
       * @param {Function} fn
       * @return {Command} `this` command for chaining
       */
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this.registeredArguments.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      /**
       * Factory routine to create a new unattached option.
       *
       * See .option() for creating an attached option, which uses this routine to
       * create the option. You can override createOption to return a custom option.
       *
       * @param {string} flags
       * @param {string} [description]
       * @return {Option} new option
       */
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      /**
       * Wrap parseArgs to catch 'commander.invalidArgument'.
       *
       * @param {(Option | Argument)} target
       * @param {string} value
       * @param {*} previous
       * @param {string} invalidArgumentMessage
       * @private
       */
      _callParseArg(target, value, previous, invalidArgumentMessage) {
        try {
          return target.parseArg(value, previous);
        } catch (err) {
          if (err.code === 'commander.invalidArgument') {
            const message = `${invalidArgumentMessage} ${err.message}`;
            this.error(message, { exitCode: err.exitCode, code: err.code });
          }
          throw err;
        }
      }
      /**
       * Check for option flag conflicts.
       * Register option if no conflicts found, or throw on conflict.
       *
       * @param {Option} option
       * @private
       */
      _registerOption(option) {
        const matchingOption =
          (option.short && this._findOption(option.short)) || (option.long && this._findOption(option.long));
        if (matchingOption) {
          const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
          throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
        }
        this.options.push(option);
      }
      /**
       * Check for command name and alias conflicts with existing commands.
       * Register command if no conflicts found, or throw on conflict.
       *
       * @param {Command} command
       * @private
       */
      _registerCommand(command) {
        const knownBy = (cmd) => {
          return [cmd.name()].concat(cmd.aliases());
        };
        const alreadyUsed = knownBy(command).find((name) => this._findCommand(name));
        if (alreadyUsed) {
          const existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|');
          const newCmd = knownBy(command).join('|');
          throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
        }
        this.commands.push(command);
      }
      /**
       * Add an option.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addOption(option) {
        this._registerOption(option);
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, '--');
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(name, option.defaultValue === void 0 ? true : option.defaultValue, 'default');
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, 'default');
        }
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            val = this._callParseArg(option, val, oldValue, invalidValueMessage);
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = '';
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on('option:' + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, 'cli');
        });
        if (option.envVar) {
          this.on('optionEnv:' + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, 'env');
          });
        }
        return this;
      }
      /**
       * Internal implementation shared by .option() and .requiredOption()
       *
       * @return {Command} `this` command for chaining
       * @private
       */
      _optionEx(config, flags, description, fn, defaultValue) {
        if (typeof flags === 'object' && flags instanceof Option2) {
          throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === 'function') {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex2 = fn;
          fn = (val, def) => {
            const m = regex2.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      /**
       * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
       * option-argument is indicated by `<>` and an optional option-argument by `[]`.
       *
       * See the README for more details, and see also addOption() and requiredOption().
       *
       * @example
       * program
       *     .option('-p, --pepper', 'add pepper')
       *     .option('--pt, --pizza-type <TYPE>', 'type of pizza') // required option-argument
       *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
       *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      option(flags, description, parseArg, defaultValue) {
        return this._optionEx({}, flags, description, parseArg, defaultValue);
      }
      /**
       * Add a required option which must have a value after parsing. This usually means
       * the option must be specified on the command line. (Otherwise the same as .option().)
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      requiredOption(flags, description, parseArg, defaultValue) {
        return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
      }
      /**
       * Alter parsing of short flags with optional values.
       *
       * @example
       * // for `.option('-f,--flag [value]'):
       * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
       * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
       *
       * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
       * @return {Command} `this` command for chaining
       */
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      /**
       * Allow unknown options on the command line.
       *
       * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
       * @return {Command} `this` command for chaining
       */
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      /**
       * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
       *
       * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
       * @return {Command} `this` command for chaining
       */
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      /**
       * Enable positional options. Positional means global options are specified before subcommands which lets
       * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
       * The default behaviour is non-positional and global options may appear anywhere on the command line.
       *
       * @param {boolean} [positional]
       * @return {Command} `this` command for chaining
       */
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      /**
       * Pass through options that come after command-arguments rather than treat them as command-options,
       * so actual command-options come before command-arguments. Turning this on for a subcommand requires
       * positional options to have been enabled on the program (parent commands).
       * The default behaviour is non-positional and options may appear before or after command-arguments.
       *
       * @param {boolean} [passThrough] for unknown options.
       * @return {Command} `this` command for chaining
       */
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        this._checkForBrokenPassThrough();
        return this;
      }
      /**
       * @private
       */
      _checkForBrokenPassThrough() {
        if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
          throw new Error(
            `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`,
          );
        }
      }
      /**
       * Whether to store option values as properties on command object,
       * or store separately (specify false). In both cases the option values can be accessed using .opts().
       *
       * @param {boolean} [storeAsProperties=true]
       * @return {Command} `this` command for chaining
       */
      storeOptionsAsProperties(storeAsProperties = true) {
        if (this.options.length) {
          throw new Error('call .storeOptionsAsProperties() before adding options');
        }
        if (Object.keys(this._optionValues).length) {
          throw new Error('call .storeOptionsAsProperties() before setting option values');
        }
        this._storeOptionsAsProperties = !!storeAsProperties;
        return this;
      }
      /**
       * Retrieve option value.
       *
       * @param {string} key
       * @return {object} value
       */
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      /**
       * Store option value.
       *
       * @param {string} key
       * @param {object} value
       * @return {Command} `this` command for chaining
       */
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      /**
       * Store option value and where the value came from.
       *
       * @param {string} key
       * @param {object} value
       * @param {string} source - expected values are default/config/env/cli/implied
       * @return {Command} `this` command for chaining
       */
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      /**
       * Get source of option value.
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      /**
       * Get source of option value. See also .optsWithGlobals().
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */
      getOptionValueSourceWithGlobals(key) {
        let source;
        this._getCommandAndAncestors().forEach((cmd) => {
          if (cmd.getOptionValueSource(key) !== void 0) {
            source = cmd.getOptionValueSource(key);
          }
        });
        return source;
      }
      /**
       * Get user arguments from implied or explicit arguments.
       * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
       *
       * @private
       */
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error('first parameter to parse must be array or undefined');
        }
        parseOptions = parseOptions || {};
        if (argv === void 0 && parseOptions.from === void 0) {
          if (process10.versions?.electron) {
            parseOptions.from = 'electron';
          }
          const execArgv = process10.execArgv ?? [];
          if (
            execArgv.includes('-e') ||
            execArgv.includes('--eval') ||
            execArgv.includes('-p') ||
            execArgv.includes('--print')
          ) {
            parseOptions.from = 'eval';
          }
        }
        if (argv === void 0) {
          argv = process10.argv;
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case 'node':
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case 'electron':
            if (process10.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case 'user':
            userArgs = argv.slice(0);
            break;
          case 'eval':
            userArgs = argv.slice(1);
            break;
          default:
            throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
        }
        if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
        this._name = this._name || 'program';
        return userArgs;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Use parseAsync instead of parse if any of your action handlers are async.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * program.parse(); // parse process.argv and auto-detect electron and special node flags
       * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
       * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       */
      parse(argv, parseOptions) {
        this._prepareForParse();
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
       * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
       * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv]
       * @param {object} [parseOptions]
       * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
       * @return {Promise}
       */
      async parseAsync(argv, parseOptions) {
        this._prepareForParse();
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      _prepareForParse() {
        if (this._savedState === null) {
          this.saveStateBeforeParse();
        } else {
          this.restoreStateBeforeParse();
        }
      }
      /**
       * Called the first time parse is called to save state and allow a restore before subsequent calls to parse.
       * Not usually called directly, but available for subclasses to save their custom state.
       *
       * This is called in a lazy way. Only commands used in parsing chain will have state saved.
       */
      saveStateBeforeParse() {
        this._savedState = {
          // name is stable if supplied by author, but may be unspecified for root command and deduced during parsing
          _name: this._name,
          // option values before parse have default values (including false for negated options)
          // shallow clones
          _optionValues: { ...this._optionValues },
          _optionValueSources: { ...this._optionValueSources },
        };
      }
      /**
       * Restore state before parse for calls after the first.
       * Not usually called directly, but available for subclasses to save their custom state.
       *
       * This is called in a lazy way. Only commands used in parsing chain will have state restored.
       */
      restoreStateBeforeParse() {
        if (this._storeOptionsAsProperties)
          throw new Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);
        this._name = this._savedState._name;
        this._scriptPath = null;
        this.rawArgs = [];
        this._optionValues = { ...this._savedState._optionValues };
        this._optionValueSources = { ...this._savedState._optionValueSources };
        this.args = [];
        this.processedArgs = [];
      }
      /**
       * Throw if expected executable is missing. Add lots of help for author.
       *
       * @param {string} executableFile
       * @param {string} executableDir
       * @param {string} subcommandName
       */
      _checkForMissingExecutable(executableFile, executableDir, subcommandName) {
        if (fs2.existsSync(executableFile)) return;
        const executableDirMessage = executableDir
          ? `searched for local subcommand relative to directory '${executableDir}'`
          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
        const executableMissing = `'${executableFile}' does not exist
 - if '${subcommandName}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
        throw new Error(executableMissing);
      }
      /**
       * Execute a sub-command executable.
       *
       * @private
       */
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];
        function findFile(baseDir, baseName) {
          const localBin = path.resolve(baseDir, baseName);
          if (fs2.existsSync(localBin)) return localBin;
          if (sourceExt.includes(path.extname(baseName))) return void 0;
          const foundExt = sourceExt.find((ext) => fs2.existsSync(`${localBin}${ext}`));
          if (foundExt) return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || '';
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs2.realpathSync(this._scriptPath);
          } catch {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));
            if (legacyName !== this._name) {
              localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path.extname(executableFile));
        let proc;
        if (process10.platform !== 'win32') {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process10.execArgv).concat(args);
            proc = childProcess.spawn(process10.argv[0], args, { stdio: 'inherit' });
          } else {
            proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });
          }
        } else {
          this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process10.execArgv).concat(args);
          proc = childProcess.spawn(process10.execPath, args, { stdio: 'inherit' });
        }
        if (!proc.killed) {
          const signals2 = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
          signals2.forEach((signal) => {
            process10.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        proc.on('close', (code) => {
          code = code ?? 1;
          if (!exitCallback) {
            process10.exit(code);
          } else {
            exitCallback(new CommanderError2(code, 'commander.executeSubCommandAsync', '(close)'));
          }
        });
        proc.on('error', (err) => {
          if (err.code === 'ENOENT') {
            this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
          } else if (err.code === 'EACCES') {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process10.exit(1);
          } else {
            const wrappedError = new CommanderError2(1, 'commander.executeSubCommandAsync', '(error)');
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      /**
       * @private
       */
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand) this.help({ error: true });
        subCommand._prepareForParse();
        let promiseChain;
        promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, 'preSubcommand');
        promiseChain = this._chainOrCall(promiseChain, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return promiseChain;
      }
      /**
       * Invoke help directly if possible, or dispatch if necessary.
       * e.g. help foo
       *
       * @private
       */
      _dispatchHelpCommand(subcommandName) {
        if (!subcommandName) {
          this.help();
        }
        const subCommand = this._findCommand(subcommandName);
        if (subCommand && !subCommand._executableHandler) {
          subCommand.help();
        }
        return this._dispatchSubcommand(
          subcommandName,
          [],
          [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help'],
        );
      }
      /**
       * Check this.args against expected this.registeredArguments.
       *
       * @private
       */
      _checkNumberOfArguments() {
        this.registeredArguments.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (
          this.registeredArguments.length > 0 &&
          this.registeredArguments[this.registeredArguments.length - 1].variadic
        ) {
          return;
        }
        if (this.args.length > this.registeredArguments.length) {
          this._excessArguments(this.args);
        }
      }
      /**
       * Process this.args using this.registeredArguments and save as this.processedArgs!
       *
       * @private
       */
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
            parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this.registeredArguments.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      /**
       * Once we have a promise we chain, but call synchronously until then.
       *
       * @param {(Promise|undefined)} promise
       * @param {Function} fn
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === 'function') {
          return promise.then(() => fn());
        }
        return fn();
      }
      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        this._getCommandAndAncestors()
          .reverse()
          .filter((cmd) => cmd._lifeCycleHooks[event] !== void 0)
          .forEach((hookedCommand) => {
            hookedCommand._lifeCycleHooks[event].forEach((callback) => {
              hooks.push({ hookedCommand, callback });
            });
          });
        if (event === 'postAction') {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {Command} subCommand
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCallSubCommandHook(promise, subCommand, event) {
        let result = promise;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook2) => {
            result = this._chainOrCall(result, () => {
              return hook2(this, subCommand);
            });
          });
        }
        return result;
      }
      /**
       * Process arguments in context of this command.
       * Returns action result, in case it is a promise.
       *
       * @private
       */
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
          return this._dispatchHelpCommand(operands[1]);
        }
        if (this._defaultCommandName) {
          this._outputHelpIfRequested(unknown);
          return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        this._outputHelpIfRequested(parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let promiseChain;
          promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
          promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
          if (this.parent) {
            promiseChain = this._chainOrCall(promiseChain, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
          return promiseChain;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand('*')) {
            return this._dispatchSubcommand('*', operands, unknown);
          }
          if (this.listenerCount('command:*')) {
            this.emit('command:*', operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      /**
       * Find matching command.
       *
       * @private
       * @return {Command | undefined}
       */
      _findCommand(name) {
        if (!name) return void 0;
        return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
      }
      /**
       * Return an option matching `arg` if any.
       *
       * @param {string} arg
       * @return {Option}
       * @package
       */
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      /**
       * Display an error message if a mandatory option does not have a value.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */
      _checkForMissingMandatoryOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        });
      }
      /**
       * Display an error message if conflicting options are used together in this.
       *
       * @private
       */
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter((option) => {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === void 0) {
            return false;
          }
          return this.getOptionValueSource(optionKey) !== 'default';
        });
        const optionsWithConflicting = definedNonDefaultOptions.filter((option) => option.conflictsWith.length > 0);
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>
            option.conflictsWith.includes(defined.attributeName()),
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      /**
       * Display an error message if conflicting options are used together.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */
      _checkForConflictingOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd._checkForConflictingLocalOptions();
        });
      }
      /**
       * Parse options from `argv` removing known options,
       * and return argv split into operands and unknown arguments.
       *
       * Side effects: modifies command by storing options. Does not reset state if called again.
       *
       * Examples:
       *
       *     argv => operands, unknown
       *     --known kkk op => [op], []
       *     op --known kkk => [op], []
       *     sub --unknown uuu op => [sub], [--unknown uuu op]
       *     sub -- --unknown uuu op => [sub --unknown uuu op], []
       *
       * @param {string[]} argv
       * @return {{operands: string[], unknown: string[]}}
       */
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === '-';
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === '--') {
            if (dest === unknown) dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0) this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf('=');
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if (
            (this._enablePositionalOptions || this._passThroughOptions) &&
            operands.length === 0 &&
            unknown.length === 0
          ) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
              operands.push(arg);
              if (args.length > 0) operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0) dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      /**
       * Return an object containing local option values as key-value pairs.
       *
       * @return {object}
       */
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      /**
       * Return an object containing merged local and global option values as key-value pairs.
       *
       * @return {object}
       */
      optsWithGlobals() {
        return this._getCommandAndAncestors().reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {},
        );
      }
      /**
       * Display error message and exit (or call exitOverride).
       *
       * @param {string} message
       * @param {object} [errorOptions]
       * @param {string} [errorOptions.code] - an id string representing the error
       * @param {number} [errorOptions.exitCode] - used with process.exit
       */
      error(message, errorOptions) {
        this._outputConfiguration.outputError(
          `${message}
`,
          this._outputConfiguration.writeErr,
        );
        if (typeof this._showHelpAfterError === 'string') {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr('\n');
          this.outputHelp({ error: true });
        }
        const config = errorOptions || {};
        const exitCode = config.exitCode || 1;
        const code = config.code || 'commander.error';
        this._exit(exitCode, code, message);
      }
      /**
       * Apply any option related environment variables, if option does
       * not have a value from cli or client code.
       *
       * @private
       */
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process10.env) {
            const optionKey = option.attributeName();
            if (
              this.getOptionValue(optionKey) === void 0 ||
              ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))
            ) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process10.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      /**
       * Apply any implied option values, if option is undefined or default value.
       *
       * @private
       */
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return (
            this.getOptionValue(optionKey) !== void 0 &&
            !['default', 'implied'].includes(this.getOptionValueSource(optionKey))
          );
        };
        this.options
          .filter(
            (option) =>
              option.implied !== void 0 &&
              hasCustomOptionValue(option.attributeName()) &&
              dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option),
          )
          .forEach((option) => {
            Object.keys(option.implied)
              .filter((impliedKey) => !hasCustomOptionValue(impliedKey))
              .forEach((impliedKey) => {
                this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], 'implied');
              });
          });
      }
      /**
       * Argument `name` is missing.
       *
       * @param {string} name
       * @private
       */
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: 'commander.missingArgument' });
      }
      /**
       * `Option` is missing an argument.
       *
       * @param {Option} option
       * @private
       */
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: 'commander.optionMissingArgument' });
      }
      /**
       * `Option` does not have a value, and is a mandatory option.
       *
       * @param {Option} option
       * @private
       */
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: 'commander.missingMandatoryOptionValue' });
      }
      /**
       * `Option` conflicts with another option.
       *
       * @param {Option} option
       * @param {Option} conflictingOption
       * @private
       */
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
          const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
          if (
            negativeOption &&
            ((negativeOption.presetArg === void 0 && optionValue === false) ||
              (negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg))
          ) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === 'env') {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: 'commander.conflictingOption' });
      }
      /**
       * Unknown option `flag`.
       *
       * @param {string} flag
       * @private
       */
      unknownOption(flag) {
        if (this._allowUnknownOption) return;
        let suggestion = '';
        if (flag.startsWith('--') && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command
              .createHelp()
              .visibleOptions(command)
              .filter((option) => option.long)
              .map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: 'commander.unknownOption' });
      }
      /**
       * Excess arguments, more than expected.
       *
       * @param {string[]} receivedArgs
       * @private
       */
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments) return;
        const expected = this.registeredArguments.length;
        const s = expected === 1 ? '' : 's';
        const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this.error(message, { code: 'commander.excessArguments' });
      }
      /**
       * Unknown command.
       *
       * @private
       */
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = '';
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp()
            .visibleCommands(this)
            .forEach((command) => {
              candidateNames.push(command.name());
              if (command.alias()) candidateNames.push(command.alias());
            });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: 'commander.unknownCommand' });
      }
      /**
       * Get or set the program version.
       *
       * This method auto-registers the "-V, --version" option which will print the version number.
       *
       * You can optionally supply the flags and description to override the defaults.
       *
       * @param {string} [str]
       * @param {string} [flags]
       * @param {string} [description]
       * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
       */
      version(str, flags, description) {
        if (str === void 0) return this._version;
        this._version = str;
        flags = flags || '-V, --version';
        description = description || 'output the version number';
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this._registerOption(versionOption);
        this.on('option:' + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, 'commander.version', str);
        });
        return this;
      }
      /**
       * Set the description.
       *
       * @param {string} [str]
       * @param {object} [argsDescription]
       * @return {(string|Command)}
       */
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0) return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      /**
       * Set the summary. Used when listed as subcommand of parent.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      summary(str) {
        if (str === void 0) return this._summary;
        this._summary = str;
        return this;
      }
      /**
       * Set an alias for the command.
       *
       * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
       *
       * @param {string} [alias]
       * @return {(string|Command)}
       */
      alias(alias) {
        if (alias === void 0) return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name) throw new Error("Command alias can't be the same as its name");
        const matchingCommand = this.parent?._findCommand(alias);
        if (matchingCommand) {
          const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join('|');
          throw new Error(
            `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`,
          );
        }
        command._aliases.push(alias);
        return this;
      }
      /**
       * Set aliases for the command.
       *
       * Only the first alias is shown in the auto-generated help.
       *
       * @param {string[]} [aliases]
       * @return {(string[]|Command)}
       */
      aliases(aliases) {
        if (aliases === void 0) return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      /**
       * Set / get the command usage `str`.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      usage(str) {
        if (str === void 0) {
          if (this._usage) return this._usage;
          const args = this.registeredArguments.map((arg) => {
            return humanReadableArgName(arg);
          });
          return []
            .concat(
              this.options.length || this._helpOption !== null ? '[options]' : [],
              this.commands.length ? '[command]' : [],
              this.registeredArguments.length ? args : [],
            )
            .join(' ');
        }
        this._usage = str;
        return this;
      }
      /**
       * Get or set the name of the command.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      name(str) {
        if (str === void 0) return this._name;
        this._name = str;
        return this;
      }
      /**
       * Set the name of the command from script filename, such as process.argv[1],
       * or require.main.filename, or __filename.
       *
       * (Used internally and public although not documented in README.)
       *
       * @example
       * program.nameFromFilename(require.main.filename);
       *
       * @param {string} filename
       * @return {Command}
       */
      nameFromFilename(filename) {
        this._name = path.basename(filename, path.extname(filename));
        return this;
      }
      /**
       * Get or set the directory for searching for executable subcommands of this command.
       *
       * @example
       * program.executableDir(__dirname);
       * // or
       * program.executableDir('subcommands');
       *
       * @param {string} [path]
       * @return {(string|null|Command)}
       */
      executableDir(path2) {
        if (path2 === void 0) return this._executableDir;
        this._executableDir = path2;
        return this;
      }
      /**
       * Return program help documentation.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
       * @return {string}
       */
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        const context = this._getOutputContext(contextOptions);
        helper.prepareContext({
          error: context.error,
          helpWidth: context.helpWidth,
          outputHasColors: context.hasColors,
        });
        const text = helper.formatHelp(this, helper);
        if (context.hasColors) return text;
        return this._outputConfiguration.stripColor(text);
      }
      /**
       * @typedef HelpContext
       * @type {object}
       * @property {boolean} error
       * @property {number} helpWidth
       * @property {boolean} hasColors
       * @property {function} write - includes stripColor if needed
       *
       * @returns {HelpContext}
       * @private
       */
      _getOutputContext(contextOptions) {
        contextOptions = contextOptions || {};
        const error = !!contextOptions.error;
        let baseWrite;
        let hasColors;
        let helpWidth;
        if (error) {
          baseWrite = (str) => this._outputConfiguration.writeErr(str);
          hasColors = this._outputConfiguration.getErrHasColors();
          helpWidth = this._outputConfiguration.getErrHelpWidth();
        } else {
          baseWrite = (str) => this._outputConfiguration.writeOut(str);
          hasColors = this._outputConfiguration.getOutHasColors();
          helpWidth = this._outputConfiguration.getOutHelpWidth();
        }
        const write = (str) => {
          if (!hasColors) str = this._outputConfiguration.stripColor(str);
          return baseWrite(str);
        };
        return { error, write, hasColors, helpWidth };
      }
      /**
       * Output help information for this command.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === 'function') {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const outputContext = this._getOutputContext(contextOptions);
        const eventContext = {
          error: outputContext.error,
          write: outputContext.write,
          command: this,
        };
        this._getCommandAndAncestors()
          .reverse()
          .forEach((command) => command.emit('beforeAllHelp', eventContext));
        this.emit('beforeHelp', eventContext);
        let helpInformation = this.helpInformation({ error: outputContext.error });
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {
            throw new Error('outputHelp callback must return a string or a Buffer');
          }
        }
        outputContext.write(helpInformation);
        if (this._getHelpOption()?.long) {
          this.emit(this._getHelpOption().long);
        }
        this.emit('afterHelp', eventContext);
        this._getCommandAndAncestors().forEach((command) => command.emit('afterAllHelp', eventContext));
      }
      /**
       * You can pass in flags and a description to customise the built-in help option.
       * Pass in false to disable the built-in help option.
       *
       * @example
       * program.helpOption('-?, --help' 'show help'); // customise
       * program.helpOption(false); // disable
       *
       * @param {(string | boolean)} flags
       * @param {string} [description]
       * @return {Command} `this` command for chaining
       */
      helpOption(flags, description) {
        if (typeof flags === 'boolean') {
          if (flags) {
            this._helpOption = this._helpOption ?? void 0;
          } else {
            this._helpOption = null;
          }
          return this;
        }
        flags = flags ?? '-h, --help';
        description = description ?? 'display help for command';
        this._helpOption = this.createOption(flags, description);
        return this;
      }
      /**
       * Lazy create help option.
       * Returns null if has been disabled with .helpOption(false).
       *
       * @returns {(Option | null)} the help option
       * @package
       */
      _getHelpOption() {
        if (this._helpOption === void 0) {
          this.helpOption(void 0, void 0);
        }
        return this._helpOption;
      }
      /**
       * Supply your own option to use for the built-in help option.
       * This is an alternative to using helpOption() to customise the flags and description etc.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addHelpOption(option) {
        this._helpOption = option;
        return this;
      }
      /**
       * Output help information and exit.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = Number(process10.exitCode ?? 0);
        if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, 'commander.help', '(outputHelp)');
      }
      /**
       * // Do a little typing to coordinate emit and listener for the help text events.
       * @typedef HelpTextEventContext
       * @type {object}
       * @property {boolean} error
       * @property {Command} command
       * @property {function} write
       */
      /**
       * Add additional text to be displayed with the built-in help.
       *
       * Position is 'before' or 'after' to affect just this command,
       * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
       *
       * @param {string} position - before or after built-in help
       * @param {(string | Function)} text - string to add, or a function returning a string
       * @return {Command} `this` command for chaining
       */
      addHelpText(position, text) {
        const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === 'function') {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
      /**
       * Output help information if help flags specified
       *
       * @param {Array} args - array of options to search for help flags
       * @private
       */
      _outputHelpIfRequested(args) {
        const helpOption = this._getHelpOption();
        const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
        if (helpRequested) {
          this.outputHelp();
          this._exit(0, 'commander.helpDisplayed', '(outputHelp)');
        }
      }
    };
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith('--inspect')) {
          return arg;
        }
        let debugOption;
        let debugHost = '127.0.0.1';
        let debugPort = '9229';
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== '0') {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    function useColor() {
      if (process10.env.NO_COLOR || process10.env.FORCE_COLOR === '0' || process10.env.FORCE_COLOR === 'false')
        return false;
      if (process10.env.FORCE_COLOR || process10.env.CLICOLOR_FORCE !== void 0) return true;
      return void 0;
    }
    exports2.Command = Command2;
    exports2.useColor = useColor;
  },
});

// node_modules/commander/index.js
var require_commander = __commonJS({
  'node_modules/commander/index.js'(exports2) {
    var { Argument: Argument2 } = require_argument();
    var { Command: Command2 } = require_command();
    var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports2.program = new Command2();
    exports2.createCommand = (name) => new Command2(name);
    exports2.createOption = (flags, description) => new Option2(flags, description);
    exports2.createArgument = (name, description) => new Argument2(name, description);
    exports2.Command = Command2;
    exports2.Option = Option2;
    exports2.Argument = Argument2;
    exports2.Help = Help2;
    exports2.CommanderError = CommanderError2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
    exports2.InvalidOptionArgumentError = InvalidArgumentError2;
  },
});

// node_modules/cli-spinners/spinners.json
var require_spinners = __commonJS({
  'node_modules/cli-spinners/spinners.json'(exports2, module2) {
    module2.exports = {
      dots: {
        interval: 80,
        frames: ['\u280B', '\u2819', '\u2839', '\u2838', '\u283C', '\u2834', '\u2826', '\u2827', '\u2807', '\u280F'],
      },
      dots2: {
        interval: 80,
        frames: ['\u28FE', '\u28FD', '\u28FB', '\u28BF', '\u287F', '\u28DF', '\u28EF', '\u28F7'],
      },
      dots3: {
        interval: 80,
        frames: ['\u280B', '\u2819', '\u281A', '\u281E', '\u2816', '\u2826', '\u2834', '\u2832', '\u2833', '\u2813'],
      },
      dots4: {
        interval: 80,
        frames: [
          '\u2804',
          '\u2806',
          '\u2807',
          '\u280B',
          '\u2819',
          '\u2838',
          '\u2830',
          '\u2820',
          '\u2830',
          '\u2838',
          '\u2819',
          '\u280B',
          '\u2807',
          '\u2806',
        ],
      },
      dots5: {
        interval: 80,
        frames: [
          '\u280B',
          '\u2819',
          '\u281A',
          '\u2812',
          '\u2802',
          '\u2802',
          '\u2812',
          '\u2832',
          '\u2834',
          '\u2826',
          '\u2816',
          '\u2812',
          '\u2810',
          '\u2810',
          '\u2812',
          '\u2813',
          '\u280B',
        ],
      },
      dots6: {
        interval: 80,
        frames: [
          '\u2801',
          '\u2809',
          '\u2819',
          '\u281A',
          '\u2812',
          '\u2802',
          '\u2802',
          '\u2812',
          '\u2832',
          '\u2834',
          '\u2824',
          '\u2804',
          '\u2804',
          '\u2824',
          '\u2834',
          '\u2832',
          '\u2812',
          '\u2802',
          '\u2802',
          '\u2812',
          '\u281A',
          '\u2819',
          '\u2809',
          '\u2801',
        ],
      },
      dots7: {
        interval: 80,
        frames: [
          '\u2808',
          '\u2809',
          '\u280B',
          '\u2813',
          '\u2812',
          '\u2810',
          '\u2810',
          '\u2812',
          '\u2816',
          '\u2826',
          '\u2824',
          '\u2820',
          '\u2820',
          '\u2824',
          '\u2826',
          '\u2816',
          '\u2812',
          '\u2810',
          '\u2810',
          '\u2812',
          '\u2813',
          '\u280B',
          '\u2809',
          '\u2808',
        ],
      },
      dots8: {
        interval: 80,
        frames: [
          '\u2801',
          '\u2801',
          '\u2809',
          '\u2819',
          '\u281A',
          '\u2812',
          '\u2802',
          '\u2802',
          '\u2812',
          '\u2832',
          '\u2834',
          '\u2824',
          '\u2804',
          '\u2804',
          '\u2824',
          '\u2820',
          '\u2820',
          '\u2824',
          '\u2826',
          '\u2816',
          '\u2812',
          '\u2810',
          '\u2810',
          '\u2812',
          '\u2813',
          '\u280B',
          '\u2809',
          '\u2808',
          '\u2808',
        ],
      },
      dots9: {
        interval: 80,
        frames: ['\u28B9', '\u28BA', '\u28BC', '\u28F8', '\u28C7', '\u2867', '\u2857', '\u284F'],
      },
      dots10: {
        interval: 80,
        frames: ['\u2884', '\u2882', '\u2881', '\u2841', '\u2848', '\u2850', '\u2860'],
      },
      dots11: {
        interval: 100,
        frames: ['\u2801', '\u2802', '\u2804', '\u2840', '\u2880', '\u2820', '\u2810', '\u2808'],
      },
      dots12: {
        interval: 80,
        frames: [
          '\u2880\u2800',
          '\u2840\u2800',
          '\u2804\u2800',
          '\u2882\u2800',
          '\u2842\u2800',
          '\u2805\u2800',
          '\u2883\u2800',
          '\u2843\u2800',
          '\u280D\u2800',
          '\u288B\u2800',
          '\u284B\u2800',
          '\u280D\u2801',
          '\u288B\u2801',
          '\u284B\u2801',
          '\u280D\u2809',
          '\u280B\u2809',
          '\u280B\u2809',
          '\u2809\u2819',
          '\u2809\u2819',
          '\u2809\u2829',
          '\u2808\u2899',
          '\u2808\u2859',
          '\u2888\u2829',
          '\u2840\u2899',
          '\u2804\u2859',
          '\u2882\u2829',
          '\u2842\u2898',
          '\u2805\u2858',
          '\u2883\u2828',
          '\u2843\u2890',
          '\u280D\u2850',
          '\u288B\u2820',
          '\u284B\u2880',
          '\u280D\u2841',
          '\u288B\u2801',
          '\u284B\u2801',
          '\u280D\u2809',
          '\u280B\u2809',
          '\u280B\u2809',
          '\u2809\u2819',
          '\u2809\u2819',
          '\u2809\u2829',
          '\u2808\u2899',
          '\u2808\u2859',
          '\u2808\u2829',
          '\u2800\u2899',
          '\u2800\u2859',
          '\u2800\u2829',
          '\u2800\u2898',
          '\u2800\u2858',
          '\u2800\u2828',
          '\u2800\u2890',
          '\u2800\u2850',
          '\u2800\u2820',
          '\u2800\u2880',
          '\u2800\u2840',
        ],
      },
      dots13: {
        interval: 80,
        frames: ['\u28FC', '\u28F9', '\u28BB', '\u283F', '\u285F', '\u28CF', '\u28E7', '\u28F6'],
      },
      dots8Bit: {
        interval: 80,
        frames: [
          '\u2800',
          '\u2801',
          '\u2802',
          '\u2803',
          '\u2804',
          '\u2805',
          '\u2806',
          '\u2807',
          '\u2840',
          '\u2841',
          '\u2842',
          '\u2843',
          '\u2844',
          '\u2845',
          '\u2846',
          '\u2847',
          '\u2808',
          '\u2809',
          '\u280A',
          '\u280B',
          '\u280C',
          '\u280D',
          '\u280E',
          '\u280F',
          '\u2848',
          '\u2849',
          '\u284A',
          '\u284B',
          '\u284C',
          '\u284D',
          '\u284E',
          '\u284F',
          '\u2810',
          '\u2811',
          '\u2812',
          '\u2813',
          '\u2814',
          '\u2815',
          '\u2816',
          '\u2817',
          '\u2850',
          '\u2851',
          '\u2852',
          '\u2853',
          '\u2854',
          '\u2855',
          '\u2856',
          '\u2857',
          '\u2818',
          '\u2819',
          '\u281A',
          '\u281B',
          '\u281C',
          '\u281D',
          '\u281E',
          '\u281F',
          '\u2858',
          '\u2859',
          '\u285A',
          '\u285B',
          '\u285C',
          '\u285D',
          '\u285E',
          '\u285F',
          '\u2820',
          '\u2821',
          '\u2822',
          '\u2823',
          '\u2824',
          '\u2825',
          '\u2826',
          '\u2827',
          '\u2860',
          '\u2861',
          '\u2862',
          '\u2863',
          '\u2864',
          '\u2865',
          '\u2866',
          '\u2867',
          '\u2828',
          '\u2829',
          '\u282A',
          '\u282B',
          '\u282C',
          '\u282D',
          '\u282E',
          '\u282F',
          '\u2868',
          '\u2869',
          '\u286A',
          '\u286B',
          '\u286C',
          '\u286D',
          '\u286E',
          '\u286F',
          '\u2830',
          '\u2831',
          '\u2832',
          '\u2833',
          '\u2834',
          '\u2835',
          '\u2836',
          '\u2837',
          '\u2870',
          '\u2871',
          '\u2872',
          '\u2873',
          '\u2874',
          '\u2875',
          '\u2876',
          '\u2877',
          '\u2838',
          '\u2839',
          '\u283A',
          '\u283B',
          '\u283C',
          '\u283D',
          '\u283E',
          '\u283F',
          '\u2878',
          '\u2879',
          '\u287A',
          '\u287B',
          '\u287C',
          '\u287D',
          '\u287E',
          '\u287F',
          '\u2880',
          '\u2881',
          '\u2882',
          '\u2883',
          '\u2884',
          '\u2885',
          '\u2886',
          '\u2887',
          '\u28C0',
          '\u28C1',
          '\u28C2',
          '\u28C3',
          '\u28C4',
          '\u28C5',
          '\u28C6',
          '\u28C7',
          '\u2888',
          '\u2889',
          '\u288A',
          '\u288B',
          '\u288C',
          '\u288D',
          '\u288E',
          '\u288F',
          '\u28C8',
          '\u28C9',
          '\u28CA',
          '\u28CB',
          '\u28CC',
          '\u28CD',
          '\u28CE',
          '\u28CF',
          '\u2890',
          '\u2891',
          '\u2892',
          '\u2893',
          '\u2894',
          '\u2895',
          '\u2896',
          '\u2897',
          '\u28D0',
          '\u28D1',
          '\u28D2',
          '\u28D3',
          '\u28D4',
          '\u28D5',
          '\u28D6',
          '\u28D7',
          '\u2898',
          '\u2899',
          '\u289A',
          '\u289B',
          '\u289C',
          '\u289D',
          '\u289E',
          '\u289F',
          '\u28D8',
          '\u28D9',
          '\u28DA',
          '\u28DB',
          '\u28DC',
          '\u28DD',
          '\u28DE',
          '\u28DF',
          '\u28A0',
          '\u28A1',
          '\u28A2',
          '\u28A3',
          '\u28A4',
          '\u28A5',
          '\u28A6',
          '\u28A7',
          '\u28E0',
          '\u28E1',
          '\u28E2',
          '\u28E3',
          '\u28E4',
          '\u28E5',
          '\u28E6',
          '\u28E7',
          '\u28A8',
          '\u28A9',
          '\u28AA',
          '\u28AB',
          '\u28AC',
          '\u28AD',
          '\u28AE',
          '\u28AF',
          '\u28E8',
          '\u28E9',
          '\u28EA',
          '\u28EB',
          '\u28EC',
          '\u28ED',
          '\u28EE',
          '\u28EF',
          '\u28B0',
          '\u28B1',
          '\u28B2',
          '\u28B3',
          '\u28B4',
          '\u28B5',
          '\u28B6',
          '\u28B7',
          '\u28F0',
          '\u28F1',
          '\u28F2',
          '\u28F3',
          '\u28F4',
          '\u28F5',
          '\u28F6',
          '\u28F7',
          '\u28B8',
          '\u28B9',
          '\u28BA',
          '\u28BB',
          '\u28BC',
          '\u28BD',
          '\u28BE',
          '\u28BF',
          '\u28F8',
          '\u28F9',
          '\u28FA',
          '\u28FB',
          '\u28FC',
          '\u28FD',
          '\u28FE',
          '\u28FF',
        ],
      },
      sand: {
        interval: 80,
        frames: [
          '\u2801',
          '\u2802',
          '\u2804',
          '\u2840',
          '\u2848',
          '\u2850',
          '\u2860',
          '\u28C0',
          '\u28C1',
          '\u28C2',
          '\u28C4',
          '\u28CC',
          '\u28D4',
          '\u28E4',
          '\u28E5',
          '\u28E6',
          '\u28EE',
          '\u28F6',
          '\u28F7',
          '\u28FF',
          '\u287F',
          '\u283F',
          '\u289F',
          '\u281F',
          '\u285B',
          '\u281B',
          '\u282B',
          '\u288B',
          '\u280B',
          '\u280D',
          '\u2849',
          '\u2809',
          '\u2811',
          '\u2821',
          '\u2881',
        ],
      },
      line: {
        interval: 130,
        frames: ['-', '\\', '|', '/'],
      },
      line2: {
        interval: 100,
        frames: ['\u2802', '-', '\u2013', '\u2014', '\u2013', '-'],
      },
      pipe: {
        interval: 100,
        frames: ['\u2524', '\u2518', '\u2534', '\u2514', '\u251C', '\u250C', '\u252C', '\u2510'],
      },
      simpleDots: {
        interval: 400,
        frames: ['.  ', '.. ', '...', '   '],
      },
      simpleDotsScrolling: {
        interval: 200,
        frames: ['.  ', '.. ', '...', ' ..', '  .', '   '],
      },
      star: {
        interval: 70,
        frames: ['\u2736', '\u2738', '\u2739', '\u273A', '\u2739', '\u2737'],
      },
      star2: {
        interval: 80,
        frames: ['+', 'x', '*'],
      },
      flip: {
        interval: 70,
        frames: ['_', '_', '_', '-', '`', '`', "'", '\xB4', '-', '_', '_', '_'],
      },
      hamburger: {
        interval: 100,
        frames: ['\u2631', '\u2632', '\u2634'],
      },
      growVertical: {
        interval: 120,
        frames: ['\u2581', '\u2583', '\u2584', '\u2585', '\u2586', '\u2587', '\u2586', '\u2585', '\u2584', '\u2583'],
      },
      growHorizontal: {
        interval: 120,
        frames: [
          '\u258F',
          '\u258E',
          '\u258D',
          '\u258C',
          '\u258B',
          '\u258A',
          '\u2589',
          '\u258A',
          '\u258B',
          '\u258C',
          '\u258D',
          '\u258E',
        ],
      },
      balloon: {
        interval: 140,
        frames: [' ', '.', 'o', 'O', '@', '*', ' '],
      },
      balloon2: {
        interval: 120,
        frames: ['.', 'o', 'O', '\xB0', 'O', 'o', '.'],
      },
      noise: {
        interval: 100,
        frames: ['\u2593', '\u2592', '\u2591'],
      },
      bounce: {
        interval: 120,
        frames: ['\u2801', '\u2802', '\u2804', '\u2802'],
      },
      boxBounce: {
        interval: 120,
        frames: ['\u2596', '\u2598', '\u259D', '\u2597'],
      },
      boxBounce2: {
        interval: 100,
        frames: ['\u258C', '\u2580', '\u2590', '\u2584'],
      },
      triangle: {
        interval: 50,
        frames: ['\u25E2', '\u25E3', '\u25E4', '\u25E5'],
      },
      binary: {
        interval: 80,
        frames: ['010010', '001100', '100101', '111010', '111101', '010111', '101011', '111000', '110011', '110101'],
      },
      arc: {
        interval: 100,
        frames: ['\u25DC', '\u25E0', '\u25DD', '\u25DE', '\u25E1', '\u25DF'],
      },
      circle: {
        interval: 120,
        frames: ['\u25E1', '\u2299', '\u25E0'],
      },
      squareCorners: {
        interval: 180,
        frames: ['\u25F0', '\u25F3', '\u25F2', '\u25F1'],
      },
      circleQuarters: {
        interval: 120,
        frames: ['\u25F4', '\u25F7', '\u25F6', '\u25F5'],
      },
      circleHalves: {
        interval: 50,
        frames: ['\u25D0', '\u25D3', '\u25D1', '\u25D2'],
      },
      squish: {
        interval: 100,
        frames: ['\u256B', '\u256A'],
      },
      toggle: {
        interval: 250,
        frames: ['\u22B6', '\u22B7'],
      },
      toggle2: {
        interval: 80,
        frames: ['\u25AB', '\u25AA'],
      },
      toggle3: {
        interval: 120,
        frames: ['\u25A1', '\u25A0'],
      },
      toggle4: {
        interval: 100,
        frames: ['\u25A0', '\u25A1', '\u25AA', '\u25AB'],
      },
      toggle5: {
        interval: 100,
        frames: ['\u25AE', '\u25AF'],
      },
      toggle6: {
        interval: 300,
        frames: ['\u101D', '\u1040'],
      },
      toggle7: {
        interval: 80,
        frames: ['\u29BE', '\u29BF'],
      },
      toggle8: {
        interval: 100,
        frames: ['\u25CD', '\u25CC'],
      },
      toggle9: {
        interval: 100,
        frames: ['\u25C9', '\u25CE'],
      },
      toggle10: {
        interval: 100,
        frames: ['\u3282', '\u3280', '\u3281'],
      },
      toggle11: {
        interval: 50,
        frames: ['\u29C7', '\u29C6'],
      },
      toggle12: {
        interval: 120,
        frames: ['\u2617', '\u2616'],
      },
      toggle13: {
        interval: 80,
        frames: ['=', '*', '-'],
      },
      arrow: {
        interval: 100,
        frames: ['\u2190', '\u2196', '\u2191', '\u2197', '\u2192', '\u2198', '\u2193', '\u2199'],
      },
      arrow2: {
        interval: 80,
        frames: [
          '\u2B06\uFE0F ',
          '\u2197\uFE0F ',
          '\u27A1\uFE0F ',
          '\u2198\uFE0F ',
          '\u2B07\uFE0F ',
          '\u2199\uFE0F ',
          '\u2B05\uFE0F ',
          '\u2196\uFE0F ',
        ],
      },
      arrow3: {
        interval: 120,
        frames: [
          '\u25B9\u25B9\u25B9\u25B9\u25B9',
          '\u25B8\u25B9\u25B9\u25B9\u25B9',
          '\u25B9\u25B8\u25B9\u25B9\u25B9',
          '\u25B9\u25B9\u25B8\u25B9\u25B9',
          '\u25B9\u25B9\u25B9\u25B8\u25B9',
          '\u25B9\u25B9\u25B9\u25B9\u25B8',
        ],
      },
      bouncingBar: {
        interval: 80,
        frames: [
          '[    ]',
          '[=   ]',
          '[==  ]',
          '[=== ]',
          '[====]',
          '[ ===]',
          '[  ==]',
          '[   =]',
          '[    ]',
          '[   =]',
          '[  ==]',
          '[ ===]',
          '[====]',
          '[=== ]',
          '[==  ]',
          '[=   ]',
        ],
      },
      bouncingBall: {
        interval: 80,
        frames: [
          '( \u25CF    )',
          '(  \u25CF   )',
          '(   \u25CF  )',
          '(    \u25CF )',
          '(     \u25CF)',
          '(    \u25CF )',
          '(   \u25CF  )',
          '(  \u25CF   )',
          '( \u25CF    )',
          '(\u25CF     )',
        ],
      },
      smiley: {
        interval: 200,
        frames: ['\u{1F604} ', '\u{1F61D} '],
      },
      monkey: {
        interval: 300,
        frames: ['\u{1F648} ', '\u{1F648} ', '\u{1F649} ', '\u{1F64A} '],
      },
      hearts: {
        interval: 100,
        frames: ['\u{1F49B} ', '\u{1F499} ', '\u{1F49C} ', '\u{1F49A} ', '\u2764\uFE0F '],
      },
      clock: {
        interval: 100,
        frames: [
          '\u{1F55B} ',
          '\u{1F550} ',
          '\u{1F551} ',
          '\u{1F552} ',
          '\u{1F553} ',
          '\u{1F554} ',
          '\u{1F555} ',
          '\u{1F556} ',
          '\u{1F557} ',
          '\u{1F558} ',
          '\u{1F559} ',
          '\u{1F55A} ',
        ],
      },
      earth: {
        interval: 180,
        frames: ['\u{1F30D} ', '\u{1F30E} ', '\u{1F30F} '],
      },
      material: {
        interval: 17,
        frames: [
          '\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588',
          '\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588',
          '\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588',
          '\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588',
          '\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588',
          '\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588',
          '\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
        ],
      },
      moon: {
        interval: 80,
        frames: [
          '\u{1F311} ',
          '\u{1F312} ',
          '\u{1F313} ',
          '\u{1F314} ',
          '\u{1F315} ',
          '\u{1F316} ',
          '\u{1F317} ',
          '\u{1F318} ',
        ],
      },
      runner: {
        interval: 140,
        frames: ['\u{1F6B6} ', '\u{1F3C3} '],
      },
      pong: {
        interval: 80,
        frames: [
          '\u2590\u2802       \u258C',
          '\u2590\u2808       \u258C',
          '\u2590 \u2802      \u258C',
          '\u2590 \u2820      \u258C',
          '\u2590  \u2840     \u258C',
          '\u2590  \u2820     \u258C',
          '\u2590   \u2802    \u258C',
          '\u2590   \u2808    \u258C',
          '\u2590    \u2802   \u258C',
          '\u2590    \u2820   \u258C',
          '\u2590     \u2840  \u258C',
          '\u2590     \u2820  \u258C',
          '\u2590      \u2802 \u258C',
          '\u2590      \u2808 \u258C',
          '\u2590       \u2802\u258C',
          '\u2590       \u2820\u258C',
          '\u2590       \u2840\u258C',
          '\u2590      \u2820 \u258C',
          '\u2590      \u2802 \u258C',
          '\u2590     \u2808  \u258C',
          '\u2590     \u2802  \u258C',
          '\u2590    \u2820   \u258C',
          '\u2590    \u2840   \u258C',
          '\u2590   \u2820    \u258C',
          '\u2590   \u2802    \u258C',
          '\u2590  \u2808     \u258C',
          '\u2590  \u2802     \u258C',
          '\u2590 \u2820      \u258C',
          '\u2590 \u2840      \u258C',
          '\u2590\u2820       \u258C',
        ],
      },
      shark: {
        interval: 120,
        frames: [
          '\u2590|\\____________\u258C',
          '\u2590_|\\___________\u258C',
          '\u2590__|\\__________\u258C',
          '\u2590___|\\_________\u258C',
          '\u2590____|\\________\u258C',
          '\u2590_____|\\_______\u258C',
          '\u2590______|\\______\u258C',
          '\u2590_______|\\_____\u258C',
          '\u2590________|\\____\u258C',
          '\u2590_________|\\___\u258C',
          '\u2590__________|\\__\u258C',
          '\u2590___________|\\_\u258C',
          '\u2590____________|\\\u258C',
          '\u2590____________/|\u258C',
          '\u2590___________/|_\u258C',
          '\u2590__________/|__\u258C',
          '\u2590_________/|___\u258C',
          '\u2590________/|____\u258C',
          '\u2590_______/|_____\u258C',
          '\u2590______/|______\u258C',
          '\u2590_____/|_______\u258C',
          '\u2590____/|________\u258C',
          '\u2590___/|_________\u258C',
          '\u2590__/|__________\u258C',
          '\u2590_/|___________\u258C',
          '\u2590/|____________\u258C',
        ],
      },
      dqpb: {
        interval: 100,
        frames: ['d', 'q', 'p', 'b'],
      },
      weather: {
        interval: 100,
        frames: [
          '\u2600\uFE0F ',
          '\u2600\uFE0F ',
          '\u2600\uFE0F ',
          '\u{1F324} ',
          '\u26C5\uFE0F ',
          '\u{1F325} ',
          '\u2601\uFE0F ',
          '\u{1F327} ',
          '\u{1F328} ',
          '\u{1F327} ',
          '\u{1F328} ',
          '\u{1F327} ',
          '\u{1F328} ',
          '\u26C8 ',
          '\u{1F328} ',
          '\u{1F327} ',
          '\u{1F328} ',
          '\u2601\uFE0F ',
          '\u{1F325} ',
          '\u26C5\uFE0F ',
          '\u{1F324} ',
          '\u2600\uFE0F ',
          '\u2600\uFE0F ',
        ],
      },
      christmas: {
        interval: 400,
        frames: ['\u{1F332}', '\u{1F384}'],
      },
      grenade: {
        interval: 80,
        frames: [
          '\u060C  ',
          '\u2032  ',
          ' \xB4 ',
          ' \u203E ',
          '  \u2E0C',
          '  \u2E0A',
          '  |',
          '  \u204E',
          '  \u2055',
          ' \u0DF4 ',
          '  \u2053',
          '   ',
          '   ',
          '   ',
        ],
      },
      point: {
        interval: 125,
        frames: [
          '\u2219\u2219\u2219',
          '\u25CF\u2219\u2219',
          '\u2219\u25CF\u2219',
          '\u2219\u2219\u25CF',
          '\u2219\u2219\u2219',
        ],
      },
      layer: {
        interval: 150,
        frames: ['-', '=', '\u2261'],
      },
      betaWave: {
        interval: 80,
        frames: [
          '\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2',
          '\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2',
          '\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2',
          '\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2',
          '\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2',
          '\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2',
          '\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1',
        ],
      },
      fingerDance: {
        interval: 160,
        frames: ['\u{1F918} ', '\u{1F91F} ', '\u{1F596} ', '\u270B ', '\u{1F91A} ', '\u{1F446} '],
      },
      fistBump: {
        interval: 80,
        frames: [
          '\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ',
          '\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ',
          '\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ',
          '\u3000\u{1F91C}\u3000\u3000\u{1F91B}\u3000 ',
          '\u3000\u3000\u{1F91C}\u{1F91B}\u3000\u3000 ',
          '\u3000\u{1F91C}\u2728\u{1F91B}\u3000\u3000 ',
          '\u{1F91C}\u3000\u2728\u3000\u{1F91B}\u3000 ',
        ],
      },
      soccerHeader: {
        interval: 80,
        frames: [
          ' \u{1F9D1}\u26BD\uFE0F       \u{1F9D1} ',
          '\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} ',
          '\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ',
          '\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ',
          '\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ',
          '\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ',
          '\u{1F9D1}       \u26BD\uFE0F\u{1F9D1}  ',
          '\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ',
          '\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ',
          '\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ',
          '\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ',
          '\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} ',
        ],
      },
      mindblown: {
        interval: 160,
        frames: [
          '\u{1F610} ',
          '\u{1F610} ',
          '\u{1F62E} ',
          '\u{1F62E} ',
          '\u{1F626} ',
          '\u{1F626} ',
          '\u{1F627} ',
          '\u{1F627} ',
          '\u{1F92F} ',
          '\u{1F4A5} ',
          '\u2728 ',
          '\u3000 ',
          '\u3000 ',
          '\u3000 ',
        ],
      },
      speaker: {
        interval: 160,
        frames: ['\u{1F508} ', '\u{1F509} ', '\u{1F50A} ', '\u{1F509} '],
      },
      orangePulse: {
        interval: 100,
        frames: ['\u{1F538} ', '\u{1F536} ', '\u{1F7E0} ', '\u{1F7E0} ', '\u{1F536} '],
      },
      bluePulse: {
        interval: 100,
        frames: ['\u{1F539} ', '\u{1F537} ', '\u{1F535} ', '\u{1F535} ', '\u{1F537} '],
      },
      orangeBluePulse: {
        interval: 100,
        frames: [
          '\u{1F538} ',
          '\u{1F536} ',
          '\u{1F7E0} ',
          '\u{1F7E0} ',
          '\u{1F536} ',
          '\u{1F539} ',
          '\u{1F537} ',
          '\u{1F535} ',
          '\u{1F535} ',
          '\u{1F537} ',
        ],
      },
      timeTravel: {
        interval: 100,
        frames: [
          '\u{1F55B} ',
          '\u{1F55A} ',
          '\u{1F559} ',
          '\u{1F558} ',
          '\u{1F557} ',
          '\u{1F556} ',
          '\u{1F555} ',
          '\u{1F554} ',
          '\u{1F553} ',
          '\u{1F552} ',
          '\u{1F551} ',
          '\u{1F550} ',
        ],
      },
      aesthetic: {
        interval: 80,
        frames: [
          '\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1',
          '\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1',
          '\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1',
          '\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1',
          '\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1',
          '\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1',
          '\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0',
          '\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1',
        ],
      },
      dwarfFortress: {
        interval: 80,
        frames: [
          ' \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '\u263A\u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '\u263A\u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '\u263A\u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '\u263A\u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '\u263A\u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '\u263A\u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '\u263A\u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '\u263A\u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '\u263A \u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u263A\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u263A\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u263A\u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u263A\u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u263A\u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u263A\u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u263A\u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u263A\u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u263A \u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u263A\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u263A\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u263A\u2593\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u263A\u2593\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u263A\u2592\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u263A\u2592\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u263A\u2591\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u263A\u2591\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u263A \u2588\u2588\u2588\xA3\xA3\xA3  ',
          '   \u263A\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '   \u263A\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '   \u263A\u2593\u2588\u2588\xA3\xA3\xA3  ',
          '   \u263A\u2593\u2588\u2588\xA3\xA3\xA3  ',
          '   \u263A\u2592\u2588\u2588\xA3\xA3\xA3  ',
          '   \u263A\u2592\u2588\u2588\xA3\xA3\xA3  ',
          '   \u263A\u2591\u2588\u2588\xA3\xA3\xA3  ',
          '   \u263A\u2591\u2588\u2588\xA3\xA3\xA3  ',
          '   \u263A \u2588\u2588\xA3\xA3\xA3  ',
          '    \u263A\u2588\u2588\xA3\xA3\xA3  ',
          '    \u263A\u2588\u2588\xA3\xA3\xA3  ',
          '    \u263A\u2593\u2588\xA3\xA3\xA3  ',
          '    \u263A\u2593\u2588\xA3\xA3\xA3  ',
          '    \u263A\u2592\u2588\xA3\xA3\xA3  ',
          '    \u263A\u2592\u2588\xA3\xA3\xA3  ',
          '    \u263A\u2591\u2588\xA3\xA3\xA3  ',
          '    \u263A\u2591\u2588\xA3\xA3\xA3  ',
          '    \u263A \u2588\xA3\xA3\xA3  ',
          '     \u263A\u2588\xA3\xA3\xA3  ',
          '     \u263A\u2588\xA3\xA3\xA3  ',
          '     \u263A\u2593\xA3\xA3\xA3  ',
          '     \u263A\u2593\xA3\xA3\xA3  ',
          '     \u263A\u2592\xA3\xA3\xA3  ',
          '     \u263A\u2592\xA3\xA3\xA3  ',
          '     \u263A\u2591\xA3\xA3\xA3  ',
          '     \u263A\u2591\xA3\xA3\xA3  ',
          '     \u263A \xA3\xA3\xA3  ',
          '      \u263A\xA3\xA3\xA3  ',
          '      \u263A\xA3\xA3\xA3  ',
          '      \u263A\u2593\xA3\xA3  ',
          '      \u263A\u2593\xA3\xA3  ',
          '      \u263A\u2592\xA3\xA3  ',
          '      \u263A\u2592\xA3\xA3  ',
          '      \u263A\u2591\xA3\xA3  ',
          '      \u263A\u2591\xA3\xA3  ',
          '      \u263A \xA3\xA3  ',
          '       \u263A\xA3\xA3  ',
          '       \u263A\xA3\xA3  ',
          '       \u263A\u2593\xA3  ',
          '       \u263A\u2593\xA3  ',
          '       \u263A\u2592\xA3  ',
          '       \u263A\u2592\xA3  ',
          '       \u263A\u2591\xA3  ',
          '       \u263A\u2591\xA3  ',
          '       \u263A \xA3  ',
          '        \u263A\xA3  ',
          '        \u263A\xA3  ',
          '        \u263A\u2593  ',
          '        \u263A\u2593  ',
          '        \u263A\u2592  ',
          '        \u263A\u2592  ',
          '        \u263A\u2591  ',
          '        \u263A\u2591  ',
          '        \u263A   ',
          '        \u263A  &',
          '        \u263A \u263C&',
          '       \u263A \u263C &',
          '       \u263A\u263C  &',
          '      \u263A\u263C  & ',
          '      \u203C   & ',
          '     \u263A   &  ',
          '    \u203C    &  ',
          '   \u263A    &   ',
          '  \u203C     &   ',
          ' \u263A     &    ',
          '\u203C      &    ',
          '      &     ',
          '      &     ',
          '     &   \u2591  ',
          '     &   \u2592  ',
          '    &    \u2593  ',
          '    &    \xA3  ',
          '   &    \u2591\xA3  ',
          '   &    \u2592\xA3  ',
          '  &     \u2593\xA3  ',
          '  &     \xA3\xA3  ',
          ' &     \u2591\xA3\xA3  ',
          ' &     \u2592\xA3\xA3  ',
          '&      \u2593\xA3\xA3  ',
          '&      \xA3\xA3\xA3  ',
          '      \u2591\xA3\xA3\xA3  ',
          '      \u2592\xA3\xA3\xA3  ',
          '      \u2593\xA3\xA3\xA3  ',
          '      \u2588\xA3\xA3\xA3  ',
          '     \u2591\u2588\xA3\xA3\xA3  ',
          '     \u2592\u2588\xA3\xA3\xA3  ',
          '     \u2593\u2588\xA3\xA3\xA3  ',
          '     \u2588\u2588\xA3\xA3\xA3  ',
          '    \u2591\u2588\u2588\xA3\xA3\xA3  ',
          '    \u2592\u2588\u2588\xA3\xA3\xA3  ',
          '    \u2593\u2588\u2588\xA3\xA3\xA3  ',
          '    \u2588\u2588\u2588\xA3\xA3\xA3  ',
          '   \u2591\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '   \u2592\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '   \u2593\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '   \u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          '  \u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
          ' \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ',
        ],
      },
    };
  },
});

// node_modules/cli-spinners/index.js
var require_cli_spinners = __commonJS({
  'node_modules/cli-spinners/index.js'(exports2, module2) {
    'use strict';
    var spinners = Object.assign({}, require_spinners());
    var spinnersList = Object.keys(spinners);
    Object.defineProperty(spinners, 'random', {
      get() {
        const randomIndex = Math.floor(Math.random() * spinnersList.length);
        const spinnerName = spinnersList[randomIndex];
        return spinners[spinnerName];
      },
    });
    module2.exports = spinners;
  },
});

// node_modules/ora/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  'node_modules/ora/node_modules/emoji-regex/index.js'(exports2, module2) {
    module2.exports = () => {
      return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    };
  },
});

// node_modules/@mixmark-io/domino/lib/Event.js
var require_Event = __commonJS({
  'node_modules/@mixmark-io/domino/lib/Event.js'(exports2, module2) {
    'use strict';
    module2.exports = Event;
    Event.CAPTURING_PHASE = 1;
    Event.AT_TARGET = 2;
    Event.BUBBLING_PHASE = 3;
    function Event(type, dictionary) {
      this.type = '';
      this.target = null;
      this.currentTarget = null;
      this.eventPhase = Event.AT_TARGET;
      this.bubbles = false;
      this.cancelable = false;
      this.isTrusted = false;
      this.defaultPrevented = false;
      this.timeStamp = Date.now();
      this._propagationStopped = false;
      this._immediatePropagationStopped = false;
      this._initialized = true;
      this._dispatching = false;
      if (type) this.type = type;
      if (dictionary) {
        for (var p in dictionary) {
          this[p] = dictionary[p];
        }
      }
    }
    Event.prototype = Object.create(Object.prototype, {
      constructor: { value: Event },
      stopPropagation: {
        value: function stopPropagation() {
          this._propagationStopped = true;
        },
      },
      stopImmediatePropagation: {
        value: function stopImmediatePropagation() {
          this._propagationStopped = true;
          this._immediatePropagationStopped = true;
        },
      },
      preventDefault: {
        value: function preventDefault() {
          if (this.cancelable) this.defaultPrevented = true;
        },
      },
      initEvent: {
        value: function initEvent(type, bubbles, cancelable) {
          this._initialized = true;
          if (this._dispatching) return;
          this._propagationStopped = false;
          this._immediatePropagationStopped = false;
          this.defaultPrevented = false;
          this.isTrusted = false;
          this.target = null;
          this.type = type;
          this.bubbles = bubbles;
          this.cancelable = cancelable;
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/UIEvent.js
var require_UIEvent = __commonJS({
  'node_modules/@mixmark-io/domino/lib/UIEvent.js'(exports2, module2) {
    'use strict';
    var Event = require_Event();
    module2.exports = UIEvent;
    function UIEvent() {
      Event.call(this);
      this.view = null;
      this.detail = 0;
    }
    UIEvent.prototype = Object.create(Event.prototype, {
      constructor: { value: UIEvent },
      initUIEvent: {
        value: function (type, bubbles, cancelable, view, detail) {
          this.initEvent(type, bubbles, cancelable);
          this.view = view;
          this.detail = detail;
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/MouseEvent.js
var require_MouseEvent = __commonJS({
  'node_modules/@mixmark-io/domino/lib/MouseEvent.js'(exports2, module2) {
    'use strict';
    var UIEvent = require_UIEvent();
    module2.exports = MouseEvent;
    function MouseEvent() {
      UIEvent.call(this);
      this.screenX = this.screenY = this.clientX = this.clientY = 0;
      this.ctrlKey = this.altKey = this.shiftKey = this.metaKey = false;
      this.button = 0;
      this.buttons = 1;
      this.relatedTarget = null;
    }
    MouseEvent.prototype = Object.create(UIEvent.prototype, {
      constructor: { value: MouseEvent },
      initMouseEvent: {
        value: function (
          type,
          bubbles,
          cancelable,
          view,
          detail,
          screenX,
          screenY,
          clientX,
          clientY,
          ctrlKey,
          altKey,
          shiftKey,
          metaKey,
          button,
          relatedTarget,
        ) {
          this.initEvent(type, bubbles, cancelable, view, detail);
          this.screenX = screenX;
          this.screenY = screenY;
          this.clientX = clientX;
          this.clientY = clientY;
          this.ctrlKey = ctrlKey;
          this.altKey = altKey;
          this.shiftKey = shiftKey;
          this.metaKey = metaKey;
          this.button = button;
          switch (button) {
            case 0:
              this.buttons = 1;
              break;
            case 1:
              this.buttons = 4;
              break;
            case 2:
              this.buttons = 2;
              break;
            default:
              this.buttons = 0;
              break;
          }
          this.relatedTarget = relatedTarget;
        },
      },
      getModifierState: {
        value: function (key) {
          switch (key) {
            case 'Alt':
              return this.altKey;
            case 'Control':
              return this.ctrlKey;
            case 'Shift':
              return this.shiftKey;
            case 'Meta':
              return this.metaKey;
            default:
              return false;
          }
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/DOMException.js
var require_DOMException = __commonJS({
  'node_modules/@mixmark-io/domino/lib/DOMException.js'(exports2, module2) {
    'use strict';
    module2.exports = DOMException;
    var INDEX_SIZE_ERR = 1;
    var HIERARCHY_REQUEST_ERR = 3;
    var WRONG_DOCUMENT_ERR = 4;
    var INVALID_CHARACTER_ERR = 5;
    var NO_MODIFICATION_ALLOWED_ERR = 7;
    var NOT_FOUND_ERR = 8;
    var NOT_SUPPORTED_ERR = 9;
    var INVALID_STATE_ERR = 11;
    var SYNTAX_ERR = 12;
    var INVALID_MODIFICATION_ERR = 13;
    var NAMESPACE_ERR = 14;
    var INVALID_ACCESS_ERR = 15;
    var TYPE_MISMATCH_ERR = 17;
    var SECURITY_ERR = 18;
    var NETWORK_ERR = 19;
    var ABORT_ERR = 20;
    var URL_MISMATCH_ERR = 21;
    var QUOTA_EXCEEDED_ERR = 22;
    var TIMEOUT_ERR = 23;
    var INVALID_NODE_TYPE_ERR = 24;
    var DATA_CLONE_ERR = 25;
    var names = [
      null,
      // No error with code 0
      'INDEX_SIZE_ERR',
      null,
      // historical
      'HIERARCHY_REQUEST_ERR',
      'WRONG_DOCUMENT_ERR',
      'INVALID_CHARACTER_ERR',
      null,
      // historical
      'NO_MODIFICATION_ALLOWED_ERR',
      'NOT_FOUND_ERR',
      'NOT_SUPPORTED_ERR',
      'INUSE_ATTRIBUTE_ERR',
      // historical
      'INVALID_STATE_ERR',
      'SYNTAX_ERR',
      'INVALID_MODIFICATION_ERR',
      'NAMESPACE_ERR',
      'INVALID_ACCESS_ERR',
      null,
      // historical
      'TYPE_MISMATCH_ERR',
      'SECURITY_ERR',
      'NETWORK_ERR',
      'ABORT_ERR',
      'URL_MISMATCH_ERR',
      'QUOTA_EXCEEDED_ERR',
      'TIMEOUT_ERR',
      'INVALID_NODE_TYPE_ERR',
      'DATA_CLONE_ERR',
    ];
    var messages = [
      null,
      // No error with code 0
      'INDEX_SIZE_ERR (1): the index is not in the allowed range',
      null,
      'HIERARCHY_REQUEST_ERR (3): the operation would yield an incorrect nodes model',
      'WRONG_DOCUMENT_ERR (4): the object is in the wrong Document, a call to importNode is required',
      'INVALID_CHARACTER_ERR (5): the string contains invalid characters',
      null,
      'NO_MODIFICATION_ALLOWED_ERR (7): the object can not be modified',
      'NOT_FOUND_ERR (8): the object can not be found here',
      'NOT_SUPPORTED_ERR (9): this operation is not supported',
      'INUSE_ATTRIBUTE_ERR (10): setAttributeNode called on owned Attribute',
      'INVALID_STATE_ERR (11): the object is in an invalid state',
      'SYNTAX_ERR (12): the string did not match the expected pattern',
      'INVALID_MODIFICATION_ERR (13): the object can not be modified in this way',
      'NAMESPACE_ERR (14): the operation is not allowed by Namespaces in XML',
      'INVALID_ACCESS_ERR (15): the object does not support the operation or argument',
      null,
      'TYPE_MISMATCH_ERR (17): the type of the object does not match the expected type',
      'SECURITY_ERR (18): the operation is insecure',
      'NETWORK_ERR (19): a network error occurred',
      'ABORT_ERR (20): the user aborted an operation',
      'URL_MISMATCH_ERR (21): the given URL does not match another URL',
      'QUOTA_EXCEEDED_ERR (22): the quota has been exceeded',
      'TIMEOUT_ERR (23): a timeout occurred',
      'INVALID_NODE_TYPE_ERR (24): the supplied node is invalid or has an invalid ancestor for this operation',
      'DATA_CLONE_ERR (25): the object can not be cloned.',
    ];
    var constants = {
      INDEX_SIZE_ERR,
      DOMSTRING_SIZE_ERR: 2,
      // historical
      HIERARCHY_REQUEST_ERR,
      WRONG_DOCUMENT_ERR,
      INVALID_CHARACTER_ERR,
      NO_DATA_ALLOWED_ERR: 6,
      // historical
      NO_MODIFICATION_ALLOWED_ERR,
      NOT_FOUND_ERR,
      NOT_SUPPORTED_ERR,
      INUSE_ATTRIBUTE_ERR: 10,
      // historical
      INVALID_STATE_ERR,
      SYNTAX_ERR,
      INVALID_MODIFICATION_ERR,
      NAMESPACE_ERR,
      INVALID_ACCESS_ERR,
      VALIDATION_ERR: 16,
      // historical
      TYPE_MISMATCH_ERR,
      SECURITY_ERR,
      NETWORK_ERR,
      ABORT_ERR,
      URL_MISMATCH_ERR,
      QUOTA_EXCEEDED_ERR,
      TIMEOUT_ERR,
      INVALID_NODE_TYPE_ERR,
      DATA_CLONE_ERR,
    };
    function DOMException(code) {
      Error.call(this);
      Error.captureStackTrace(this, this.constructor);
      this.code = code;
      this.message = messages[code];
      this.name = names[code];
    }
    DOMException.prototype.__proto__ = Error.prototype;
    for (c in constants) {
      v = { value: constants[c] };
      Object.defineProperty(DOMException, c, v);
      Object.defineProperty(DOMException.prototype, c, v);
    }
    var v;
    var c;
  },
});

// node_modules/@mixmark-io/domino/lib/config.js
var require_config = __commonJS({
  'node_modules/@mixmark-io/domino/lib/config.js'(exports2) {
    exports2.isApiWritable = !globalThis.__domino_frozen__;
  },
});

// node_modules/@mixmark-io/domino/lib/utils.js
var require_utils2 = __commonJS({
  'node_modules/@mixmark-io/domino/lib/utils.js'(exports2) {
    'use strict';
    var DOMException = require_DOMException();
    var ERR = DOMException;
    var isApiWritable = require_config().isApiWritable;
    exports2.NAMESPACE = {
      HTML: 'http://www.w3.org/1999/xhtml',
      XML: 'http://www.w3.org/XML/1998/namespace',
      XMLNS: 'http://www.w3.org/2000/xmlns/',
      MATHML: 'http://www.w3.org/1998/Math/MathML',
      SVG: 'http://www.w3.org/2000/svg',
      XLINK: 'http://www.w3.org/1999/xlink',
    };
    exports2.IndexSizeError = function () {
      throw new DOMException(ERR.INDEX_SIZE_ERR);
    };
    exports2.HierarchyRequestError = function () {
      throw new DOMException(ERR.HIERARCHY_REQUEST_ERR);
    };
    exports2.WrongDocumentError = function () {
      throw new DOMException(ERR.WRONG_DOCUMENT_ERR);
    };
    exports2.InvalidCharacterError = function () {
      throw new DOMException(ERR.INVALID_CHARACTER_ERR);
    };
    exports2.NoModificationAllowedError = function () {
      throw new DOMException(ERR.NO_MODIFICATION_ALLOWED_ERR);
    };
    exports2.NotFoundError = function () {
      throw new DOMException(ERR.NOT_FOUND_ERR);
    };
    exports2.NotSupportedError = function () {
      throw new DOMException(ERR.NOT_SUPPORTED_ERR);
    };
    exports2.InvalidStateError = function () {
      throw new DOMException(ERR.INVALID_STATE_ERR);
    };
    exports2.SyntaxError = function () {
      throw new DOMException(ERR.SYNTAX_ERR);
    };
    exports2.InvalidModificationError = function () {
      throw new DOMException(ERR.INVALID_MODIFICATION_ERR);
    };
    exports2.NamespaceError = function () {
      throw new DOMException(ERR.NAMESPACE_ERR);
    };
    exports2.InvalidAccessError = function () {
      throw new DOMException(ERR.INVALID_ACCESS_ERR);
    };
    exports2.TypeMismatchError = function () {
      throw new DOMException(ERR.TYPE_MISMATCH_ERR);
    };
    exports2.SecurityError = function () {
      throw new DOMException(ERR.SECURITY_ERR);
    };
    exports2.NetworkError = function () {
      throw new DOMException(ERR.NETWORK_ERR);
    };
    exports2.AbortError = function () {
      throw new DOMException(ERR.ABORT_ERR);
    };
    exports2.UrlMismatchError = function () {
      throw new DOMException(ERR.URL_MISMATCH_ERR);
    };
    exports2.QuotaExceededError = function () {
      throw new DOMException(ERR.QUOTA_EXCEEDED_ERR);
    };
    exports2.TimeoutError = function () {
      throw new DOMException(ERR.TIMEOUT_ERR);
    };
    exports2.InvalidNodeTypeError = function () {
      throw new DOMException(ERR.INVALID_NODE_TYPE_ERR);
    };
    exports2.DataCloneError = function () {
      throw new DOMException(ERR.DATA_CLONE_ERR);
    };
    exports2.nyi = function () {
      throw new Error('NotYetImplemented');
    };
    exports2.shouldOverride = function () {
      throw new Error('Abstract function; should be overriding in subclass.');
    };
    exports2.assert = function (expr, msg) {
      if (!expr) {
        throw new Error('Assertion failed: ' + (msg || '') + '\n' + new Error().stack);
      }
    };
    exports2.expose = function (src, c) {
      for (var n in src) {
        Object.defineProperty(c.prototype, n, { value: src[n], writable: isApiWritable });
      }
    };
    exports2.merge = function (a, b) {
      for (var n in b) {
        a[n] = b[n];
      }
    };
    exports2.documentOrder = function (n, m) {
      return 3 - (n.compareDocumentPosition(m) & 6);
    };
    exports2.toASCIILowerCase = function (s) {
      return s.replace(/[A-Z]+/g, function (c) {
        return c.toLowerCase();
      });
    };
    exports2.toASCIIUpperCase = function (s) {
      return s.replace(/[a-z]+/g, function (c) {
        return c.toUpperCase();
      });
    };
  },
});

// node_modules/@mixmark-io/domino/lib/EventTarget.js
var require_EventTarget = __commonJS({
  'node_modules/@mixmark-io/domino/lib/EventTarget.js'(exports2, module2) {
    'use strict';
    var Event = require_Event();
    var MouseEvent = require_MouseEvent();
    var utils = require_utils2();
    module2.exports = EventTarget;
    function EventTarget() {}
    EventTarget.prototype = {
      // XXX
      // See WebIDL §4.8 for details on object event handlers
      // and how they should behave.  We actually have to accept
      // any object to addEventListener... Can't type check it.
      // on registration.
      // XXX:
      // Capturing event listeners are sort of rare.  I think I can optimize
      // them so that dispatchEvent can skip the capturing phase (or much of
      // it).  Each time a capturing listener is added, increment a flag on
      // the target node and each of its ancestors.  Decrement when removed.
      // And update the counter when nodes are added and removed from the
      // tree as well.  Then, in dispatch event, the capturing phase can
      // abort if it sees any node with a zero count.
      addEventListener: function addEventListener(type, listener, capture) {
        if (!listener) return;
        if (capture === void 0) capture = false;
        if (!this._listeners) this._listeners = /* @__PURE__ */ Object.create(null);
        if (!this._listeners[type]) this._listeners[type] = [];
        var list = this._listeners[type];
        for (var i = 0, n = list.length; i < n; i++) {
          var l = list[i];
          if (l.listener === listener && l.capture === capture) return;
        }
        var obj = { listener, capture };
        if (typeof listener === 'function') obj.f = listener;
        list.push(obj);
      },
      removeEventListener: function removeEventListener(type, listener, capture) {
        if (capture === void 0) capture = false;
        if (this._listeners) {
          var list = this._listeners[type];
          if (list) {
            for (var i = 0, n = list.length; i < n; i++) {
              var l = list[i];
              if (l.listener === listener && l.capture === capture) {
                if (list.length === 1) {
                  this._listeners[type] = void 0;
                } else {
                  list.splice(i, 1);
                }
                return;
              }
            }
          }
        }
      },
      // This is the public API for dispatching untrusted public events.
      // See _dispatchEvent for the implementation
      dispatchEvent: function dispatchEvent(event) {
        return this._dispatchEvent(event, false);
      },
      //
      // See DOMCore §4.4
      // XXX: I'll probably need another version of this method for
      // internal use, one that does not set isTrusted to false.
      // XXX: see Document._dispatchEvent: perhaps that and this could
      // call a common internal function with different settings of
      // a trusted boolean argument
      //
      // XXX:
      // The spec has changed in how to deal with handlers registered
      // on idl or content attributes rather than with addEventListener.
      // Used to say that they always ran first.  That's how webkit does it
      // Spec now says that they run in a position determined by
      // when they were first set.  FF does it that way.  See:
      // http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#event-handlers
      //
      _dispatchEvent: function _dispatchEvent(event, trusted) {
        if (typeof trusted !== 'boolean') trusted = false;
        function invoke(target, event2) {
          var type = event2.type,
            phase = event2.eventPhase;
          event2.currentTarget = target;
          if (phase !== Event.CAPTURING_PHASE && target._handlers && target._handlers[type]) {
            var handler2 = target._handlers[type];
            var rv;
            if (typeof handler2 === 'function') {
              rv = handler2.call(event2.currentTarget, event2);
            } else {
              var f = handler2.handleEvent;
              if (typeof f !== 'function')
                throw new TypeError('handleEvent property of event handler object isnot a function.');
              rv = f.call(handler2, event2);
            }
            switch (event2.type) {
              case 'mouseover':
                if (rv === true) event2.preventDefault();
                break;
              case 'beforeunload':
              // XXX: eventually we need a special case here
              /* falls through */
              default:
                if (rv === false) event2.preventDefault();
                break;
            }
          }
          var list = target._listeners && target._listeners[type];
          if (!list) return;
          list = list.slice();
          for (var i2 = 0, n2 = list.length; i2 < n2; i2++) {
            if (event2._immediatePropagationStopped) return;
            var l = list[i2];
            if ((phase === Event.CAPTURING_PHASE && !l.capture) || (phase === Event.BUBBLING_PHASE && l.capture))
              continue;
            if (l.f) {
              l.f.call(event2.currentTarget, event2);
            } else {
              var fn = l.listener.handleEvent;
              if (typeof fn !== 'function')
                throw new TypeError('handleEvent property of event listener object is not a function.');
              fn.call(l.listener, event2);
            }
          }
        }
        if (!event._initialized || event._dispatching) utils.InvalidStateError();
        event.isTrusted = trusted;
        event._dispatching = true;
        event.target = this;
        var ancestors = [];
        for (var n = this.parentNode; n; n = n.parentNode) ancestors.push(n);
        event.eventPhase = Event.CAPTURING_PHASE;
        for (var i = ancestors.length - 1; i >= 0; i--) {
          invoke(ancestors[i], event);
          if (event._propagationStopped) break;
        }
        if (!event._propagationStopped) {
          event.eventPhase = Event.AT_TARGET;
          invoke(this, event);
        }
        if (event.bubbles && !event._propagationStopped) {
          event.eventPhase = Event.BUBBLING_PHASE;
          for (var ii = 0, nn = ancestors.length; ii < nn; ii++) {
            invoke(ancestors[ii], event);
            if (event._propagationStopped) break;
          }
        }
        event._dispatching = false;
        event.eventPhase = Event.AT_TARGET;
        event.currentTarget = null;
        if (trusted && !event.defaultPrevented && event instanceof MouseEvent) {
          switch (event.type) {
            case 'mousedown':
              this._armed = {
                x: event.clientX,
                y: event.clientY,
                t: event.timeStamp,
              };
              break;
            case 'mouseout':
            case 'mouseover':
              this._armed = null;
              break;
            case 'mouseup':
              if (this._isClick(event)) this._doClick(event);
              this._armed = null;
              break;
          }
        }
        return !event.defaultPrevented;
      },
      // Determine whether a click occurred
      // XXX We don't support double clicks for now
      _isClick: function (event) {
        return (
          this._armed !== null &&
          event.type === 'mouseup' &&
          event.isTrusted &&
          event.button === 0 &&
          event.timeStamp - this._armed.t < 1e3 &&
          Math.abs(event.clientX - this._armed.x) < 10 &&
          Math.abs(event.clientY - this._armed.Y) < 10
        );
      },
      // Clicks are handled like this:
      // http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#interactive-content-0
      //
      // Note that this method is similar to the HTMLElement.click() method
      // The event argument must be the trusted mouseup event
      _doClick: function (event) {
        if (this._click_in_progress) return;
        this._click_in_progress = true;
        var activated = this;
        while (activated && !activated._post_click_activation_steps) activated = activated.parentNode;
        if (activated && activated._pre_click_activation_steps) {
          activated._pre_click_activation_steps();
        }
        var click = this.ownerDocument.createEvent('MouseEvent');
        click.initMouseEvent(
          'click',
          true,
          true,
          this.ownerDocument.defaultView,
          1,
          event.screenX,
          event.screenY,
          event.clientX,
          event.clientY,
          event.ctrlKey,
          event.altKey,
          event.shiftKey,
          event.metaKey,
          event.button,
          null,
        );
        var result = this._dispatchEvent(click, true);
        if (activated) {
          if (result) {
            if (activated._post_click_activation_steps) activated._post_click_activation_steps(click);
          } else {
            if (activated._cancelled_activation_steps) activated._cancelled_activation_steps();
          }
        }
      },
      //
      // An event handler is like an event listener, but it registered
      // by setting an IDL or content attribute like onload or onclick.
      // There can only be one of these at a time for any event type.
      // This is an internal method for the attribute accessors and
      // content attribute handlers that need to register events handlers.
      // The type argument is the same as in addEventListener().
      // The handler argument is the same as listeners in addEventListener:
      // it can be a function or an object. Pass null to remove any existing
      // handler.  Handlers are always invoked before any listeners of
      // the same type.  They are not invoked during the capturing phase
      // of event dispatch.
      //
      _setEventHandler: function _setEventHandler(type, handler2) {
        if (!this._handlers) this._handlers = /* @__PURE__ */ Object.create(null);
        this._handlers[type] = handler2;
      },
      _getEventHandler: function _getEventHandler(type) {
        return (this._handlers && this._handlers[type]) || null;
      },
    };
  },
});

// node_modules/@mixmark-io/domino/lib/LinkedList.js
var require_LinkedList = __commonJS({
  'node_modules/@mixmark-io/domino/lib/LinkedList.js'(exports2, module2) {
    'use strict';
    var utils = require_utils2();
    var LinkedList = (module2.exports = {
      // basic validity tests on a circular linked list a
      valid: function (a) {
        utils.assert(a, 'list falsy');
        utils.assert(a._previousSibling, 'previous falsy');
        utils.assert(a._nextSibling, 'next falsy');
        return true;
      },
      // insert a before b
      insertBefore: function (a, b) {
        utils.assert(LinkedList.valid(a) && LinkedList.valid(b));
        var a_first = a,
          a_last = a._previousSibling;
        var b_first = b,
          b_last = b._previousSibling;
        a_first._previousSibling = b_last;
        a_last._nextSibling = b_first;
        b_last._nextSibling = a_first;
        b_first._previousSibling = a_last;
        utils.assert(LinkedList.valid(a) && LinkedList.valid(b));
      },
      // replace a single node a with a list b (which could be null)
      replace: function (a, b) {
        utils.assert(LinkedList.valid(a) && (b === null || LinkedList.valid(b)));
        if (b !== null) {
          LinkedList.insertBefore(b, a);
        }
        LinkedList.remove(a);
        utils.assert(LinkedList.valid(a) && (b === null || LinkedList.valid(b)));
      },
      // remove single node a from its list
      remove: function (a) {
        utils.assert(LinkedList.valid(a));
        var prev = a._previousSibling;
        if (prev === a) {
          return;
        }
        var next = a._nextSibling;
        prev._nextSibling = next;
        next._previousSibling = prev;
        a._previousSibling = a._nextSibling = a;
        utils.assert(LinkedList.valid(a));
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/NodeUtils.js
var require_NodeUtils = __commonJS({
  'node_modules/@mixmark-io/domino/lib/NodeUtils.js'(exports2, module2) {
    'use strict';
    module2.exports = {
      // NOTE: The `serializeOne()` function used to live on the `Node.prototype`
      // as a private method `Node#_serializeOne(child)`, however that requires
      // a megamorphic property access `this._serializeOne` just to get to the
      // method, and this is being done on lots of different `Node` subclasses,
      // which puts a lot of pressure on V8's megamorphic stub cache. So by
      // moving the helper off of the `Node.prototype` and into a separate
      // function in this helper module, we get a monomorphic property access
      // `NodeUtils.serializeOne` to get to the function and reduce pressure
      // on the megamorphic stub cache.
      // See https://github.com/fgnass/domino/pull/142 for more information.
      serializeOne,
      // Export util functions so that we can run extra test for them.
      // Note: we prefix function names with `ɵ`, similar to what we do
      // with internal functions in Angular packages.
      ɵescapeMatchingClosingTag: escapeMatchingClosingTag,
      ɵescapeClosingCommentTag: escapeClosingCommentTag,
      ɵescapeProcessingInstructionContent: escapeProcessingInstructionContent,
    };
    var utils = require_utils2();
    var NAMESPACE = utils.NAMESPACE;
    var hasRawContent = {
      STYLE: true,
      SCRIPT: true,
      XMP: true,
      IFRAME: true,
      NOEMBED: true,
      NOFRAMES: true,
      PLAINTEXT: true,
    };
    var emptyElements = {
      area: true,
      base: true,
      basefont: true,
      bgsound: true,
      br: true,
      col: true,
      embed: true,
      frame: true,
      hr: true,
      img: true,
      input: true,
      keygen: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true,
    };
    var extraNewLine = {
      /* Removed in https://github.com/whatwg/html/issues/944
      pre: true,
      textarea: true,
      listing: true
      */
    };
    var ESCAPE_REGEXP = /[&<>\u00A0]/g;
    var ESCAPE_ATTR_REGEXP = /[&"<>\u00A0]/g;
    function escape(s) {
      if (!ESCAPE_REGEXP.test(s)) {
        return s;
      }
      return s.replace(ESCAPE_REGEXP, (c) => {
        switch (c) {
          case '&':
            return '&amp;';
          case '<':
            return '&lt;';
          case '>':
            return '&gt;';
          case '\xA0':
            return '&nbsp;';
        }
      });
    }
    function escapeAttr(s) {
      if (!ESCAPE_ATTR_REGEXP.test(s)) {
        return s;
      }
      return s.replace(ESCAPE_ATTR_REGEXP, (c) => {
        switch (c) {
          case '<':
            return '&lt;';
          case '>':
            return '&gt;';
          case '&':
            return '&amp;';
          case '"':
            return '&quot;';
          case '\xA0':
            return '&nbsp;';
        }
      });
    }
    function attrname(a) {
      var ns = a.namespaceURI;
      if (!ns) return a.localName;
      if (ns === NAMESPACE.XML) return 'xml:' + a.localName;
      if (ns === NAMESPACE.XLINK) return 'xlink:' + a.localName;
      if (ns === NAMESPACE.XMLNS) {
        if (a.localName === 'xmlns') return 'xmlns';
        else return 'xmlns:' + a.localName;
      }
      return a.name;
    }
    function escapeMatchingClosingTag(rawText, parentTag) {
      const parentClosingTag = '</' + parentTag;
      if (!rawText.toLowerCase().includes(parentClosingTag)) {
        return rawText;
      }
      const result = [...rawText];
      const matches = rawText.matchAll(new RegExp(parentClosingTag, 'ig'));
      for (const match of matches) {
        result[match.index] = '&lt;';
      }
      return result.join('');
    }
    var CLOSING_COMMENT_REGEXP = /--!?>/;
    function escapeClosingCommentTag(rawContent) {
      if (!CLOSING_COMMENT_REGEXP.test(rawContent)) {
        return rawContent;
      }
      return rawContent.replace(/(--\!?)>/g, '$1&gt;');
    }
    function escapeProcessingInstructionContent(rawContent) {
      return rawContent.includes('>') ? rawContent.replaceAll('>', '&gt;') : rawContent;
    }
    function serializeOne(kid, parent) {
      var s = '';
      switch (kid.nodeType) {
        case 1:
          var ns = kid.namespaceURI;
          var html = ns === NAMESPACE.HTML;
          var tagname = html || ns === NAMESPACE.SVG || ns === NAMESPACE.MATHML ? kid.localName : kid.tagName;
          s += '<' + tagname;
          for (var j = 0, k = kid._numattrs; j < k; j++) {
            var a = kid._attr(j);
            s += ' ' + attrname(a);
            if (a.value !== void 0) s += '="' + escapeAttr(a.value) + '"';
          }
          s += '>';
          if (!(html && emptyElements[tagname])) {
            var ss = kid.serialize();
            if (hasRawContent[tagname.toUpperCase()]) {
              ss = escapeMatchingClosingTag(ss, tagname);
            }
            if (html && extraNewLine[tagname] && ss.charAt(0) === '\n') s += '\n';
            s += ss;
            s += '</' + tagname + '>';
          }
          break;
        case 3:
        //TEXT_NODE
        case 4:
          var parenttag;
          if (parent.nodeType === 1 && parent.namespaceURI === NAMESPACE.HTML) parenttag = parent.tagName;
          else parenttag = '';
          if (hasRawContent[parenttag] || (parenttag === 'NOSCRIPT' && parent.ownerDocument._scripting_enabled)) {
            s += kid.data;
          } else {
            s += escape(kid.data);
          }
          break;
        case 8:
          s += '<!--' + escapeClosingCommentTag(kid.data) + '-->';
          break;
        case 7:
          const content = escapeProcessingInstructionContent(kid.data);
          s += '<?' + kid.target + ' ' + content + '?>';
          break;
        case 10:
          s += '<!DOCTYPE ' + kid.name;
          if (false) {
            if (kid.publicID) {
              s += ' PUBLIC "' + kid.publicId + '"';
            }
            if (kid.systemId) {
              s += ' "' + kid.systemId + '"';
            }
          }
          s += '>';
          break;
        default:
          utils.InvalidStateError();
      }
      return s;
    }
  },
});

// node_modules/@mixmark-io/domino/lib/Node.js
var require_Node = __commonJS({
  'node_modules/@mixmark-io/domino/lib/Node.js'(exports2, module2) {
    'use strict';
    module2.exports = Node;
    var EventTarget = require_EventTarget();
    var LinkedList = require_LinkedList();
    var NodeUtils = require_NodeUtils();
    var utils = require_utils2();
    function Node() {
      EventTarget.call(this);
      this.parentNode = null;
      this._nextSibling = this._previousSibling = this;
      this._index = void 0;
    }
    var ELEMENT_NODE = (Node.ELEMENT_NODE = 1);
    var ATTRIBUTE_NODE = (Node.ATTRIBUTE_NODE = 2);
    var TEXT_NODE = (Node.TEXT_NODE = 3);
    var CDATA_SECTION_NODE = (Node.CDATA_SECTION_NODE = 4);
    var ENTITY_REFERENCE_NODE = (Node.ENTITY_REFERENCE_NODE = 5);
    var ENTITY_NODE = (Node.ENTITY_NODE = 6);
    var PROCESSING_INSTRUCTION_NODE = (Node.PROCESSING_INSTRUCTION_NODE = 7);
    var COMMENT_NODE = (Node.COMMENT_NODE = 8);
    var DOCUMENT_NODE = (Node.DOCUMENT_NODE = 9);
    var DOCUMENT_TYPE_NODE = (Node.DOCUMENT_TYPE_NODE = 10);
    var DOCUMENT_FRAGMENT_NODE = (Node.DOCUMENT_FRAGMENT_NODE = 11);
    var NOTATION_NODE = (Node.NOTATION_NODE = 12);
    var DOCUMENT_POSITION_DISCONNECTED = (Node.DOCUMENT_POSITION_DISCONNECTED = 1);
    var DOCUMENT_POSITION_PRECEDING = (Node.DOCUMENT_POSITION_PRECEDING = 2);
    var DOCUMENT_POSITION_FOLLOWING = (Node.DOCUMENT_POSITION_FOLLOWING = 4);
    var DOCUMENT_POSITION_CONTAINS = (Node.DOCUMENT_POSITION_CONTAINS = 8);
    var DOCUMENT_POSITION_CONTAINED_BY = (Node.DOCUMENT_POSITION_CONTAINED_BY = 16);
    var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = (Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32);
    Node.prototype = Object.create(EventTarget.prototype, {
      // Node that are not inserted into the tree inherit a null parent
      // XXX: the baseURI attribute is defined by dom core, but
      // a correct implementation of it requires HTML features, so
      // we'll come back to this later.
      baseURI: { get: utils.nyi },
      parentElement: {
        get: function () {
          return this.parentNode && this.parentNode.nodeType === ELEMENT_NODE ? this.parentNode : null;
        },
      },
      hasChildNodes: { value: utils.shouldOverride },
      firstChild: { get: utils.shouldOverride },
      lastChild: { get: utils.shouldOverride },
      isConnected: {
        get: function () {
          let node = this;
          while (node != null) {
            if (node.nodeType === Node.DOCUMENT_NODE) {
              return true;
            }
            node = node.parentNode;
            if (node != null && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
              node = node.host;
            }
          }
          return false;
        },
      },
      previousSibling: {
        get: function () {
          var parent = this.parentNode;
          if (!parent) return null;
          if (this === parent.firstChild) return null;
          return this._previousSibling;
        },
      },
      nextSibling: {
        get: function () {
          var parent = this.parentNode,
            next = this._nextSibling;
          if (!parent) return null;
          if (next === parent.firstChild) return null;
          return next;
        },
      },
      textContent: {
        // Should override for DocumentFragment/Element/Attr/Text/PI/Comment
        get: function () {
          return null;
        },
        set: function (v) {},
      },
      innerText: {
        // Should override for DocumentFragment/Element/Attr/Text/PI/Comment
        get: function () {
          return null;
        },
        set: function (v) {},
      },
      _countChildrenOfType: {
        value: function (type) {
          var sum = 0;
          for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
            if (kid.nodeType === type) sum++;
          }
          return sum;
        },
      },
      _ensureInsertValid: {
        value: function _ensureInsertValid(node, child, isPreinsert) {
          var parent = this,
            i,
            kid;
          if (!node.nodeType) throw new TypeError('not a node');
          switch (parent.nodeType) {
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
            case ELEMENT_NODE:
              break;
            default:
              utils.HierarchyRequestError();
          }
          if (node.isAncestor(parent)) utils.HierarchyRequestError();
          if (child !== null || !isPreinsert) {
            if (child.parentNode !== parent) utils.NotFoundError();
          }
          switch (node.nodeType) {
            case DOCUMENT_FRAGMENT_NODE:
            case DOCUMENT_TYPE_NODE:
            case ELEMENT_NODE:
            case TEXT_NODE:
            case PROCESSING_INSTRUCTION_NODE:
            case COMMENT_NODE:
              break;
            default:
              utils.HierarchyRequestError();
          }
          if (parent.nodeType === DOCUMENT_NODE) {
            switch (node.nodeType) {
              case TEXT_NODE:
                utils.HierarchyRequestError();
                break;
              case DOCUMENT_FRAGMENT_NODE:
                if (node._countChildrenOfType(TEXT_NODE) > 0) utils.HierarchyRequestError();
                switch (node._countChildrenOfType(ELEMENT_NODE)) {
                  case 0:
                    break;
                  case 1:
                    if (child !== null) {
                      if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
                      for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {
                        if (kid.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
                      }
                    }
                    i = parent._countChildrenOfType(ELEMENT_NODE);
                    if (isPreinsert) {
                      if (i > 0) utils.HierarchyRequestError();
                    } else {
                      if (i > 1 || (i === 1 && child.nodeType !== ELEMENT_NODE)) utils.HierarchyRequestError();
                    }
                    break;
                  default:
                    utils.HierarchyRequestError();
                }
                break;
              case ELEMENT_NODE:
                if (child !== null) {
                  if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
                  for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {
                    if (kid.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
                  }
                }
                i = parent._countChildrenOfType(ELEMENT_NODE);
                if (isPreinsert) {
                  if (i > 0) utils.HierarchyRequestError();
                } else {
                  if (i > 1 || (i === 1 && child.nodeType !== ELEMENT_NODE)) utils.HierarchyRequestError();
                }
                break;
              case DOCUMENT_TYPE_NODE:
                if (child === null) {
                  if (parent._countChildrenOfType(ELEMENT_NODE)) utils.HierarchyRequestError();
                } else {
                  for (kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {
                    if (kid === child) break;
                    if (kid.nodeType === ELEMENT_NODE) utils.HierarchyRequestError();
                  }
                }
                i = parent._countChildrenOfType(DOCUMENT_TYPE_NODE);
                if (isPreinsert) {
                  if (i > 0) utils.HierarchyRequestError();
                } else {
                  if (i > 1 || (i === 1 && child.nodeType !== DOCUMENT_TYPE_NODE)) utils.HierarchyRequestError();
                }
                break;
            }
          } else {
            if (node.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
          }
        },
      },
      insertBefore: {
        value: function insertBefore(node, child) {
          var parent = this;
          parent._ensureInsertValid(node, child, true);
          var refChild = child;
          if (refChild === node) {
            refChild = node.nextSibling;
          }
          parent.doc.adoptNode(node);
          node._insertOrReplace(parent, refChild, false);
          return node;
        },
      },
      appendChild: {
        value: function (child) {
          return this.insertBefore(child, null);
        },
      },
      _appendChild: {
        value: function (child) {
          child._insertOrReplace(this, null, false);
        },
      },
      removeChild: {
        value: function removeChild(child) {
          var parent = this;
          if (!child.nodeType) throw new TypeError('not a node');
          if (child.parentNode !== parent) utils.NotFoundError();
          child.remove();
          return child;
        },
      },
      // To replace a `child` with `node` within a `parent` (this)
      replaceChild: {
        value: function replaceChild(node, child) {
          var parent = this;
          parent._ensureInsertValid(node, child, false);
          if (node.doc !== parent.doc) {
            parent.doc.adoptNode(node);
          }
          node._insertOrReplace(parent, child, true);
          return child;
        },
      },
      // See: http://ejohn.org/blog/comparing-document-position/
      contains: {
        value: function contains(node) {
          if (node === null) {
            return false;
          }
          if (this === node) {
            return true;
          }
          return (this.compareDocumentPosition(node) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
        },
      },
      compareDocumentPosition: {
        value: function compareDocumentPosition(that) {
          if (this === that) return 0;
          if (this.doc !== that.doc || this.rooted !== that.rooted)
            return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          var these = [],
            those = [];
          for (var n = this; n !== null; n = n.parentNode) these.push(n);
          for (n = that; n !== null; n = n.parentNode) those.push(n);
          these.reverse();
          those.reverse();
          if (these[0] !== those[0]) return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          n = Math.min(these.length, those.length);
          for (var i = 1; i < n; i++) {
            if (these[i] !== those[i]) {
              if (these[i].index < those[i].index) return DOCUMENT_POSITION_FOLLOWING;
              else return DOCUMENT_POSITION_PRECEDING;
            }
          }
          if (these.length < those.length) return DOCUMENT_POSITION_FOLLOWING + DOCUMENT_POSITION_CONTAINED_BY;
          else return DOCUMENT_POSITION_PRECEDING + DOCUMENT_POSITION_CONTAINS;
        },
      },
      isSameNode: {
        value: function isSameNode(node) {
          return this === node;
        },
      },
      // This method implements the generic parts of node equality testing
      // and defers to the (non-recursive) type-specific isEqual() method
      // defined by subclasses
      isEqualNode: {
        value: function isEqualNode(node) {
          if (!node) return false;
          if (node.nodeType !== this.nodeType) return false;
          if (!this.isEqual(node)) return false;
          for (var c1 = this.firstChild, c2 = node.firstChild; c1 && c2; c1 = c1.nextSibling, c2 = c2.nextSibling) {
            if (!c1.isEqualNode(c2)) return false;
          }
          return c1 === null && c2 === null;
        },
      },
      // This method delegates shallow cloning to a clone() method
      // that each concrete subclass must implement
      cloneNode: {
        value: function (deep) {
          var clone = this.clone();
          if (deep) {
            for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
              clone._appendChild(kid.cloneNode(true));
            }
          }
          return clone;
        },
      },
      lookupPrefix: {
        value: function lookupPrefix(ns) {
          var e;
          if (ns === '' || ns === null || ns === void 0) return null;
          switch (this.nodeType) {
            case ELEMENT_NODE:
              return this._lookupNamespacePrefix(ns, this);
            case DOCUMENT_NODE:
              e = this.documentElement;
              return e ? e.lookupPrefix(ns) : null;
            case ENTITY_NODE:
            case NOTATION_NODE:
            case DOCUMENT_FRAGMENT_NODE:
            case DOCUMENT_TYPE_NODE:
              return null;
            case ATTRIBUTE_NODE:
              e = this.ownerElement;
              return e ? e.lookupPrefix(ns) : null;
            default:
              e = this.parentElement;
              return e ? e.lookupPrefix(ns) : null;
          }
        },
      },
      lookupNamespaceURI: {
        value: function lookupNamespaceURI(prefix) {
          if (prefix === '' || prefix === void 0) {
            prefix = null;
          }
          var e;
          switch (this.nodeType) {
            case ELEMENT_NODE:
              return utils.shouldOverride();
            case DOCUMENT_NODE:
              e = this.documentElement;
              return e ? e.lookupNamespaceURI(prefix) : null;
            case ENTITY_NODE:
            case NOTATION_NODE:
            case DOCUMENT_TYPE_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              return null;
            case ATTRIBUTE_NODE:
              e = this.ownerElement;
              return e ? e.lookupNamespaceURI(prefix) : null;
            default:
              e = this.parentElement;
              return e ? e.lookupNamespaceURI(prefix) : null;
          }
        },
      },
      isDefaultNamespace: {
        value: function isDefaultNamespace(ns) {
          if (ns === '' || ns === void 0) {
            ns = null;
          }
          var defaultNamespace = this.lookupNamespaceURI(null);
          return defaultNamespace === ns;
        },
      },
      // Utility methods for nodes.  Not part of the DOM
      // Return the index of this node in its parent.
      // Throw if no parent, or if this node is not a child of its parent
      index: {
        get: function () {
          var parent = this.parentNode;
          if (this === parent.firstChild) return 0;
          var kids = parent.childNodes;
          if (this._index === void 0 || kids[this._index] !== this) {
            for (var i = 0; i < kids.length; i++) {
              kids[i]._index = i;
            }
            utils.assert(kids[this._index] === this);
          }
          return this._index;
        },
      },
      // Return true if this node is equal to or is an ancestor of that node
      // Note that nodes are considered to be ancestors of themselves
      isAncestor: {
        value: function (that) {
          if (this.doc !== that.doc) return false;
          if (this.rooted !== that.rooted) return false;
          for (var e = that; e; e = e.parentNode) {
            if (e === this) return true;
          }
          return false;
        },
      },
      // DOMINO Changed the behavior to conform with the specs. See:
      // https://groups.google.com/d/topic/mozilla.dev.platform/77sIYcpdDmc/discussion
      ensureSameDoc: {
        value: function (that) {
          if (that.ownerDocument === null) {
            that.ownerDocument = this.doc;
          } else if (that.ownerDocument !== this.doc) {
            utils.WrongDocumentError();
          }
        },
      },
      removeChildren: { value: utils.shouldOverride },
      // Insert this node as a child of parent before the specified child,
      // or insert as the last child of parent if specified child is null,
      // or replace the specified child with this node, firing mutation events as
      // necessary
      _insertOrReplace: {
        value: function _insertOrReplace(parent, before, isReplace) {
          var child = this,
            before_index,
            i;
          if (child.nodeType === DOCUMENT_FRAGMENT_NODE && child.rooted) {
            utils.HierarchyRequestError();
          }
          if (parent._childNodes) {
            before_index = before === null ? parent._childNodes.length : before.index;
            if (child.parentNode === parent) {
              var child_index = child.index;
              if (child_index < before_index) {
                before_index--;
              }
            }
          }
          if (isReplace) {
            if (before.rooted) before.doc.mutateRemove(before);
            before.parentNode = null;
          }
          var n = before;
          if (n === null) {
            n = parent.firstChild;
          }
          var bothRooted = child.rooted && parent.rooted;
          if (child.nodeType === DOCUMENT_FRAGMENT_NODE) {
            var spliceArgs = [0, isReplace ? 1 : 0],
              next;
            for (var kid = child.firstChild; kid !== null; kid = next) {
              next = kid.nextSibling;
              spliceArgs.push(kid);
              kid.parentNode = parent;
            }
            var len = spliceArgs.length;
            if (isReplace) {
              LinkedList.replace(n, len > 2 ? spliceArgs[2] : null);
            } else if (len > 2 && n !== null) {
              LinkedList.insertBefore(spliceArgs[2], n);
            }
            if (parent._childNodes) {
              spliceArgs[0] = before === null ? parent._childNodes.length : before._index;
              parent._childNodes.splice.apply(parent._childNodes, spliceArgs);
              for (i = 2; i < len; i++) {
                spliceArgs[i]._index = spliceArgs[0] + (i - 2);
              }
            } else if (parent._firstChild === before) {
              if (len > 2) {
                parent._firstChild = spliceArgs[2];
              } else if (isReplace) {
                parent._firstChild = null;
              }
            }
            if (child._childNodes) {
              child._childNodes.length = 0;
            } else {
              child._firstChild = null;
            }
            if (parent.rooted) {
              parent.modify();
              for (i = 2; i < len; i++) {
                parent.doc.mutateInsert(spliceArgs[i]);
              }
            }
          } else {
            if (before === child) {
              return;
            }
            if (bothRooted) {
              child._remove();
            } else if (child.parentNode) {
              child.remove();
            }
            child.parentNode = parent;
            if (isReplace) {
              LinkedList.replace(n, child);
              if (parent._childNodes) {
                child._index = before_index;
                parent._childNodes[before_index] = child;
              } else if (parent._firstChild === before) {
                parent._firstChild = child;
              }
            } else {
              if (n !== null) {
                LinkedList.insertBefore(child, n);
              }
              if (parent._childNodes) {
                child._index = before_index;
                parent._childNodes.splice(before_index, 0, child);
              } else if (parent._firstChild === before) {
                parent._firstChild = child;
              }
            }
            if (bothRooted) {
              parent.modify();
              parent.doc.mutateMove(child);
            } else if (parent.rooted) {
              parent.modify();
              parent.doc.mutateInsert(child);
            }
          }
        },
      },
      // Return the lastModTime value for this node. (For use as a
      // cache invalidation mechanism. If the node does not already
      // have one, initialize it from the owner document's modclock
      // property. (Note that modclock does not return the actual
      // time; it is simply a counter incremented on each document
      // modification)
      lastModTime: {
        get: function () {
          if (!this._lastModTime) {
            this._lastModTime = this.doc.modclock;
          }
          return this._lastModTime;
        },
      },
      // Increment the owner document's modclock and use the new
      // value to update the lastModTime value for this node and
      // all of its ancestors. Nodes that have never had their
      // lastModTime value queried do not need to have a
      // lastModTime property set on them since there is no
      // previously queried value to ever compare the new value
      // against, so only update nodes that already have a
      // _lastModTime property.
      modify: {
        value: function () {
          if (this.doc.modclock) {
            var time = ++this.doc.modclock;
            for (var n = this; n; n = n.parentElement) {
              if (n._lastModTime) {
                n._lastModTime = time;
              }
            }
          }
        },
      },
      // This attribute is not part of the DOM but is quite helpful.
      // It returns the document with which a node is associated.  Usually
      // this is the ownerDocument. But ownerDocument is null for the
      // document object itself, so this is a handy way to get the document
      // regardless of the node type
      doc: {
        get: function () {
          return this.ownerDocument || this;
        },
      },
      // If the node has a nid (node id), then it is rooted in a document
      rooted: {
        get: function () {
          return !!this._nid;
        },
      },
      normalize: {
        value: function () {
          var next;
          for (var child = this.firstChild; child !== null; child = next) {
            next = child.nextSibling;
            if (child.normalize) {
              child.normalize();
            }
            if (child.nodeType !== Node.TEXT_NODE) {
              continue;
            }
            if (child.nodeValue === '') {
              this.removeChild(child);
              continue;
            }
            var prevChild = child.previousSibling;
            if (prevChild === null) {
              continue;
            } else if (prevChild.nodeType === Node.TEXT_NODE) {
              prevChild.appendData(child.nodeValue);
              this.removeChild(child);
            }
          }
        },
      },
      // Convert the children of a node to an HTML string.
      // This is used by the innerHTML getter
      // The serialization spec is at:
      // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#serializing-html-fragments
      //
      // The serialization logic is intentionally implemented in a separate
      // `NodeUtils` helper instead of the more obvious choice of a private
      // `_serializeOne()` method on the `Node.prototype` in order to avoid
      // the megamorphic `this._serializeOne` property access, which reduces
      // performance unnecessarily. If you need specialized behavior for a
      // certain subclass, you'll need to implement that in `NodeUtils`.
      // See https://github.com/fgnass/domino/pull/142 for more information.
      serialize: {
        value: function () {
          if (this._innerHTML) {
            return this._innerHTML;
          }
          var s = '';
          for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
            s += NodeUtils.serializeOne(kid, this);
          }
          return s;
        },
      },
      // Non-standard, but often useful for debugging.
      outerHTML: {
        get: function () {
          return NodeUtils.serializeOne(this, { nodeType: 0 });
        },
        set: utils.nyi,
      },
      // mirror node type properties in the prototype, so they are present
      // in instances of Node (and subclasses)
      ELEMENT_NODE: { value: ELEMENT_NODE },
      ATTRIBUTE_NODE: { value: ATTRIBUTE_NODE },
      TEXT_NODE: { value: TEXT_NODE },
      CDATA_SECTION_NODE: { value: CDATA_SECTION_NODE },
      ENTITY_REFERENCE_NODE: { value: ENTITY_REFERENCE_NODE },
      ENTITY_NODE: { value: ENTITY_NODE },
      PROCESSING_INSTRUCTION_NODE: { value: PROCESSING_INSTRUCTION_NODE },
      COMMENT_NODE: { value: COMMENT_NODE },
      DOCUMENT_NODE: { value: DOCUMENT_NODE },
      DOCUMENT_TYPE_NODE: { value: DOCUMENT_TYPE_NODE },
      DOCUMENT_FRAGMENT_NODE: { value: DOCUMENT_FRAGMENT_NODE },
      NOTATION_NODE: { value: NOTATION_NODE },
      DOCUMENT_POSITION_DISCONNECTED: { value: DOCUMENT_POSITION_DISCONNECTED },
      DOCUMENT_POSITION_PRECEDING: { value: DOCUMENT_POSITION_PRECEDING },
      DOCUMENT_POSITION_FOLLOWING: { value: DOCUMENT_POSITION_FOLLOWING },
      DOCUMENT_POSITION_CONTAINS: { value: DOCUMENT_POSITION_CONTAINS },
      DOCUMENT_POSITION_CONTAINED_BY: { value: DOCUMENT_POSITION_CONTAINED_BY },
      DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: { value: DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/NodeList.es6.js
var require_NodeList_es6 = __commonJS({
  'node_modules/@mixmark-io/domino/lib/NodeList.es6.js'(exports2, module2) {
    'use strict';
    module2.exports = class NodeList extends Array {
      constructor(a) {
        super((a && a.length) || 0);
        if (a) {
          for (var idx in a) {
            this[idx] = a[idx];
          }
        }
      }
      item(i) {
        return this[i] || null;
      }
    };
  },
});

// node_modules/@mixmark-io/domino/lib/NodeList.es5.js
var require_NodeList_es5 = __commonJS({
  'node_modules/@mixmark-io/domino/lib/NodeList.es5.js'(exports2, module2) {
    'use strict';
    function item(i) {
      return this[i] || null;
    }
    function NodeList(a) {
      if (!a) a = [];
      a.item = item;
      return a;
    }
    module2.exports = NodeList;
  },
});

// node_modules/@mixmark-io/domino/lib/NodeList.js
var require_NodeList = __commonJS({
  'node_modules/@mixmark-io/domino/lib/NodeList.js'(exports2, module2) {
    'use strict';
    var NodeList;
    try {
      NodeList = require_NodeList_es6();
    } catch (e) {
      NodeList = require_NodeList_es5();
    }
    module2.exports = NodeList;
  },
});

// node_modules/@mixmark-io/domino/lib/ContainerNode.js
var require_ContainerNode = __commonJS({
  'node_modules/@mixmark-io/domino/lib/ContainerNode.js'(exports2, module2) {
    'use strict';
    module2.exports = ContainerNode;
    var Node = require_Node();
    var NodeList = require_NodeList();
    function ContainerNode() {
      Node.call(this);
      this._firstChild = this._childNodes = null;
    }
    ContainerNode.prototype = Object.create(Node.prototype, {
      hasChildNodes: {
        value: function () {
          if (this._childNodes) {
            return this._childNodes.length > 0;
          }
          return this._firstChild !== null;
        },
      },
      childNodes: {
        get: function () {
          this._ensureChildNodes();
          return this._childNodes;
        },
      },
      firstChild: {
        get: function () {
          if (this._childNodes) {
            return this._childNodes.length === 0 ? null : this._childNodes[0];
          }
          return this._firstChild;
        },
      },
      lastChild: {
        get: function () {
          var kids = this._childNodes,
            first;
          if (kids) {
            return kids.length === 0 ? null : kids[kids.length - 1];
          }
          first = this._firstChild;
          if (first === null) {
            return null;
          }
          return first._previousSibling;
        },
      },
      _ensureChildNodes: {
        value: function () {
          if (this._childNodes) {
            return;
          }
          var first = this._firstChild,
            kid = first,
            childNodes = (this._childNodes = new NodeList());
          if (first)
            do {
              childNodes.push(kid);
              kid = kid._nextSibling;
            } while (kid !== first);
          this._firstChild = null;
        },
      },
      // Remove all of this node's children.  This is a minor
      // optimization that only calls modify() once.
      removeChildren: {
        value: function removeChildren() {
          var root = this.rooted ? this.ownerDocument : null,
            next = this.firstChild,
            kid;
          while (next !== null) {
            kid = next;
            next = kid.nextSibling;
            if (root) root.mutateRemove(kid);
            kid.parentNode = null;
          }
          if (this._childNodes) {
            this._childNodes.length = 0;
          } else {
            this._firstChild = null;
          }
          this.modify();
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/xmlnames.js
var require_xmlnames = __commonJS({
  'node_modules/@mixmark-io/domino/lib/xmlnames.js'(exports2) {
    'use strict';
    exports2.isValidName = isValidName;
    exports2.isValidQName = isValidQName;
    var simplename = /^[_:A-Za-z][-.:\w]+$/;
    var simpleqname = /^([_A-Za-z][-.\w]+|[_A-Za-z][-.\w]+:[_A-Za-z][-.\w]+)$/;
    var ncnamestartchars =
      '_A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD';
    var ncnamechars =
      '-._A-Za-z0-9\xB7\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0300-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD';
    var ncname = '[' + ncnamestartchars + '][' + ncnamechars + ']*';
    var namestartchars = ncnamestartchars + ':';
    var namechars = ncnamechars + ':';
    var name = new RegExp('^[' + namestartchars + '][' + namechars + ']*$');
    var qname = new RegExp('^(' + ncname + '|' + ncname + ':' + ncname + ')$');
    var hassurrogates = /[\uD800-\uDB7F\uDC00-\uDFFF]/;
    var surrogatechars = /[\uD800-\uDB7F\uDC00-\uDFFF]/g;
    var surrogatepairs = /[\uD800-\uDB7F][\uDC00-\uDFFF]/g;
    ncnamestartchars += '\uD800-\u{EFC00}-\uDFFF';
    ncnamechars += '\uD800-\u{EFC00}-\uDFFF';
    ncname = '[' + ncnamestartchars + '][' + ncnamechars + ']*';
    namestartchars = ncnamestartchars + ':';
    namechars = ncnamechars + ':';
    var surrogatename = new RegExp('^[' + namestartchars + '][' + namechars + ']*$');
    var surrogateqname = new RegExp('^(' + ncname + '|' + ncname + ':' + ncname + ')$');
    function isValidName(s) {
      if (simplename.test(s)) return true;
      if (name.test(s)) return true;
      if (!hassurrogates.test(s)) return false;
      if (!surrogatename.test(s)) return false;
      var chars = s.match(surrogatechars),
        pairs = s.match(surrogatepairs);
      return pairs !== null && 2 * pairs.length === chars.length;
    }
    function isValidQName(s) {
      if (simpleqname.test(s)) return true;
      if (qname.test(s)) return true;
      if (!hassurrogates.test(s)) return false;
      if (!surrogateqname.test(s)) return false;
      var chars = s.match(surrogatechars),
        pairs = s.match(surrogatepairs);
      return pairs !== null && 2 * pairs.length === chars.length;
    }
  },
});

// node_modules/@mixmark-io/domino/lib/attributes.js
var require_attributes = __commonJS({
  'node_modules/@mixmark-io/domino/lib/attributes.js'(exports2) {
    'use strict';
    var utils = require_utils2();
    exports2.property = function (attr) {
      if (Array.isArray(attr.type)) {
        var valid = /* @__PURE__ */ Object.create(null);
        attr.type.forEach(function (val) {
          valid[val.value || val] = val.alias || val;
        });
        var missingValueDefault = attr.missing;
        if (missingValueDefault === void 0) {
          missingValueDefault = null;
        }
        var invalidValueDefault = attr.invalid;
        if (invalidValueDefault === void 0) {
          invalidValueDefault = missingValueDefault;
        }
        return {
          get: function () {
            var v = this._getattr(attr.name);
            if (v === null) return missingValueDefault;
            v = valid[v.toLowerCase()];
            if (v !== void 0) return v;
            if (invalidValueDefault !== null) return invalidValueDefault;
            return v;
          },
          set: function (v) {
            this._setattr(attr.name, v);
          },
        };
      } else if (attr.type === Boolean) {
        return {
          get: function () {
            return this.hasAttribute(attr.name);
          },
          set: function (v) {
            if (v) {
              this._setattr(attr.name, '');
            } else {
              this.removeAttribute(attr.name);
            }
          },
        };
      } else if (
        attr.type === Number ||
        attr.type === 'long' ||
        attr.type === 'unsigned long' ||
        attr.type === 'limited unsigned long with fallback'
      ) {
        return numberPropDesc(attr);
      } else if (!attr.type || attr.type === String) {
        return {
          get: function () {
            return this._getattr(attr.name) || '';
          },
          set: function (v) {
            if (attr.treatNullAsEmptyString && v === null) {
              v = '';
            }
            this._setattr(attr.name, v);
          },
        };
      } else if (typeof attr.type === 'function') {
        return attr.type(attr.name, attr);
      }
      throw new Error('Invalid attribute definition');
    };
    function numberPropDesc(a) {
      var def;
      if (typeof a.default === 'function') {
        def = a.default;
      } else if (typeof a.default === 'number') {
        def = function () {
          return a.default;
        };
      } else {
        def = function () {
          utils.assert(false, typeof a.default);
        };
      }
      var unsigned_long = a.type === 'unsigned long';
      var signed_long = a.type === 'long';
      var unsigned_fallback = a.type === 'limited unsigned long with fallback';
      var min = a.min,
        max = a.max,
        setmin = a.setmin;
      if (min === void 0) {
        if (unsigned_long) min = 0;
        if (signed_long) min = -2147483648;
        if (unsigned_fallback) min = 1;
      }
      if (max === void 0) {
        if (unsigned_long || signed_long || unsigned_fallback) max = 2147483647;
      }
      return {
        get: function () {
          var v = this._getattr(a.name);
          var n = a.float ? parseFloat(v) : parseInt(v, 10);
          if (v === null || !isFinite(n) || (min !== void 0 && n < min) || (max !== void 0 && n > max)) {
            return def.call(this);
          }
          if (unsigned_long || signed_long || unsigned_fallback) {
            if (!/^[ \t\n\f\r]*[-+]?[0-9]/.test(v)) {
              return def.call(this);
            }
            n = n | 0;
          }
          return n;
        },
        set: function (v) {
          if (!a.float) {
            v = Math.floor(v);
          }
          if (setmin !== void 0 && v < setmin) {
            utils.IndexSizeError(a.name + ' set to ' + v);
          }
          if (unsigned_long) {
            v = v < 0 || v > 2147483647 ? def.call(this) : v | 0;
          } else if (unsigned_fallback) {
            v = v < 1 || v > 2147483647 ? def.call(this) : v | 0;
          } else if (signed_long) {
            v = v < -2147483648 || v > 2147483647 ? def.call(this) : v | 0;
          }
          this._setattr(a.name, String(v));
        },
      };
    }
    exports2.registerChangeHandler = function (c, name, handler2) {
      var p = c.prototype;
      if (!Object.prototype.hasOwnProperty.call(p, '_attributeChangeHandlers')) {
        p._attributeChangeHandlers = Object.create(p._attributeChangeHandlers || null);
      }
      p._attributeChangeHandlers[name] = handler2;
    };
  },
});

// node_modules/@mixmark-io/domino/lib/FilteredElementList.js
var require_FilteredElementList = __commonJS({
  'node_modules/@mixmark-io/domino/lib/FilteredElementList.js'(exports2, module2) {
    'use strict';
    module2.exports = FilteredElementList;
    var Node = require_Node();
    function FilteredElementList(root, filter) {
      this.root = root;
      this.filter = filter;
      this.lastModTime = root.lastModTime;
      this.done = false;
      this.cache = [];
      this.traverse();
    }
    FilteredElementList.prototype = Object.create(Object.prototype, {
      length: {
        get: function () {
          this.checkcache();
          if (!this.done) this.traverse();
          return this.cache.length;
        },
      },
      item: {
        value: function (n) {
          this.checkcache();
          if (!this.done && n >= this.cache.length) {
            this
              .traverse
              /*n*/
              ();
          }
          return this.cache[n];
        },
      },
      checkcache: {
        value: function () {
          if (this.lastModTime !== this.root.lastModTime) {
            for (var i = this.cache.length - 1; i >= 0; i--) {
              this[i] = void 0;
            }
            this.cache.length = 0;
            this.done = false;
            this.lastModTime = this.root.lastModTime;
          }
        },
      },
      // If n is specified, then traverse the tree until we've found the nth
      // item (or until we've found all items).  If n is not specified,
      // traverse until we've found all items.
      traverse: {
        value: function (n) {
          if (n !== void 0) n++;
          var elt;
          while ((elt = this.next()) !== null) {
            this[this.cache.length] = elt;
            this.cache.push(elt);
            if (n && this.cache.length === n) return;
          }
          this.done = true;
        },
      },
      // Return the next element under root that matches filter
      next: {
        value: function () {
          var start = this.cache.length === 0 ? this.root : this.cache[this.cache.length - 1];
          var elt;
          if (start.nodeType === Node.DOCUMENT_NODE) elt = start.documentElement;
          else elt = start.nextElement(this.root);
          while (elt) {
            if (this.filter(elt)) {
              return elt;
            }
            elt = elt.nextElement(this.root);
          }
          return null;
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/DOMTokenList.js
var require_DOMTokenList = __commonJS({
  'node_modules/@mixmark-io/domino/lib/DOMTokenList.js'(exports2, module2) {
    'use strict';
    var utils = require_utils2();
    module2.exports = DOMTokenList;
    function DOMTokenList(getter, setter) {
      this._getString = getter;
      this._setString = setter;
      this._length = 0;
      this._lastStringValue = '';
      this._update();
    }
    Object.defineProperties(DOMTokenList.prototype, {
      length: {
        get: function () {
          return this._length;
        },
      },
      item: {
        value: function (index) {
          var list = getList(this);
          if (index < 0 || index >= list.length) {
            return null;
          }
          return list[index];
        },
      },
      contains: {
        value: function (token) {
          token = String(token);
          var list = getList(this);
          return list.indexOf(token) > -1;
        },
      },
      add: {
        value: function () {
          var list = getList(this);
          for (var i = 0, len = arguments.length; i < len; i++) {
            var token = handleErrors(arguments[i]);
            if (list.indexOf(token) < 0) {
              list.push(token);
            }
          }
          this._update(list);
        },
      },
      remove: {
        value: function () {
          var list = getList(this);
          for (var i = 0, len = arguments.length; i < len; i++) {
            var token = handleErrors(arguments[i]);
            var index = list.indexOf(token);
            if (index > -1) {
              list.splice(index, 1);
            }
          }
          this._update(list);
        },
      },
      toggle: {
        value: function toggle(token, force) {
          token = handleErrors(token);
          if (this.contains(token)) {
            if (force === void 0 || force === false) {
              this.remove(token);
              return false;
            }
            return true;
          } else {
            if (force === void 0 || force === true) {
              this.add(token);
              return true;
            }
            return false;
          }
        },
      },
      replace: {
        value: function replace(token, newToken) {
          if (String(newToken) === '') {
            utils.SyntaxError();
          }
          token = handleErrors(token);
          newToken = handleErrors(newToken);
          var list = getList(this);
          var idx = list.indexOf(token);
          if (idx < 0) {
            return false;
          }
          var idx2 = list.indexOf(newToken);
          if (idx2 < 0) {
            list[idx] = newToken;
          } else {
            if (idx < idx2) {
              list[idx] = newToken;
              list.splice(idx2, 1);
            } else {
              list.splice(idx, 1);
            }
          }
          this._update(list);
          return true;
        },
      },
      toString: {
        value: function () {
          return this._getString();
        },
      },
      value: {
        get: function () {
          return this._getString();
        },
        set: function (v) {
          this._setString(v);
          this._update();
        },
      },
      // Called when the setter is called from outside this interface.
      _update: {
        value: function (list) {
          if (list) {
            fixIndex(this, list);
            this._setString(list.join(' ').trim());
          } else {
            fixIndex(this, getList(this));
          }
          this._lastStringValue = this._getString();
        },
      },
    });
    function fixIndex(clist, list) {
      var oldLength = clist._length;
      var i;
      clist._length = list.length;
      for (i = 0; i < list.length; i++) {
        clist[i] = list[i];
      }
      for (; i < oldLength; i++) {
        clist[i] = void 0;
      }
    }
    function handleErrors(token) {
      token = String(token);
      if (token === '') {
        utils.SyntaxError();
      }
      if (/[ \t\r\n\f]/.test(token)) {
        utils.InvalidCharacterError();
      }
      return token;
    }
    function toArray(clist) {
      var length = clist._length;
      var arr = Array(length);
      for (var i = 0; i < length; i++) {
        arr[i] = clist[i];
      }
      return arr;
    }
    function getList(clist) {
      var strProp = clist._getString();
      if (strProp === clist._lastStringValue) {
        return toArray(clist);
      }
      var str = strProp.replace(/(^[ \t\r\n\f]+)|([ \t\r\n\f]+$)/g, '');
      if (str === '') {
        return [];
      } else {
        var seen = /* @__PURE__ */ Object.create(null);
        return str.split(/[ \t\r\n\f]+/g).filter(function (n) {
          var key = '$' + n;
          if (seen[key]) {
            return false;
          }
          seen[key] = true;
          return true;
        });
      }
    }
  },
});

// node_modules/@mixmark-io/domino/lib/select.js
var require_select = __commonJS({
  'node_modules/@mixmark-io/domino/lib/select.js'(exports2, module2) {
    'use strict';
    var window2 = Object.create(null, {
      location: {
        get: function () {
          throw new Error('window.location is not supported.');
        },
      },
    });
    var compareDocumentPosition = function (a, b) {
      return a.compareDocumentPosition(b);
    };
    var order = function (a, b) {
      return compareDocumentPosition(a, b) & 2 ? 1 : -1;
    };
    var next = function (el) {
      while ((el = el.nextSibling) && el.nodeType !== 1);
      return el;
    };
    var prev = function (el) {
      while ((el = el.previousSibling) && el.nodeType !== 1);
      return el;
    };
    var child = function (el) {
      if ((el = el.firstChild)) {
        while (el.nodeType !== 1 && (el = el.nextSibling));
      }
      return el;
    };
    var lastChild = function (el) {
      if ((el = el.lastChild)) {
        while (el.nodeType !== 1 && (el = el.previousSibling));
      }
      return el;
    };
    var parentIsElement = function (n) {
      if (!n.parentNode) {
        return false;
      }
      var nodeType = n.parentNode.nodeType;
      return nodeType === 1 || nodeType === 9;
    };
    var unquote = function (str) {
      if (!str) return str;
      var ch = str[0];
      if (ch === '"' || ch === "'") {
        if (str[str.length - 1] === ch) {
          str = str.slice(1, -1);
        } else {
          str = str.slice(1);
        }
        return str.replace(rules.str_escape, function (s) {
          var m = /^\\(?:([0-9A-Fa-f]+)|([\r\n\f]+))/.exec(s);
          if (!m) {
            return s.slice(1);
          }
          if (m[2]) {
            return '';
          }
          var cp = parseInt(m[1], 16);
          return String.fromCodePoint
            ? String.fromCodePoint(cp)
            : // Not all JavaScript implementations have String.fromCodePoint yet.
              String.fromCharCode(cp);
        });
      } else if (rules.ident.test(str)) {
        return decodeid(str);
      } else {
        return str;
      }
    };
    var decodeid = function (str) {
      return str.replace(rules.escape, function (s) {
        var m = /^\\([0-9A-Fa-f]+)/.exec(s);
        if (!m) {
          return s[1];
        }
        var cp = parseInt(m[1], 16);
        return String.fromCodePoint
          ? String.fromCodePoint(cp)
          : // Not all JavaScript implementations have String.fromCodePoint yet.
            String.fromCharCode(cp);
      });
    };
    var indexOf = (function () {
      if (Array.prototype.indexOf) {
        return Array.prototype.indexOf;
      }
      return function (obj, item) {
        var i = this.length;
        while (i--) {
          if (this[i] === item) return i;
        }
        return -1;
      };
    })();
    var makeInside = function (start, end) {
      var regex2 = rules.inside.source.replace(/</g, start).replace(/>/g, end);
      return new RegExp(regex2);
    };
    var replace = function (regex2, name, val) {
      regex2 = regex2.source;
      regex2 = regex2.replace(name, val.source || val);
      return new RegExp(regex2);
    };
    var truncateUrl = function (url, num) {
      return url
        .replace(/^(?:\w+:\/\/|\/+)/, '')
        .replace(/(?:\/+|\/*#.*?)$/, '')
        .split('/', num)
        .join('/');
    };
    var parseNth = function (param_, test) {
      var param = param_.replace(/\s+/g, ''),
        cap;
      if (param === 'even') {
        param = '2n+0';
      } else if (param === 'odd') {
        param = '2n+1';
      } else if (param.indexOf('n') === -1) {
        param = '0n' + param;
      }
      cap = /^([+-])?(\d+)?n([+-])?(\d+)?$/.exec(param);
      return {
        group: cap[1] === '-' ? -(cap[2] || 1) : +(cap[2] || 1),
        offset: cap[4] ? (cap[3] === '-' ? -cap[4] : +cap[4]) : 0,
      };
    };
    var nth = function (param_, test, last) {
      var param = parseNth(param_),
        group = param.group,
        offset = param.offset,
        find2 = !last ? child : lastChild,
        advance = !last ? next : prev;
      return function (el) {
        if (!parentIsElement(el)) return;
        var rel = find2(el.parentNode),
          pos = 0;
        while (rel) {
          if (test(rel, el)) pos++;
          if (rel === el) {
            pos -= offset;
            return group && pos ? pos % group === 0 && pos < 0 === group < 0 : !pos;
          }
          rel = advance(rel);
        }
      };
    };
    var selectors = {
      '*': (function () {
        if (false) {
          return function (el) {
            if (el.nodeType === 1) return true;
          };
        }
        return function () {
          return true;
        };
      })(),
      type: function (type) {
        type = type.toLowerCase();
        return function (el) {
          return el.nodeName.toLowerCase() === type;
        };
      },
      attr: function (key, op, val, i) {
        op = operators[op];
        return function (el) {
          var attr;
          switch (key) {
            case 'for':
              attr = el.htmlFor;
              break;
            case 'class':
              attr = el.className;
              if (attr === '' && el.getAttribute('class') == null) {
                attr = null;
              }
              break;
            case 'href':
            case 'src':
              attr = el.getAttribute(key, 2);
              break;
            case 'title':
              attr = el.getAttribute('title') || null;
              break;
            // careful with attributes with special getter functions
            case 'id':
            case 'lang':
            case 'dir':
            case 'accessKey':
            case 'hidden':
            case 'tabIndex':
            case 'style':
              if (el.getAttribute) {
                attr = el.getAttribute(key);
                break;
              }
            /* falls through */
            default:
              if (el.hasAttribute && !el.hasAttribute(key)) {
                break;
              }
              attr = el[key] != null ? el[key] : el.getAttribute && el.getAttribute(key);
              break;
          }
          if (attr == null) return;
          attr = attr + '';
          if (i) {
            attr = attr.toLowerCase();
            val = val.toLowerCase();
          }
          return op(attr, val);
        };
      },
      ':first-child': function (el) {
        return !prev(el) && parentIsElement(el);
      },
      ':last-child': function (el) {
        return !next(el) && parentIsElement(el);
      },
      ':only-child': function (el) {
        return !prev(el) && !next(el) && parentIsElement(el);
      },
      ':nth-child': function (param, last) {
        return nth(
          param,
          function () {
            return true;
          },
          last,
        );
      },
      ':nth-last-child': function (param) {
        return selectors[':nth-child'](param, true);
      },
      ':root': function (el) {
        return el.ownerDocument.documentElement === el;
      },
      ':empty': function (el) {
        return !el.firstChild;
      },
      ':not': function (sel) {
        var test = compileGroup(sel);
        return function (el) {
          return !test(el);
        };
      },
      ':first-of-type': function (el) {
        if (!parentIsElement(el)) return;
        var type = el.nodeName;
        while ((el = prev(el))) {
          if (el.nodeName === type) return;
        }
        return true;
      },
      ':last-of-type': function (el) {
        if (!parentIsElement(el)) return;
        var type = el.nodeName;
        while ((el = next(el))) {
          if (el.nodeName === type) return;
        }
        return true;
      },
      ':only-of-type': function (el) {
        return selectors[':first-of-type'](el) && selectors[':last-of-type'](el);
      },
      ':nth-of-type': function (param, last) {
        return nth(
          param,
          function (rel, el) {
            return rel.nodeName === el.nodeName;
          },
          last,
        );
      },
      ':nth-last-of-type': function (param) {
        return selectors[':nth-of-type'](param, true);
      },
      ':checked': function (el) {
        return !!(el.checked || el.selected);
      },
      ':indeterminate': function (el) {
        return !selectors[':checked'](el);
      },
      ':enabled': function (el) {
        return !el.disabled && el.type !== 'hidden';
      },
      ':disabled': function (el) {
        return !!el.disabled;
      },
      ':target': function (el) {
        return el.id === window2.location.hash.substring(1);
      },
      ':focus': function (el) {
        return el === el.ownerDocument.activeElement;
      },
      ':is': function (sel) {
        return compileGroup(sel);
      },
      // :matches is an older name for :is; see
      // https://github.com/w3c/csswg-drafts/issues/3258
      ':matches': function (sel) {
        return selectors[':is'](sel);
      },
      ':nth-match': function (param, last) {
        var args = param.split(/\s*,\s*/),
          arg = args.shift(),
          test = compileGroup(args.join(','));
        return nth(arg, test, last);
      },
      ':nth-last-match': function (param) {
        return selectors[':nth-match'](param, true);
      },
      ':links-here': function (el) {
        return el + '' === window2.location + '';
      },
      ':lang': function (param) {
        return function (el) {
          while (el) {
            if (el.lang) return el.lang.indexOf(param) === 0;
            el = el.parentNode;
          }
        };
      },
      ':dir': function (param) {
        return function (el) {
          while (el) {
            if (el.dir) return el.dir === param;
            el = el.parentNode;
          }
        };
      },
      ':scope': function (el, con) {
        var context = con || el.ownerDocument;
        if (context.nodeType === 9) {
          return el === context.documentElement;
        }
        return el === context;
      },
      ':any-link': function (el) {
        return typeof el.href === 'string';
      },
      ':local-link': function (el) {
        if (el.nodeName) {
          return el.href && el.host === window2.location.host;
        }
        var param = +el + 1;
        return function (el2) {
          if (!el2.href) return;
          var url = window2.location + '',
            href = el2 + '';
          return truncateUrl(url, param) === truncateUrl(href, param);
        };
      },
      ':default': function (el) {
        return !!el.defaultSelected;
      },
      ':valid': function (el) {
        return el.willValidate || (el.validity && el.validity.valid);
      },
      ':invalid': function (el) {
        return !selectors[':valid'](el);
      },
      ':in-range': function (el) {
        return el.value > el.min && el.value <= el.max;
      },
      ':out-of-range': function (el) {
        return !selectors[':in-range'](el);
      },
      ':required': function (el) {
        return !!el.required;
      },
      ':optional': function (el) {
        return !el.required;
      },
      ':read-only': function (el) {
        if (el.readOnly) return true;
        var attr = el.getAttribute('contenteditable'),
          prop = el.contentEditable,
          name = el.nodeName.toLowerCase();
        name = name !== 'input' && name !== 'textarea';
        return (name || el.disabled) && attr == null && prop !== 'true';
      },
      ':read-write': function (el) {
        return !selectors[':read-only'](el);
      },
      ':hover': function () {
        throw new Error(':hover is not supported.');
      },
      ':active': function () {
        throw new Error(':active is not supported.');
      },
      ':link': function () {
        throw new Error(':link is not supported.');
      },
      ':visited': function () {
        throw new Error(':visited is not supported.');
      },
      ':column': function () {
        throw new Error(':column is not supported.');
      },
      ':nth-column': function () {
        throw new Error(':nth-column is not supported.');
      },
      ':nth-last-column': function () {
        throw new Error(':nth-last-column is not supported.');
      },
      ':current': function () {
        throw new Error(':current is not supported.');
      },
      ':past': function () {
        throw new Error(':past is not supported.');
      },
      ':future': function () {
        throw new Error(':future is not supported.');
      },
      // Non-standard, for compatibility purposes.
      ':contains': function (param) {
        return function (el) {
          var text = el.innerText || el.textContent || el.value || '';
          return text.indexOf(param) !== -1;
        };
      },
      ':has': function (param) {
        return function (el) {
          return find(param, el).length > 0;
        };
      },
      // Potentially add more pseudo selectors for
      // compatibility with sizzle and most other
      // selector engines (?).
    };
    var operators = {
      '-': function () {
        return true;
      },
      '=': function (attr, val) {
        return attr === val;
      },
      '*=': function (attr, val) {
        return attr.indexOf(val) !== -1;
      },
      '~=': function (attr, val) {
        var i, s, f, l;
        for (s = 0; true; s = i + 1) {
          i = attr.indexOf(val, s);
          if (i === -1) return false;
          f = attr[i - 1];
          l = attr[i + val.length];
          if ((!f || f === ' ') && (!l || l === ' ')) return true;
        }
      },
      '|=': function (attr, val) {
        var i = attr.indexOf(val),
          l;
        if (i !== 0) return;
        l = attr[i + val.length];
        return l === '-' || !l;
      },
      '^=': function (attr, val) {
        return attr.indexOf(val) === 0;
      },
      '$=': function (attr, val) {
        var i = attr.lastIndexOf(val);
        return i !== -1 && i + val.length === attr.length;
      },
      // non-standard
      '!=': function (attr, val) {
        return attr !== val;
      },
    };
    var combinators = {
      ' ': function (test) {
        return function (el) {
          while ((el = el.parentNode)) {
            if (test(el)) return el;
          }
        };
      },
      '>': function (test) {
        return function (el) {
          if ((el = el.parentNode)) {
            return test(el) && el;
          }
        };
      },
      '+': function (test) {
        return function (el) {
          if ((el = prev(el))) {
            return test(el) && el;
          }
        };
      },
      '~': function (test) {
        return function (el) {
          while ((el = prev(el))) {
            if (test(el)) return el;
          }
        };
      },
      noop: function (test) {
        return function (el) {
          return test(el) && el;
        };
      },
      ref: function (test, name) {
        var node;
        function ref(el) {
          var doc = el.ownerDocument,
            nodes = doc.getElementsByTagName('*'),
            i = nodes.length;
          while (i--) {
            node = nodes[i];
            if (ref.test(el)) {
              node = null;
              return true;
            }
          }
          node = null;
        }
        ref.combinator = function (el) {
          if (!node || !node.getAttribute) return;
          var attr = node.getAttribute(name) || '';
          if (attr[0] === '#') attr = attr.substring(1);
          if (attr === el.id && test(node)) {
            return node;
          }
        };
        return ref;
      },
    };
    var rules = {
      escape: /\\(?:[^0-9A-Fa-f\r\n]|[0-9A-Fa-f]{1,6}[\r\n\t ]?)/g,
      str_escape: /(escape)|\\(\n|\r\n?|\f)/g,
      nonascii: /[\u00A0-\uFFFF]/,
      cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,
      qname: /^ *(cssid|\*)/,
      simple: /^(?:([.#]cssid)|pseudo|attr)/,
      ref: /^ *\/(cssid)\/ */,
      combinator: /^(?: +([^ \w*.#\\]) +|( )+|([^ \w*.#\\]))(?! *$)/,
      attr: /^\[(cssid)(?:([^\w]?=)(inside))?\]/,
      pseudo: /^(:cssid)(?:\((inside)\))?/,
      inside: /(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|<[^"'>]*>|\\["'>]|[^"'>])*/,
      ident: /^(cssid)$/,
    };
    rules.cssid = replace(rules.cssid, 'nonascii', rules.nonascii);
    rules.cssid = replace(rules.cssid, 'escape', rules.escape);
    rules.qname = replace(rules.qname, 'cssid', rules.cssid);
    rules.simple = replace(rules.simple, 'cssid', rules.cssid);
    rules.ref = replace(rules.ref, 'cssid', rules.cssid);
    rules.attr = replace(rules.attr, 'cssid', rules.cssid);
    rules.pseudo = replace(rules.pseudo, 'cssid', rules.cssid);
    rules.inside = replace(rules.inside, `[^"'>]*`, rules.inside);
    rules.attr = replace(rules.attr, 'inside', makeInside('\\[', '\\]'));
    rules.pseudo = replace(rules.pseudo, 'inside', makeInside('\\(', '\\)'));
    rules.simple = replace(rules.simple, 'pseudo', rules.pseudo);
    rules.simple = replace(rules.simple, 'attr', rules.attr);
    rules.ident = replace(rules.ident, 'cssid', rules.cssid);
    rules.str_escape = replace(rules.str_escape, 'escape', rules.escape);
    var compile = function (sel_) {
      var sel = sel_.replace(/^\s+|\s+$/g, ''),
        test,
        filter = [],
        buff = [],
        subject,
        qname,
        cap,
        op,
        ref;
      while (sel) {
        if ((cap = rules.qname.exec(sel))) {
          sel = sel.substring(cap[0].length);
          qname = decodeid(cap[1]);
          buff.push(tok(qname, true));
        } else if ((cap = rules.simple.exec(sel))) {
          sel = sel.substring(cap[0].length);
          qname = '*';
          buff.push(tok(qname, true));
          buff.push(tok(cap));
        } else {
          throw new SyntaxError('Invalid selector.');
        }
        while ((cap = rules.simple.exec(sel))) {
          sel = sel.substring(cap[0].length);
          buff.push(tok(cap));
        }
        if (sel[0] === '!') {
          sel = sel.substring(1);
          subject = makeSubject();
          subject.qname = qname;
          buff.push(subject.simple);
        }
        if ((cap = rules.ref.exec(sel))) {
          sel = sel.substring(cap[0].length);
          ref = combinators.ref(makeSimple(buff), decodeid(cap[1]));
          filter.push(ref.combinator);
          buff = [];
          continue;
        }
        if ((cap = rules.combinator.exec(sel))) {
          sel = sel.substring(cap[0].length);
          op = cap[1] || cap[2] || cap[3];
          if (op === ',') {
            filter.push(combinators.noop(makeSimple(buff)));
            break;
          }
        } else {
          op = 'noop';
        }
        if (!combinators[op]) {
          throw new SyntaxError('Bad combinator.');
        }
        filter.push(combinators[op](makeSimple(buff)));
        buff = [];
      }
      test = makeTest(filter);
      test.qname = qname;
      test.sel = sel;
      if (subject) {
        subject.lname = test.qname;
        subject.test = test;
        subject.qname = subject.qname;
        subject.sel = test.sel;
        test = subject;
      }
      if (ref) {
        ref.test = test;
        ref.qname = test.qname;
        ref.sel = test.sel;
        test = ref;
      }
      return test;
    };
    var tok = function (cap, qname) {
      if (qname) {
        return cap === '*' ? selectors['*'] : selectors.type(cap);
      }
      if (cap[1]) {
        return cap[1][0] === '.'
          ? selectors.attr('class', '~=', decodeid(cap[1].substring(1)), false)
          : selectors.attr('id', '=', decodeid(cap[1].substring(1)), false);
      }
      if (cap[2]) {
        return cap[3] ? selectors[decodeid(cap[2])](unquote(cap[3])) : selectors[decodeid(cap[2])];
      }
      if (cap[4]) {
        var value = cap[6];
        var i = /["'\s]\s*I$/i.test(value);
        if (i) {
          value = value.replace(/\s*I$/i, '');
        }
        return selectors.attr(decodeid(cap[4]), cap[5] || '-', unquote(value), i);
      }
      throw new SyntaxError('Unknown Selector.');
    };
    var makeSimple = function (func) {
      var l = func.length,
        i;
      if (l < 2) return func[0];
      return function (el) {
        if (!el) return;
        for (i = 0; i < l; i++) {
          if (!func[i](el)) return;
        }
        return true;
      };
    };
    var makeTest = function (func) {
      if (func.length < 2) {
        return function (el) {
          return !!func[0](el);
        };
      }
      return function (el) {
        var i = func.length;
        while (i--) {
          if (!(el = func[i](el))) return;
        }
        return true;
      };
    };
    var makeSubject = function () {
      var target;
      function subject(el) {
        var node = el.ownerDocument,
          scope = node.getElementsByTagName(subject.lname),
          i = scope.length;
        while (i--) {
          if (subject.test(scope[i]) && target === el) {
            target = null;
            return true;
          }
        }
        target = null;
      }
      subject.simple = function (el) {
        target = el;
        return true;
      };
      return subject;
    };
    var compileGroup = function (sel) {
      var test = compile(sel),
        tests = [test];
      while (test.sel) {
        test = compile(test.sel);
        tests.push(test);
      }
      if (tests.length < 2) return test;
      return function (el) {
        var l = tests.length,
          i = 0;
        for (; i < l; i++) {
          if (tests[i](el)) return true;
        }
      };
    };
    var find = function (sel, node) {
      var results = [],
        test = compile(sel),
        scope = node.getElementsByTagName(test.qname),
        i = 0,
        el;
      while ((el = scope[i++])) {
        if (test(el)) results.push(el);
      }
      if (test.sel) {
        while (test.sel) {
          test = compile(test.sel);
          scope = node.getElementsByTagName(test.qname);
          i = 0;
          while ((el = scope[i++])) {
            if (test(el) && indexOf.call(results, el) === -1) {
              results.push(el);
            }
          }
        }
        results.sort(order);
      }
      return results;
    };
    module2.exports = exports2 = function (sel, context) {
      var id, r;
      if (context.nodeType !== 11 && sel.indexOf(' ') === -1) {
        if (sel[0] === '#' && context.rooted && /^#[A-Z_][-A-Z0-9_]*$/i.test(sel)) {
          if (context.doc._hasMultipleElementsWithId) {
            id = sel.substring(1);
            if (!context.doc._hasMultipleElementsWithId(id)) {
              r = context.doc.getElementById(id);
              return r ? [r] : [];
            }
          }
        }
        if (sel[0] === '.' && /^\.\w+$/.test(sel)) {
          return context.getElementsByClassName(sel.substring(1));
        }
        if (/^\w+$/.test(sel)) {
          return context.getElementsByTagName(sel);
        }
      }
      return find(sel, context);
    };
    exports2.selectors = selectors;
    exports2.operators = operators;
    exports2.combinators = combinators;
    exports2.matches = function (el, sel) {
      var test = { sel };
      do {
        test = compile(test.sel);
        if (test(el)) {
          return true;
        }
      } while (test.sel);
      return false;
    };
  },
});

// node_modules/@mixmark-io/domino/lib/ChildNode.js
var require_ChildNode = __commonJS({
  'node_modules/@mixmark-io/domino/lib/ChildNode.js'(exports2, module2) {
    'use strict';
    var Node = require_Node();
    var LinkedList = require_LinkedList();
    var createDocumentFragmentFromArguments = function (document, args) {
      var docFrag = document.createDocumentFragment();
      for (var i = 0; i < args.length; i++) {
        var argItem = args[i];
        var isNode = argItem instanceof Node;
        docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
      }
      return docFrag;
    };
    var ChildNode = {
      // Inserts a set of Node or String objects in the children list of this
      // ChildNode's parent, just after this ChildNode.  String objects are
      // inserted as the equivalent Text nodes.
      after: {
        value: function after() {
          var argArr = Array.prototype.slice.call(arguments);
          var parentNode = this.parentNode,
            nextSibling = this.nextSibling;
          if (parentNode === null) {
            return;
          }
          while (
            nextSibling &&
            argArr.some(function (v) {
              return v === nextSibling;
            })
          )
            nextSibling = nextSibling.nextSibling;
          var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
          parentNode.insertBefore(docFrag, nextSibling);
        },
      },
      // Inserts a set of Node or String objects in the children list of this
      // ChildNode's parent, just before this ChildNode.  String objects are
      // inserted as the equivalent Text nodes.
      before: {
        value: function before() {
          var argArr = Array.prototype.slice.call(arguments);
          var parentNode = this.parentNode,
            prevSibling = this.previousSibling;
          if (parentNode === null) {
            return;
          }
          while (
            prevSibling &&
            argArr.some(function (v) {
              return v === prevSibling;
            })
          )
            prevSibling = prevSibling.previousSibling;
          var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
          var nextSibling = prevSibling ? prevSibling.nextSibling : parentNode.firstChild;
          parentNode.insertBefore(docFrag, nextSibling);
        },
      },
      // Remove this node from its parent
      remove: {
        value: function remove() {
          if (this.parentNode === null) return;
          if (this.doc) {
            this.doc._preremoveNodeIterators(this);
            if (this.rooted) {
              this.doc.mutateRemove(this);
            }
          }
          this._remove();
          this.parentNode = null;
        },
      },
      // Remove this node w/o uprooting or sending mutation events
      // (But do update the structure id for all ancestors)
      _remove: {
        value: function _remove() {
          var parent = this.parentNode;
          if (parent === null) return;
          if (parent._childNodes) {
            parent._childNodes.splice(this.index, 1);
          } else if (parent._firstChild === this) {
            if (this._nextSibling === this) {
              parent._firstChild = null;
            } else {
              parent._firstChild = this._nextSibling;
            }
          }
          LinkedList.remove(this);
          parent.modify();
        },
      },
      // Replace this node with the nodes or strings provided as arguments.
      replaceWith: {
        value: function replaceWith() {
          var argArr = Array.prototype.slice.call(arguments);
          var parentNode = this.parentNode,
            nextSibling = this.nextSibling;
          if (parentNode === null) {
            return;
          }
          while (
            nextSibling &&
            argArr.some(function (v) {
              return v === nextSibling;
            })
          )
            nextSibling = nextSibling.nextSibling;
          var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
          if (this.parentNode === parentNode) {
            parentNode.replaceChild(docFrag, this);
          } else {
            parentNode.insertBefore(docFrag, nextSibling);
          }
        },
      },
    };
    module2.exports = ChildNode;
  },
});

// node_modules/@mixmark-io/domino/lib/NonDocumentTypeChildNode.js
var require_NonDocumentTypeChildNode = __commonJS({
  'node_modules/@mixmark-io/domino/lib/NonDocumentTypeChildNode.js'(exports2, module2) {
    'use strict';
    var Node = require_Node();
    var NonDocumentTypeChildNode = {
      nextElementSibling: {
        get: function () {
          if (this.parentNode) {
            for (var kid = this.nextSibling; kid !== null; kid = kid.nextSibling) {
              if (kid.nodeType === Node.ELEMENT_NODE) return kid;
            }
          }
          return null;
        },
      },
      previousElementSibling: {
        get: function () {
          if (this.parentNode) {
            for (var kid = this.previousSibling; kid !== null; kid = kid.previousSibling) {
              if (kid.nodeType === Node.ELEMENT_NODE) return kid;
            }
          }
          return null;
        },
      },
    };
    module2.exports = NonDocumentTypeChildNode;
  },
});

// node_modules/@mixmark-io/domino/lib/NamedNodeMap.js
var require_NamedNodeMap = __commonJS({
  'node_modules/@mixmark-io/domino/lib/NamedNodeMap.js'(exports2, module2) {
    'use strict';
    module2.exports = NamedNodeMap;
    var utils = require_utils2();
    function NamedNodeMap(element) {
      this.element = element;
    }
    Object.defineProperties(NamedNodeMap.prototype, {
      length: { get: utils.shouldOverride },
      item: { value: utils.shouldOverride },
      getNamedItem: {
        value: function getNamedItem(qualifiedName) {
          return this.element.getAttributeNode(qualifiedName);
        },
      },
      getNamedItemNS: {
        value: function getNamedItemNS(namespace, localName) {
          return this.element.getAttributeNodeNS(namespace, localName);
        },
      },
      setNamedItem: { value: utils.nyi },
      setNamedItemNS: { value: utils.nyi },
      removeNamedItem: {
        value: function removeNamedItem(qualifiedName) {
          var attr = this.element.getAttributeNode(qualifiedName);
          if (attr) {
            this.element.removeAttribute(qualifiedName);
            return attr;
          }
          utils.NotFoundError();
        },
      },
      removeNamedItemNS: {
        value: function removeNamedItemNS(ns, lname) {
          var attr = this.element.getAttributeNodeNS(ns, lname);
          if (attr) {
            this.element.removeAttributeNS(ns, lname);
            return attr;
          }
          utils.NotFoundError();
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/Element.js
var require_Element = __commonJS({
  'node_modules/@mixmark-io/domino/lib/Element.js'(exports2, module2) {
    'use strict';
    module2.exports = Element;
    var xml = require_xmlnames();
    var utils = require_utils2();
    var NAMESPACE = utils.NAMESPACE;
    var attributes = require_attributes();
    var Node = require_Node();
    var NodeList = require_NodeList();
    var NodeUtils = require_NodeUtils();
    var FilteredElementList = require_FilteredElementList();
    var DOMException = require_DOMException();
    var DOMTokenList = require_DOMTokenList();
    var select = require_select();
    var ContainerNode = require_ContainerNode();
    var ChildNode = require_ChildNode();
    var NonDocumentTypeChildNode = require_NonDocumentTypeChildNode();
    var NamedNodeMap = require_NamedNodeMap();
    var uppercaseCache = /* @__PURE__ */ Object.create(null);
    function Element(doc, localName, namespaceURI, prefix) {
      ContainerNode.call(this);
      this.nodeType = Node.ELEMENT_NODE;
      this.ownerDocument = doc;
      this.localName = localName;
      this.namespaceURI = namespaceURI;
      this.prefix = prefix;
      this._tagName = void 0;
      this._attrsByQName = /* @__PURE__ */ Object.create(null);
      this._attrsByLName = /* @__PURE__ */ Object.create(null);
      this._attrKeys = [];
    }
    function recursiveGetText(node, a) {
      if (node.nodeType === Node.TEXT_NODE) {
        a.push(node._data);
      } else {
        for (var i = 0, n = node.childNodes.length; i < n; i++) recursiveGetText(node.childNodes[i], a);
      }
    }
    Element.prototype = Object.create(ContainerNode.prototype, {
      isHTML: {
        get: function isHTML() {
          return this.namespaceURI === NAMESPACE.HTML && this.ownerDocument.isHTML;
        },
      },
      tagName: {
        get: function tagName() {
          if (this._tagName === void 0) {
            var tn;
            if (this.prefix === null) {
              tn = this.localName;
            } else {
              tn = this.prefix + ':' + this.localName;
            }
            if (this.isHTML) {
              var up = uppercaseCache[tn];
              if (!up) {
                uppercaseCache[tn] = up = utils.toASCIIUpperCase(tn);
              }
              tn = up;
            }
            this._tagName = tn;
          }
          return this._tagName;
        },
      },
      nodeName: {
        get: function () {
          return this.tagName;
        },
      },
      nodeValue: {
        get: function () {
          return null;
        },
        set: function () {},
      },
      textContent: {
        get: function () {
          var strings = [];
          recursiveGetText(this, strings);
          return strings.join('');
        },
        set: function (newtext) {
          this.removeChildren();
          if (newtext !== null && newtext !== void 0 && newtext !== '') {
            this._appendChild(this.ownerDocument.createTextNode(newtext));
          }
        },
      },
      innerText: {
        get: function () {
          var strings = [];
          recursiveGetText(this, strings);
          return strings
            .join('')
            .replace(/[ \t\n\f\r]+/g, ' ')
            .trim();
        },
        set: function (newtext) {
          this.removeChildren();
          if (newtext !== null && newtext !== void 0 && newtext !== '') {
            this._appendChild(this.ownerDocument.createTextNode(newtext));
          }
        },
      },
      innerHTML: {
        get: function () {
          return this.serialize();
        },
        set: utils.nyi,
      },
      outerHTML: {
        get: function () {
          return NodeUtils.serializeOne(this, { nodeType: 0 });
        },
        set: function (v) {
          var document = this.ownerDocument;
          var parent = this.parentNode;
          if (parent === null) {
            return;
          }
          if (parent.nodeType === Node.DOCUMENT_NODE) {
            utils.NoModificationAllowedError();
          }
          if (parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            parent = parent.ownerDocument.createElement('body');
          }
          var parser = document.implementation.mozHTMLParser(document._address, parent);
          parser.parse(v === null ? '' : String(v), true);
          this.replaceWith(parser._asDocumentFragment());
        },
      },
      _insertAdjacent: {
        value: function _insertAdjacent(position, node) {
          var first = false;
          switch (position) {
            case 'beforebegin':
              first = true;
            /* falls through */
            case 'afterend':
              var parent = this.parentNode;
              if (parent === null) {
                return null;
              }
              return parent.insertBefore(node, first ? this : this.nextSibling);
            case 'afterbegin':
              first = true;
            /* falls through */
            case 'beforeend':
              return this.insertBefore(node, first ? this.firstChild : null);
            default:
              return utils.SyntaxError();
          }
        },
      },
      insertAdjacentElement: {
        value: function insertAdjacentElement(position, element) {
          if (element.nodeType !== Node.ELEMENT_NODE) {
            throw new TypeError('not an element');
          }
          position = utils.toASCIILowerCase(String(position));
          return this._insertAdjacent(position, element);
        },
      },
      insertAdjacentText: {
        value: function insertAdjacentText(position, data) {
          var textNode = this.ownerDocument.createTextNode(data);
          position = utils.toASCIILowerCase(String(position));
          this._insertAdjacent(position, textNode);
        },
      },
      insertAdjacentHTML: {
        value: function insertAdjacentHTML(position, text) {
          position = utils.toASCIILowerCase(String(position));
          text = String(text);
          var context;
          switch (position) {
            case 'beforebegin':
            case 'afterend':
              context = this.parentNode;
              if (context === null || context.nodeType === Node.DOCUMENT_NODE) {
                utils.NoModificationAllowedError();
              }
              break;
            case 'afterbegin':
            case 'beforeend':
              context = this;
              break;
            default:
              utils.SyntaxError();
          }
          if (
            !(context instanceof Element) ||
            (context.ownerDocument.isHTML && context.localName === 'html' && context.namespaceURI === NAMESPACE.HTML)
          ) {
            context = context.ownerDocument.createElementNS(NAMESPACE.HTML, 'body');
          }
          var parser = this.ownerDocument.implementation.mozHTMLParser(this.ownerDocument._address, context);
          parser.parse(text, true);
          this._insertAdjacent(position, parser._asDocumentFragment());
        },
      },
      children: {
        get: function () {
          if (!this._children) {
            this._children = new ChildrenCollection(this);
          }
          return this._children;
        },
      },
      attributes: {
        get: function () {
          if (!this._attributes) {
            this._attributes = new AttributesArray(this);
          }
          return this._attributes;
        },
      },
      firstElementChild: {
        get: function () {
          for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
            if (kid.nodeType === Node.ELEMENT_NODE) return kid;
          }
          return null;
        },
      },
      lastElementChild: {
        get: function () {
          for (var kid = this.lastChild; kid !== null; kid = kid.previousSibling) {
            if (kid.nodeType === Node.ELEMENT_NODE) return kid;
          }
          return null;
        },
      },
      childElementCount: {
        get: function () {
          return this.children.length;
        },
      },
      // Return the next element, in source order, after this one or
      // null if there are no more.  If root element is specified,
      // then don't traverse beyond its subtree.
      //
      // This is not a DOM method, but is convenient for
      // lazy traversals of the tree.
      nextElement: {
        value: function (root) {
          if (!root) root = this.ownerDocument.documentElement;
          var next = this.firstElementChild;
          if (!next) {
            if (this === root) return null;
            next = this.nextElementSibling;
          }
          if (next) return next;
          for (var parent = this.parentElement; parent && parent !== root; parent = parent.parentElement) {
            next = parent.nextElementSibling;
            if (next) return next;
          }
          return null;
        },
      },
      // XXX:
      // Tests are currently failing for this function.
      // Awaiting resolution of:
      // http://lists.w3.org/Archives/Public/www-dom/2011JulSep/0016.html
      getElementsByTagName: {
        value: function getElementsByTagName(lname) {
          var filter;
          if (!lname) return new NodeList();
          if (lname === '*')
            filter = function () {
              return true;
            };
          else if (this.isHTML) filter = htmlLocalNameElementFilter(lname);
          else filter = localNameElementFilter(lname);
          return new FilteredElementList(this, filter);
        },
      },
      getElementsByTagNameNS: {
        value: function getElementsByTagNameNS(ns, lname) {
          var filter;
          if (ns === '*' && lname === '*')
            filter = function () {
              return true;
            };
          else if (ns === '*') filter = localNameElementFilter(lname);
          else if (lname === '*') filter = namespaceElementFilter(ns);
          else filter = namespaceLocalNameElementFilter(ns, lname);
          return new FilteredElementList(this, filter);
        },
      },
      getElementsByClassName: {
        value: function getElementsByClassName(names) {
          names = String(names).trim();
          if (names === '') {
            var result = new NodeList();
            return result;
          }
          names = names.split(/[ \t\r\n\f]+/);
          return new FilteredElementList(this, classNamesElementFilter(names));
        },
      },
      getElementsByName: {
        value: function getElementsByName(name) {
          return new FilteredElementList(this, elementNameFilter(String(name)));
        },
      },
      // Utility methods used by the public API methods above
      clone: {
        value: function clone() {
          var e;
          if (this.namespaceURI !== NAMESPACE.HTML || this.prefix || !this.ownerDocument.isHTML) {
            e = this.ownerDocument.createElementNS(
              this.namespaceURI,
              this.prefix !== null ? this.prefix + ':' + this.localName : this.localName,
            );
          } else {
            e = this.ownerDocument.createElement(this.localName);
          }
          for (var i = 0, n = this._attrKeys.length; i < n; i++) {
            var lname = this._attrKeys[i];
            var a = this._attrsByLName[lname];
            var b = a.cloneNode();
            b._setOwnerElement(e);
            e._attrsByLName[lname] = b;
            e._addQName(b);
          }
          e._attrKeys = this._attrKeys.concat();
          return e;
        },
      },
      isEqual: {
        value: function isEqual(that) {
          if (
            this.localName !== that.localName ||
            this.namespaceURI !== that.namespaceURI ||
            this.prefix !== that.prefix ||
            this._numattrs !== that._numattrs
          )
            return false;
          for (var i = 0, n = this._numattrs; i < n; i++) {
            var a = this._attr(i);
            if (!that.hasAttributeNS(a.namespaceURI, a.localName)) return false;
            if (that.getAttributeNS(a.namespaceURI, a.localName) !== a.value) return false;
          }
          return true;
        },
      },
      // This is the 'locate a namespace prefix' algorithm from the
      // DOM specification.  It is used by Node.lookupPrefix()
      // (Be sure to compare DOM3 and DOM4 versions of spec.)
      _lookupNamespacePrefix: {
        value: function _lookupNamespacePrefix(ns, originalElement) {
          if (
            this.namespaceURI &&
            this.namespaceURI === ns &&
            this.prefix !== null &&
            originalElement.lookupNamespaceURI(this.prefix) === ns
          ) {
            return this.prefix;
          }
          for (var i = 0, n = this._numattrs; i < n; i++) {
            var a = this._attr(i);
            if (a.prefix === 'xmlns' && a.value === ns && originalElement.lookupNamespaceURI(a.localName) === ns) {
              return a.localName;
            }
          }
          var parent = this.parentElement;
          return parent ? parent._lookupNamespacePrefix(ns, originalElement) : null;
        },
      },
      // This is the 'locate a namespace' algorithm for Element nodes
      // from the DOM Core spec.  It is used by Node#lookupNamespaceURI()
      lookupNamespaceURI: {
        value: function lookupNamespaceURI(prefix) {
          if (prefix === '' || prefix === void 0) {
            prefix = null;
          }
          if (this.namespaceURI !== null && this.prefix === prefix) return this.namespaceURI;
          for (var i = 0, n = this._numattrs; i < n; i++) {
            var a = this._attr(i);
            if (a.namespaceURI === NAMESPACE.XMLNS) {
              if (
                (a.prefix === 'xmlns' && a.localName === prefix) ||
                (prefix === null && a.prefix === null && a.localName === 'xmlns')
              ) {
                return a.value || null;
              }
            }
          }
          var parent = this.parentElement;
          return parent ? parent.lookupNamespaceURI(prefix) : null;
        },
      },
      //
      // Attribute handling methods and utilities
      //
      /*
       * Attributes in the DOM are tricky:
       *
       * - there are the 8 basic get/set/has/removeAttribute{NS} methods
       *
       * - but many HTML attributes are also 'reflected' through IDL
       *   attributes which means that they can be queried and set through
       *   regular properties of the element.  There is just one attribute
       *   value, but two ways to get and set it.
       *
       * - Different HTML element types have different sets of reflected
         attributes.
       *
       * - attributes can also be queried and set through the .attributes
       *   property of an element.  This property behaves like an array of
       *   Attr objects.  The value property of each Attr is writeable, so
       *   this is a third way to read and write attributes.
       *
       * - for efficiency, we really want to store attributes in some kind
       *   of name->attr map.  But the attributes[] array is an array, not a
       *   map, which is kind of unnatural.
       *
       * - When using namespaces and prefixes, and mixing the NS methods
       *   with the non-NS methods, it is apparently actually possible for
       *   an attributes[] array to have more than one attribute with the
       *   same qualified name.  And certain methods must operate on only
       *   the first attribute with such a name.  So for these methods, an
       *   inefficient array-like data structure would be easier to
       *   implement.
       *
       * - The attributes[] array is live, not a snapshot, so changes to the
       *   attributes must be immediately visible through existing arrays.
       *
       * - When attributes are queried and set through IDL properties
       *   (instead of the get/setAttributes() method or the attributes[]
       *   array) they may be subject to type conversions, URL
       *   normalization, etc., so some extra processing is required in that
       *   case.
       *
       * - But access through IDL properties is probably the most common
       *   case, so we'd like that to be as fast as possible.
       *
       * - We can't just store attribute values in their parsed idl form,
       *   because setAttribute() has to return whatever string is passed to
       *   getAttribute even if it is not a legal, parseable value. So
       *   attribute values must be stored in unparsed string form.
       *
       * - We need to be able to send change notifications or mutation
       *   events of some sort to the renderer whenever an attribute value
       *   changes, regardless of the way in which it changes.
       *
       * - Some attributes, such as id and class affect other parts of the
       *   DOM API, like getElementById and getElementsByClassName and so
       *   for efficiency, we need to specially track changes to these
       *   special attributes.
       *
       * - Some attributes like class have different names (className) when
       *   reflected.
       *
       * - Attributes whose names begin with the string 'data-' are treated
         specially.
       *
       * - Reflected attributes that have a boolean type in IDL have special
       *   behavior: setting them to false (in IDL) is the same as removing
       *   them with removeAttribute()
       *
       * - numeric attributes (like HTMLElement.tabIndex) can have default
       *   values that must be returned by the idl getter even if the
       *   content attribute does not exist. (The default tabIndex value
       *   actually varies based on the type of the element, so that is a
       *   tricky one).
       *
       * See
       * http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#reflect
       * for rules on how attributes are reflected.
       *
       */
      getAttribute: {
        value: function getAttribute(qname) {
          var attr = this.getAttributeNode(qname);
          return attr ? attr.value : null;
        },
      },
      getAttributeNS: {
        value: function getAttributeNS(ns, lname) {
          var attr = this.getAttributeNodeNS(ns, lname);
          return attr ? attr.value : null;
        },
      },
      getAttributeNode: {
        value: function getAttributeNode(qname) {
          qname = String(qname);
          if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);
          var attr = this._attrsByQName[qname];
          if (!attr) return null;
          if (Array.isArray(attr)) attr = attr[0];
          return attr;
        },
      },
      getAttributeNodeNS: {
        value: function getAttributeNodeNS(ns, lname) {
          ns = ns === void 0 || ns === null ? '' : String(ns);
          lname = String(lname);
          var attr = this._attrsByLName[ns + '|' + lname];
          return attr ? attr : null;
        },
      },
      hasAttribute: {
        value: function hasAttribute(qname) {
          qname = String(qname);
          if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);
          return this._attrsByQName[qname] !== void 0;
        },
      },
      hasAttributeNS: {
        value: function hasAttributeNS(ns, lname) {
          ns = ns === void 0 || ns === null ? '' : String(ns);
          lname = String(lname);
          var key = ns + '|' + lname;
          return this._attrsByLName[key] !== void 0;
        },
      },
      hasAttributes: {
        value: function hasAttributes() {
          return this._numattrs > 0;
        },
      },
      toggleAttribute: {
        value: function toggleAttribute(qname, force) {
          qname = String(qname);
          if (!xml.isValidName(qname)) utils.InvalidCharacterError();
          if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);
          var a = this._attrsByQName[qname];
          if (a === void 0) {
            if (force === void 0 || force === true) {
              this._setAttribute(qname, '');
              return true;
            }
            return false;
          } else {
            if (force === void 0 || force === false) {
              this.removeAttribute(qname);
              return false;
            }
            return true;
          }
        },
      },
      // Set the attribute without error checking. The parser uses this.
      _setAttribute: {
        value: function _setAttribute(qname, value) {
          var attr = this._attrsByQName[qname];
          var isnew;
          if (!attr) {
            attr = this._newattr(qname);
            isnew = true;
          } else {
            if (Array.isArray(attr)) attr = attr[0];
          }
          attr.value = value;
          if (this._attributes) this._attributes[qname] = attr;
          if (isnew && this._newattrhook) this._newattrhook(qname, value);
        },
      },
      // Check for errors, and then set the attribute
      setAttribute: {
        value: function setAttribute(qname, value) {
          qname = String(qname);
          if (!xml.isValidName(qname)) utils.InvalidCharacterError();
          if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);
          this._setAttribute(qname, String(value));
        },
      },
      // The version with no error checking used by the parser
      _setAttributeNS: {
        value: function _setAttributeNS(ns, qname, value) {
          var pos = qname.indexOf(':'),
            prefix,
            lname;
          if (pos < 0) {
            prefix = null;
            lname = qname;
          } else {
            prefix = qname.substring(0, pos);
            lname = qname.substring(pos + 1);
          }
          if (ns === '' || ns === void 0) ns = null;
          var key = (ns === null ? '' : ns) + '|' + lname;
          var attr = this._attrsByLName[key];
          var isnew;
          if (!attr) {
            attr = new Attr(this, lname, prefix, ns);
            isnew = true;
            this._attrsByLName[key] = attr;
            if (this._attributes) {
              this._attributes[this._attrKeys.length] = attr;
            }
            this._attrKeys.push(key);
            this._addQName(attr);
          } else if (false) {
            if (attr.prefix !== prefix) {
              this._removeQName(attr);
              attr.prefix = prefix;
              this._addQName(attr);
            }
          }
          attr.value = value;
          if (isnew && this._newattrhook) this._newattrhook(qname, value);
        },
      },
      // Do error checking then call _setAttributeNS
      setAttributeNS: {
        value: function setAttributeNS(ns, qname, value) {
          ns = ns === null || ns === void 0 || ns === '' ? null : String(ns);
          qname = String(qname);
          if (!xml.isValidQName(qname)) utils.InvalidCharacterError();
          var pos = qname.indexOf(':');
          var prefix = pos < 0 ? null : qname.substring(0, pos);
          if (
            (prefix !== null && ns === null) ||
            (prefix === 'xml' && ns !== NAMESPACE.XML) ||
            ((qname === 'xmlns' || prefix === 'xmlns') && ns !== NAMESPACE.XMLNS) ||
            (ns === NAMESPACE.XMLNS && !(qname === 'xmlns' || prefix === 'xmlns'))
          )
            utils.NamespaceError();
          this._setAttributeNS(ns, qname, String(value));
        },
      },
      setAttributeNode: {
        value: function setAttributeNode(attr) {
          if (attr.ownerElement !== null && attr.ownerElement !== this) {
            throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
          }
          var result = null;
          var oldAttrs = this._attrsByQName[attr.name];
          if (oldAttrs) {
            if (!Array.isArray(oldAttrs)) {
              oldAttrs = [oldAttrs];
            }
            if (
              oldAttrs.some(function (a) {
                return a === attr;
              })
            ) {
              return attr;
            } else if (attr.ownerElement !== null) {
              throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
            }
            oldAttrs.forEach(function (a) {
              this.removeAttributeNode(a);
            }, this);
            result = oldAttrs[0];
          }
          this.setAttributeNodeNS(attr);
          return result;
        },
      },
      setAttributeNodeNS: {
        value: function setAttributeNodeNS(attr) {
          if (attr.ownerElement !== null) {
            throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
          }
          var ns = attr.namespaceURI;
          var key = (ns === null ? '' : ns) + '|' + attr.localName;
          var oldAttr = this._attrsByLName[key];
          if (oldAttr) {
            this.removeAttributeNode(oldAttr);
          }
          attr._setOwnerElement(this);
          this._attrsByLName[key] = attr;
          if (this._attributes) {
            this._attributes[this._attrKeys.length] = attr;
          }
          this._attrKeys.push(key);
          this._addQName(attr);
          if (this._newattrhook) this._newattrhook(attr.name, attr.value);
          return oldAttr || null;
        },
      },
      removeAttribute: {
        value: function removeAttribute(qname) {
          qname = String(qname);
          if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);
          var attr = this._attrsByQName[qname];
          if (!attr) return;
          if (Array.isArray(attr)) {
            if (attr.length > 2) {
              attr = attr.shift();
            } else {
              this._attrsByQName[qname] = attr[1];
              attr = attr[0];
            }
          } else {
            this._attrsByQName[qname] = void 0;
          }
          var ns = attr.namespaceURI;
          var key = (ns === null ? '' : ns) + '|' + attr.localName;
          this._attrsByLName[key] = void 0;
          var i = this._attrKeys.indexOf(key);
          if (this._attributes) {
            Array.prototype.splice.call(this._attributes, i, 1);
            this._attributes[qname] = void 0;
          }
          this._attrKeys.splice(i, 1);
          var onchange = attr.onchange;
          attr._setOwnerElement(null);
          if (onchange) {
            onchange.call(attr, this, attr.localName, attr.value, null);
          }
          if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
        },
      },
      removeAttributeNS: {
        value: function removeAttributeNS(ns, lname) {
          ns = ns === void 0 || ns === null ? '' : String(ns);
          lname = String(lname);
          var key = ns + '|' + lname;
          var attr = this._attrsByLName[key];
          if (!attr) return;
          this._attrsByLName[key] = void 0;
          var i = this._attrKeys.indexOf(key);
          if (this._attributes) {
            Array.prototype.splice.call(this._attributes, i, 1);
          }
          this._attrKeys.splice(i, 1);
          this._removeQName(attr);
          var onchange = attr.onchange;
          attr._setOwnerElement(null);
          if (onchange) {
            onchange.call(attr, this, attr.localName, attr.value, null);
          }
          if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
        },
      },
      removeAttributeNode: {
        value: function removeAttributeNode(attr) {
          var ns = attr.namespaceURI;
          var key = (ns === null ? '' : ns) + '|' + attr.localName;
          if (this._attrsByLName[key] !== attr) {
            utils.NotFoundError();
          }
          this.removeAttributeNS(ns, attr.localName);
          return attr;
        },
      },
      getAttributeNames: {
        value: function getAttributeNames() {
          var elt = this;
          return this._attrKeys.map(function (key) {
            return elt._attrsByLName[key].name;
          });
        },
      },
      // This 'raw' version of getAttribute is used by the getter functions
      // of reflected attributes. It skips some error checking and
      // namespace steps
      _getattr: {
        value: function _getattr(qname) {
          var attr = this._attrsByQName[qname];
          return attr ? attr.value : null;
        },
      },
      // The raw version of setAttribute for reflected idl attributes.
      _setattr: {
        value: function _setattr(qname, value) {
          var attr = this._attrsByQName[qname];
          var isnew;
          if (!attr) {
            attr = this._newattr(qname);
            isnew = true;
          }
          attr.value = String(value);
          if (this._attributes) this._attributes[qname] = attr;
          if (isnew && this._newattrhook) this._newattrhook(qname, value);
        },
      },
      // Create a new Attr object, insert it, and return it.
      // Used by setAttribute() and by set()
      _newattr: {
        value: function _newattr(qname) {
          var attr = new Attr(this, qname, null, null);
          var key = '|' + qname;
          this._attrsByQName[qname] = attr;
          this._attrsByLName[key] = attr;
          if (this._attributes) {
            this._attributes[this._attrKeys.length] = attr;
          }
          this._attrKeys.push(key);
          return attr;
        },
      },
      // Add a qname->Attr mapping to the _attrsByQName object, taking into
      // account that there may be more than one attr object with the
      // same qname
      _addQName: {
        value: function (attr) {
          var qname = attr.name;
          var existing = this._attrsByQName[qname];
          if (!existing) {
            this._attrsByQName[qname] = attr;
          } else if (Array.isArray(existing)) {
            existing.push(attr);
          } else {
            this._attrsByQName[qname] = [existing, attr];
          }
          if (this._attributes) this._attributes[qname] = attr;
        },
      },
      // Remove a qname->Attr mapping to the _attrsByQName object, taking into
      // account that there may be more than one attr object with the
      // same qname
      _removeQName: {
        value: function (attr) {
          var qname = attr.name;
          var target = this._attrsByQName[qname];
          if (Array.isArray(target)) {
            var idx = target.indexOf(attr);
            utils.assert(idx !== -1);
            if (target.length === 2) {
              this._attrsByQName[qname] = target[1 - idx];
              if (this._attributes) {
                this._attributes[qname] = this._attrsByQName[qname];
              }
            } else {
              target.splice(idx, 1);
              if (this._attributes && this._attributes[qname] === attr) {
                this._attributes[qname] = target[0];
              }
            }
          } else {
            utils.assert(target === attr);
            this._attrsByQName[qname] = void 0;
            if (this._attributes) {
              this._attributes[qname] = void 0;
            }
          }
        },
      },
      // Return the number of attributes
      _numattrs: {
        get: function () {
          return this._attrKeys.length;
        },
      },
      // Return the nth Attr object
      _attr: {
        value: function (n) {
          return this._attrsByLName[this._attrKeys[n]];
        },
      },
      // Define getters and setters for an 'id' property that reflects
      // the content attribute 'id'.
      id: attributes.property({ name: 'id' }),
      // Define getters and setters for a 'className' property that reflects
      // the content attribute 'class'.
      className: attributes.property({ name: 'class' }),
      classList: {
        get: function () {
          var self = this;
          if (this._classList) {
            return this._classList;
          }
          var dtlist = new DOMTokenList(
            function () {
              return self.className || '';
            },
            function (v) {
              self.className = v;
            },
          );
          this._classList = dtlist;
          return dtlist;
        },
        set: function (v) {
          this.className = v;
        },
      },
      matches: {
        value: function (selector) {
          return select.matches(this, selector);
        },
      },
      closest: {
        value: function (selector) {
          var el = this;
          do {
            if (el.matches && el.matches(selector)) {
              return el;
            }
            el = el.parentElement || el.parentNode;
          } while (el !== null && el.nodeType === Node.ELEMENT_NODE);
          return null;
        },
      },
      querySelector: {
        value: function (selector) {
          return select(selector, this)[0];
        },
      },
      querySelectorAll: {
        value: function (selector) {
          var nodes = select(selector, this);
          return nodes.item ? nodes : new NodeList(nodes);
        },
      },
    });
    Object.defineProperties(Element.prototype, ChildNode);
    Object.defineProperties(Element.prototype, NonDocumentTypeChildNode);
    attributes.registerChangeHandler(Element, 'id', function (element, lname, oldval, newval) {
      if (element.rooted) {
        if (oldval) {
          element.ownerDocument.delId(oldval, element);
        }
        if (newval) {
          element.ownerDocument.addId(newval, element);
        }
      }
    });
    attributes.registerChangeHandler(Element, 'class', function (element, lname, oldval, newval) {
      if (element._classList) {
        element._classList._update();
      }
    });
    function Attr(elt, lname, prefix, namespace, value) {
      this.localName = lname;
      this.prefix = prefix === null || prefix === '' ? null : '' + prefix;
      this.namespaceURI = namespace === null || namespace === '' ? null : '' + namespace;
      this.data = value;
      this._setOwnerElement(elt);
    }
    Attr.prototype = Object.create(Object.prototype, {
      ownerElement: {
        get: function () {
          return this._ownerElement;
        },
      },
      _setOwnerElement: {
        value: function _setOwnerElement(elt) {
          this._ownerElement = elt;
          if (this.prefix === null && this.namespaceURI === null && elt) {
            this.onchange = elt._attributeChangeHandlers[this.localName];
          } else {
            this.onchange = null;
          }
        },
      },
      name: {
        get: function () {
          return this.prefix ? this.prefix + ':' + this.localName : this.localName;
        },
      },
      specified: {
        get: function () {
          return true;
        },
      },
      value: {
        get: function () {
          return this.data;
        },
        set: function (value) {
          var oldval = this.data;
          value = value === void 0 ? '' : value + '';
          if (value === oldval) return;
          this.data = value;
          if (this.ownerElement) {
            if (this.onchange) this.onchange(this.ownerElement, this.localName, oldval, value);
            if (this.ownerElement.rooted) this.ownerElement.ownerDocument.mutateAttr(this, oldval);
          }
        },
      },
      cloneNode: {
        value: function cloneNode(deep) {
          return new Attr(null, this.localName, this.prefix, this.namespaceURI, this.data);
        },
      },
      // Legacy aliases (see gh#70 and https://dom.spec.whatwg.org/#interface-attr)
      nodeType: {
        get: function () {
          return Node.ATTRIBUTE_NODE;
        },
      },
      nodeName: {
        get: function () {
          return this.name;
        },
      },
      nodeValue: {
        get: function () {
          return this.value;
        },
        set: function (v) {
          this.value = v;
        },
      },
      textContent: {
        get: function () {
          return this.value;
        },
        set: function (v) {
          if (v === null || v === void 0) {
            v = '';
          }
          this.value = v;
        },
      },
      innerText: {
        get: function () {
          return this.value;
        },
        set: function (v) {
          if (v === null || v === void 0) {
            v = '';
          }
          this.value = v;
        },
      },
    });
    Element._Attr = Attr;
    function AttributesArray(elt) {
      NamedNodeMap.call(this, elt);
      for (var name in elt._attrsByQName) {
        this[name] = elt._attrsByQName[name];
      }
      for (var i = 0; i < elt._attrKeys.length; i++) {
        this[i] = elt._attrsByLName[elt._attrKeys[i]];
      }
    }
    AttributesArray.prototype = Object.create(NamedNodeMap.prototype, {
      length: {
        get: function () {
          return this.element._attrKeys.length;
        },
        set: function () {},
      },
      item: {
        value: function (n) {
          n = n >>> 0;
          if (n >= this.length) {
            return null;
          }
          return this.element._attrsByLName[this.element._attrKeys[n]];
        },
      },
    });
    if (globalThis.Symbol?.iterator) {
      AttributesArray.prototype[globalThis.Symbol.iterator] = function () {
        var i = 0,
          n = this.length,
          self = this;
        return {
          next: function () {
            if (i < n) return { value: self.item(i++) };
            return { done: true };
          },
        };
      };
    }
    function ChildrenCollection(e) {
      this.element = e;
      this.updateCache();
    }
    ChildrenCollection.prototype = Object.create(Object.prototype, {
      length: {
        get: function () {
          this.updateCache();
          return this.childrenByNumber.length;
        },
      },
      item: {
        value: function item(n) {
          this.updateCache();
          return this.childrenByNumber[n] || null;
        },
      },
      namedItem: {
        value: function namedItem(name) {
          this.updateCache();
          return this.childrenByName[name] || null;
        },
      },
      // This attribute returns the entire name->element map.
      // It is not part of the HTMLCollection API, but we need it in
      // src/HTMLCollectionProxy
      namedItems: {
        get: function () {
          this.updateCache();
          return this.childrenByName;
        },
      },
      updateCache: {
        value: function updateCache() {
          var namedElts = /^(a|applet|area|embed|form|frame|frameset|iframe|img|object)$/;
          if (this.lastModTime !== this.element.lastModTime) {
            this.lastModTime = this.element.lastModTime;
            var n = (this.childrenByNumber && this.childrenByNumber.length) || 0;
            for (var i = 0; i < n; i++) {
              this[i] = void 0;
            }
            this.childrenByNumber = [];
            this.childrenByName = /* @__PURE__ */ Object.create(null);
            for (var c = this.element.firstChild; c !== null; c = c.nextSibling) {
              if (c.nodeType === Node.ELEMENT_NODE) {
                this[this.childrenByNumber.length] = c;
                this.childrenByNumber.push(c);
                var id = c.getAttribute('id');
                if (id && !this.childrenByName[id]) this.childrenByName[id] = c;
                var name = c.getAttribute('name');
                if (
                  name &&
                  this.element.namespaceURI === NAMESPACE.HTML &&
                  namedElts.test(this.element.localName) &&
                  !this.childrenByName[name]
                )
                  this.childrenByName[id] = c;
              }
            }
          }
        },
      },
    });
    function localNameElementFilter(lname) {
      return function (e) {
        return e.localName === lname;
      };
    }
    function htmlLocalNameElementFilter(lname) {
      var lclname = utils.toASCIILowerCase(lname);
      if (lclname === lname) return localNameElementFilter(lname);
      return function (e) {
        return e.isHTML ? e.localName === lclname : e.localName === lname;
      };
    }
    function namespaceElementFilter(ns) {
      return function (e) {
        return e.namespaceURI === ns;
      };
    }
    function namespaceLocalNameElementFilter(ns, lname) {
      return function (e) {
        return e.namespaceURI === ns && e.localName === lname;
      };
    }
    function classNamesElementFilter(names) {
      return function (e) {
        return names.every(function (n) {
          return e.classList.contains(n);
        });
      };
    }
    function elementNameFilter(name) {
      return function (e) {
        if (e.namespaceURI !== NAMESPACE.HTML) {
          return false;
        }
        return e.getAttribute('name') === name;
      };
    }
  },
});

// node_modules/@mixmark-io/domino/lib/Leaf.js
var require_Leaf = __commonJS({
  'node_modules/@mixmark-io/domino/lib/Leaf.js'(exports2, module2) {
    'use strict';
    module2.exports = Leaf;
    var Node = require_Node();
    var NodeList = require_NodeList();
    var utils = require_utils2();
    var HierarchyRequestError = utils.HierarchyRequestError;
    var NotFoundError = utils.NotFoundError;
    function Leaf() {
      Node.call(this);
    }
    Leaf.prototype = Object.create(Node.prototype, {
      hasChildNodes: {
        value: function () {
          return false;
        },
      },
      firstChild: { value: null },
      lastChild: { value: null },
      insertBefore: {
        value: function (node, child) {
          if (!node.nodeType) throw new TypeError('not a node');
          HierarchyRequestError();
        },
      },
      replaceChild: {
        value: function (node, child) {
          if (!node.nodeType) throw new TypeError('not a node');
          HierarchyRequestError();
        },
      },
      removeChild: {
        value: function (node) {
          if (!node.nodeType) throw new TypeError('not a node');
          NotFoundError();
        },
      },
      removeChildren: { value: function () {} },
      childNodes: {
        get: function () {
          if (!this._childNodes) this._childNodes = new NodeList();
          return this._childNodes;
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/CharacterData.js
var require_CharacterData = __commonJS({
  'node_modules/@mixmark-io/domino/lib/CharacterData.js'(exports2, module2) {
    'use strict';
    module2.exports = CharacterData;
    var Leaf = require_Leaf();
    var utils = require_utils2();
    var ChildNode = require_ChildNode();
    var NonDocumentTypeChildNode = require_NonDocumentTypeChildNode();
    function CharacterData() {
      Leaf.call(this);
    }
    CharacterData.prototype = Object.create(Leaf.prototype, {
      // DOMString substringData(unsigned long offset,
      //               unsigned long count);
      // The substringData(offset, count) method must run these steps:
      //
      //     If offset is greater than the context object's
      //     length, throw an INDEX_SIZE_ERR exception and
      //     terminate these steps.
      //
      //     If offset+count is greater than the context
      //     object's length, return a DOMString whose value is
      //     the UTF-16 code units from the offsetth UTF-16 code
      //     unit to the end of data.
      //
      //     Return a DOMString whose value is the UTF-16 code
      //     units from the offsetth UTF-16 code unit to the
      //     offset+countth UTF-16 code unit in data.
      substringData: {
        value: function substringData(offset, count) {
          if (arguments.length < 2) {
            throw new TypeError('Not enough arguments');
          }
          offset = offset >>> 0;
          count = count >>> 0;
          if (offset > this.data.length || offset < 0 || count < 0) {
            utils.IndexSizeError();
          }
          return this.data.substring(offset, offset + count);
        },
      },
      // void appendData(DOMString data);
      // The appendData(data) method must append data to the context
      // object's data.
      appendData: {
        value: function appendData(data) {
          if (arguments.length < 1) {
            throw new TypeError('Not enough arguments');
          }
          this.data += String(data);
        },
      },
      // void insertData(unsigned long offset, DOMString data);
      // The insertData(offset, data) method must run these steps:
      //
      //     If offset is greater than the context object's
      //     length, throw an INDEX_SIZE_ERR exception and
      //     terminate these steps.
      //
      //     Insert data into the context object's data after
      //     offset UTF-16 code units.
      //
      insertData: {
        value: function insertData(offset, data) {
          return this.replaceData(offset, 0, data);
        },
      },
      // void deleteData(unsigned long offset, unsigned long count);
      // The deleteData(offset, count) method must run these steps:
      //
      //     If offset is greater than the context object's
      //     length, throw an INDEX_SIZE_ERR exception and
      //     terminate these steps.
      //
      //     If offset+count is greater than the context
      //     object's length var count be length-offset.
      //
      //     Starting from offset UTF-16 code units remove count
      //     UTF-16 code units from the context object's data.
      deleteData: {
        value: function deleteData(offset, count) {
          return this.replaceData(offset, count, '');
        },
      },
      // void replaceData(unsigned long offset, unsigned long count,
      //          DOMString data);
      //
      // The replaceData(offset, count, data) method must act as
      // if the deleteData() method is invoked with offset and
      // count as arguments followed by the insertData() method
      // with offset and data as arguments and re-throw any
      // exceptions these methods might have thrown.
      replaceData: {
        value: function replaceData(offset, count, data) {
          var curtext = this.data,
            len = curtext.length;
          offset = offset >>> 0;
          count = count >>> 0;
          data = String(data);
          if (offset > len || offset < 0) utils.IndexSizeError();
          if (offset + count > len) count = len - offset;
          var prefix = curtext.substring(0, offset),
            suffix = curtext.substring(offset + count);
          this.data = prefix + data + suffix;
        },
      },
      // Utility method that Node.isEqualNode() calls to test Text and
      // Comment nodes for equality.  It is okay to put it here, since
      // Node will have already verified that nodeType is equal
      isEqual: {
        value: function isEqual(n) {
          return this._data === n._data;
        },
      },
      length: {
        get: function () {
          return this.data.length;
        },
      },
    });
    Object.defineProperties(CharacterData.prototype, ChildNode);
    Object.defineProperties(CharacterData.prototype, NonDocumentTypeChildNode);
  },
});

// node_modules/@mixmark-io/domino/lib/Text.js
var require_Text = __commonJS({
  'node_modules/@mixmark-io/domino/lib/Text.js'(exports2, module2) {
    'use strict';
    module2.exports = Text;
    var utils = require_utils2();
    var Node = require_Node();
    var CharacterData = require_CharacterData();
    function Text(doc, data) {
      CharacterData.call(this);
      this.nodeType = Node.TEXT_NODE;
      this.ownerDocument = doc;
      this._data = data;
      this._index = void 0;
    }
    var nodeValue = {
      get: function () {
        return this._data;
      },
      set: function (v) {
        if (v === null || v === void 0) {
          v = '';
        } else {
          v = String(v);
        }
        if (v === this._data) return;
        this._data = v;
        if (this.rooted) this.ownerDocument.mutateValue(this);
        if (this.parentNode && this.parentNode._textchangehook) this.parentNode._textchangehook(this);
      },
    };
    Text.prototype = Object.create(CharacterData.prototype, {
      nodeName: { value: '#text' },
      // These three attributes are all the same.
      // The data attribute has a [TreatNullAs=EmptyString] but we'll
      // implement that at the interface level
      nodeValue,
      textContent: nodeValue,
      innerText: nodeValue,
      data: {
        get: nodeValue.get,
        set: function (v) {
          nodeValue.set.call(this, v === null ? '' : String(v));
        },
      },
      splitText: {
        value: function splitText(offset) {
          if (offset > this._data.length || offset < 0) utils.IndexSizeError();
          var newdata = this._data.substring(offset),
            newnode = this.ownerDocument.createTextNode(newdata);
          this.data = this.data.substring(0, offset);
          var parent = this.parentNode;
          if (parent !== null) parent.insertBefore(newnode, this.nextSibling);
          return newnode;
        },
      },
      wholeText: {
        get: function wholeText() {
          var result = this.textContent;
          for (var next = this.nextSibling; next; next = next.nextSibling) {
            if (next.nodeType !== Node.TEXT_NODE) {
              break;
            }
            result += next.textContent;
          }
          return result;
        },
      },
      // Obsolete, removed from spec.
      replaceWholeText: { value: utils.nyi },
      // Utility methods
      clone: {
        value: function clone() {
          return new Text(this.ownerDocument, this._data);
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/Comment.js
var require_Comment = __commonJS({
  'node_modules/@mixmark-io/domino/lib/Comment.js'(exports2, module2) {
    'use strict';
    module2.exports = Comment;
    var Node = require_Node();
    var CharacterData = require_CharacterData();
    function Comment(doc, data) {
      CharacterData.call(this);
      this.nodeType = Node.COMMENT_NODE;
      this.ownerDocument = doc;
      this._data = data;
    }
    var nodeValue = {
      get: function () {
        return this._data;
      },
      set: function (v) {
        if (v === null || v === void 0) {
          v = '';
        } else {
          v = String(v);
        }
        this._data = v;
        if (this.rooted) this.ownerDocument.mutateValue(this);
      },
    };
    Comment.prototype = Object.create(CharacterData.prototype, {
      nodeName: { value: '#comment' },
      nodeValue,
      textContent: nodeValue,
      innerText: nodeValue,
      data: {
        get: nodeValue.get,
        set: function (v) {
          nodeValue.set.call(this, v === null ? '' : String(v));
        },
      },
      // Utility methods
      clone: {
        value: function clone() {
          return new Comment(this.ownerDocument, this._data);
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/DocumentFragment.js
var require_DocumentFragment = __commonJS({
  'node_modules/@mixmark-io/domino/lib/DocumentFragment.js'(exports2, module2) {
    'use strict';
    module2.exports = DocumentFragment;
    var Node = require_Node();
    var NodeList = require_NodeList();
    var ContainerNode = require_ContainerNode();
    var Element = require_Element();
    var select = require_select();
    var utils = require_utils2();
    function DocumentFragment(doc) {
      ContainerNode.call(this);
      this.nodeType = Node.DOCUMENT_FRAGMENT_NODE;
      this.ownerDocument = doc;
    }
    DocumentFragment.prototype = Object.create(ContainerNode.prototype, {
      nodeName: { value: '#document-fragment' },
      nodeValue: {
        get: function () {
          return null;
        },
        set: function () {},
      },
      // Copy the text content getter/setter from Element
      textContent: Object.getOwnPropertyDescriptor(Element.prototype, 'textContent'),
      // Copy the text content getter/setter from Element
      innerText: Object.getOwnPropertyDescriptor(Element.prototype, 'innerText'),
      querySelector: {
        value: function (selector) {
          var nodes = this.querySelectorAll(selector);
          return nodes.length ? nodes[0] : null;
        },
      },
      querySelectorAll: {
        value: function (selector) {
          var context = Object.create(this);
          context.isHTML = true;
          context.getElementsByTagName = Element.prototype.getElementsByTagName;
          context.nextElement = Object.getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').get;
          var nodes = select(selector, context);
          return nodes.item ? nodes : new NodeList(nodes);
        },
      },
      // Utility methods
      clone: {
        value: function clone() {
          return new DocumentFragment(this.ownerDocument);
        },
      },
      isEqual: {
        value: function isEqual(n) {
          return true;
        },
      },
      // Non-standard, but useful (github issue #73)
      innerHTML: {
        get: function () {
          return this.serialize();
        },
        set: utils.nyi,
      },
      outerHTML: {
        get: function () {
          return this.serialize();
        },
        set: utils.nyi,
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/ProcessingInstruction.js
var require_ProcessingInstruction = __commonJS({
  'node_modules/@mixmark-io/domino/lib/ProcessingInstruction.js'(exports2, module2) {
    'use strict';
    module2.exports = ProcessingInstruction;
    var Node = require_Node();
    var CharacterData = require_CharacterData();
    function ProcessingInstruction(doc, target, data) {
      CharacterData.call(this);
      this.nodeType = Node.PROCESSING_INSTRUCTION_NODE;
      this.ownerDocument = doc;
      this.target = target;
      this._data = data;
    }
    var nodeValue = {
      get: function () {
        return this._data;
      },
      set: function (v) {
        if (v === null || v === void 0) {
          v = '';
        } else {
          v = String(v);
        }
        this._data = v;
        if (this.rooted) this.ownerDocument.mutateValue(this);
      },
    };
    ProcessingInstruction.prototype = Object.create(CharacterData.prototype, {
      nodeName: {
        get: function () {
          return this.target;
        },
      },
      nodeValue,
      textContent: nodeValue,
      innerText: nodeValue,
      data: {
        get: nodeValue.get,
        set: function (v) {
          nodeValue.set.call(this, v === null ? '' : String(v));
        },
      },
      // Utility methods
      clone: {
        value: function clone() {
          return new ProcessingInstruction(this.ownerDocument, this.target, this._data);
        },
      },
      isEqual: {
        value: function isEqual(n) {
          return this.target === n.target && this._data === n._data;
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/NodeFilter.js
var require_NodeFilter = __commonJS({
  'node_modules/@mixmark-io/domino/lib/NodeFilter.js'(exports2, module2) {
    'use strict';
    var NodeFilter = {
      // Constants for acceptNode()
      FILTER_ACCEPT: 1,
      FILTER_REJECT: 2,
      FILTER_SKIP: 3,
      // Constants for whatToShow
      SHOW_ALL: 4294967295,
      SHOW_ELEMENT: 1,
      SHOW_ATTRIBUTE: 2,
      // historical
      SHOW_TEXT: 4,
      SHOW_CDATA_SECTION: 8,
      // historical
      SHOW_ENTITY_REFERENCE: 16,
      // historical
      SHOW_ENTITY: 32,
      // historical
      SHOW_PROCESSING_INSTRUCTION: 64,
      SHOW_COMMENT: 128,
      SHOW_DOCUMENT: 256,
      SHOW_DOCUMENT_TYPE: 512,
      SHOW_DOCUMENT_FRAGMENT: 1024,
      SHOW_NOTATION: 2048,
      // historical
    };
    module2.exports = NodeFilter.constructor = NodeFilter.prototype = NodeFilter;
  },
});

// node_modules/@mixmark-io/domino/lib/NodeTraversal.js
var require_NodeTraversal = __commonJS({
  'node_modules/@mixmark-io/domino/lib/NodeTraversal.js'(exports2, module2) {
    'use strict';
    var NodeTraversal = (module2.exports = {
      nextSkippingChildren,
      nextAncestorSibling,
      next,
      previous,
      deepLastChild,
    });
    function nextSkippingChildren(node, stayWithin) {
      if (node === stayWithin) {
        return null;
      }
      if (node.nextSibling !== null) {
        return node.nextSibling;
      }
      return nextAncestorSibling(node, stayWithin);
    }
    function nextAncestorSibling(node, stayWithin) {
      for (node = node.parentNode; node !== null; node = node.parentNode) {
        if (node === stayWithin) {
          return null;
        }
        if (node.nextSibling !== null) {
          return node.nextSibling;
        }
      }
      return null;
    }
    function next(node, stayWithin) {
      var n;
      n = node.firstChild;
      if (n !== null) {
        return n;
      }
      if (node === stayWithin) {
        return null;
      }
      n = node.nextSibling;
      if (n !== null) {
        return n;
      }
      return nextAncestorSibling(node, stayWithin);
    }
    function deepLastChild(node) {
      while (node.lastChild) {
        node = node.lastChild;
      }
      return node;
    }
    function previous(node, stayWithin) {
      var p;
      p = node.previousSibling;
      if (p !== null) {
        return deepLastChild(p);
      }
      p = node.parentNode;
      if (p === stayWithin) {
        return null;
      }
      return p;
    }
  },
});

// node_modules/@mixmark-io/domino/lib/TreeWalker.js
var require_TreeWalker = __commonJS({
  'node_modules/@mixmark-io/domino/lib/TreeWalker.js'(exports2, module2) {
    'use strict';
    module2.exports = TreeWalker;
    var Node = require_Node();
    var NodeFilter = require_NodeFilter();
    var NodeTraversal = require_NodeTraversal();
    var utils = require_utils2();
    var mapChild = {
      first: 'firstChild',
      last: 'lastChild',
      next: 'firstChild',
      previous: 'lastChild',
    };
    var mapSibling = {
      first: 'nextSibling',
      last: 'previousSibling',
      next: 'nextSibling',
      previous: 'previousSibling',
    };
    function traverseChildren(tw, type) {
      var child, node, parent, result, sibling;
      node = tw._currentNode[mapChild[type]];
      while (node !== null) {
        result = tw._internalFilter(node);
        if (result === NodeFilter.FILTER_ACCEPT) {
          tw._currentNode = node;
          return node;
        }
        if (result === NodeFilter.FILTER_SKIP) {
          child = node[mapChild[type]];
          if (child !== null) {
            node = child;
            continue;
          }
        }
        while (node !== null) {
          sibling = node[mapSibling[type]];
          if (sibling !== null) {
            node = sibling;
            break;
          }
          parent = node.parentNode;
          if (parent === null || parent === tw.root || parent === tw._currentNode) {
            return null;
          } else {
            node = parent;
          }
        }
      }
      return null;
    }
    function traverseSiblings(tw, type) {
      var node, result, sibling;
      node = tw._currentNode;
      if (node === tw.root) {
        return null;
      }
      while (true) {
        sibling = node[mapSibling[type]];
        while (sibling !== null) {
          node = sibling;
          result = tw._internalFilter(node);
          if (result === NodeFilter.FILTER_ACCEPT) {
            tw._currentNode = node;
            return node;
          }
          sibling = node[mapChild[type]];
          if (result === NodeFilter.FILTER_REJECT || sibling === null) {
            sibling = node[mapSibling[type]];
          }
        }
        node = node.parentNode;
        if (node === null || node === tw.root) {
          return null;
        }
        if (tw._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {
          return null;
        }
      }
    }
    function TreeWalker(root, whatToShow, filter) {
      if (!root || !root.nodeType) {
        utils.NotSupportedError();
      }
      this._root = root;
      this._whatToShow = Number(whatToShow) || 0;
      this._filter = filter || null;
      this._active = false;
      this._currentNode = root;
    }
    Object.defineProperties(TreeWalker.prototype, {
      root: {
        get: function () {
          return this._root;
        },
      },
      whatToShow: {
        get: function () {
          return this._whatToShow;
        },
      },
      filter: {
        get: function () {
          return this._filter;
        },
      },
      currentNode: {
        get: function currentNode() {
          return this._currentNode;
        },
        set: function setCurrentNode(v) {
          if (!(v instanceof Node)) {
            throw new TypeError('Not a Node');
          }
          this._currentNode = v;
        },
      },
      /**
       * @method
       * @param {Node} node
       * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
       *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
       */
      _internalFilter: {
        value: function _internalFilter(node) {
          var result, filter;
          if (this._active) {
            utils.InvalidStateError();
          }
          if (!((1 << (node.nodeType - 1)) & this._whatToShow)) {
            return NodeFilter.FILTER_SKIP;
          }
          filter = this._filter;
          if (filter === null) {
            result = NodeFilter.FILTER_ACCEPT;
          } else {
            this._active = true;
            try {
              if (typeof filter === 'function') {
                result = filter(node);
              } else {
                result = filter.acceptNode(node);
              }
            } finally {
              this._active = false;
            }
          }
          return +result;
        },
      },
      /**
       * @spec https://dom.spec.whatwg.org/#dom-treewalker-parentnode
       * @based on WebKit's TreeWalker::parentNode
       * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L50
       * @method
       * @return {Node|null}
       */
      parentNode: {
        value: function parentNode() {
          var node = this._currentNode;
          while (node !== this.root) {
            node = node.parentNode;
            if (node === null) {
              return null;
            }
            if (this._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {
              this._currentNode = node;
              return node;
            }
          }
          return null;
        },
      },
      /**
       * @spec https://dom.spec.whatwg.org/#dom-treewalker-firstchild
       * @method
       * @return {Node|null}
       */
      firstChild: {
        value: function firstChild() {
          return traverseChildren(this, 'first');
        },
      },
      /**
       * @spec https://dom.spec.whatwg.org/#dom-treewalker-lastchild
       * @method
       * @return {Node|null}
       */
      lastChild: {
        value: function lastChild() {
          return traverseChildren(this, 'last');
        },
      },
      /**
       * @spec http://www.w3.org/TR/dom/#dom-treewalker-previoussibling
       * @method
       * @return {Node|null}
       */
      previousSibling: {
        value: function previousSibling() {
          return traverseSiblings(this, 'previous');
        },
      },
      /**
       * @spec http://www.w3.org/TR/dom/#dom-treewalker-nextsibling
       * @method
       * @return {Node|null}
       */
      nextSibling: {
        value: function nextSibling() {
          return traverseSiblings(this, 'next');
        },
      },
      /**
       * @spec https://dom.spec.whatwg.org/#dom-treewalker-previousnode
       * @based on WebKit's TreeWalker::previousNode
       * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L181
       * @method
       * @return {Node|null}
       */
      previousNode: {
        value: function previousNode() {
          var node, result, previousSibling, lastChild;
          node = this._currentNode;
          while (node !== this._root) {
            for (previousSibling = node.previousSibling; previousSibling; previousSibling = node.previousSibling) {
              node = previousSibling;
              result = this._internalFilter(node);
              if (result === NodeFilter.FILTER_REJECT) {
                continue;
              }
              for (lastChild = node.lastChild; lastChild; lastChild = node.lastChild) {
                node = lastChild;
                result = this._internalFilter(node);
                if (result === NodeFilter.FILTER_REJECT) {
                  break;
                }
              }
              if (result === NodeFilter.FILTER_ACCEPT) {
                this._currentNode = node;
                return node;
              }
            }
            if (node === this.root || node.parentNode === null) {
              return null;
            }
            node = node.parentNode;
            if (this._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {
              this._currentNode = node;
              return node;
            }
          }
          return null;
        },
      },
      /**
       * @spec https://dom.spec.whatwg.org/#dom-treewalker-nextnode
       * @based on WebKit's TreeWalker::nextNode
       * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L228
       * @method
       * @return {Node|null}
       */
      nextNode: {
        value: function nextNode() {
          var node, result, firstChild, nextSibling;
          node = this._currentNode;
          result = NodeFilter.FILTER_ACCEPT;
          CHILDREN: while (true) {
            for (firstChild = node.firstChild; firstChild; firstChild = node.firstChild) {
              node = firstChild;
              result = this._internalFilter(node);
              if (result === NodeFilter.FILTER_ACCEPT) {
                this._currentNode = node;
                return node;
              } else if (result === NodeFilter.FILTER_REJECT) {
                break;
              }
            }
            for (
              nextSibling = NodeTraversal.nextSkippingChildren(node, this.root);
              nextSibling;
              nextSibling = NodeTraversal.nextSkippingChildren(node, this.root)
            ) {
              node = nextSibling;
              result = this._internalFilter(node);
              if (result === NodeFilter.FILTER_ACCEPT) {
                this._currentNode = node;
                return node;
              } else if (result === NodeFilter.FILTER_SKIP) {
                continue CHILDREN;
              }
            }
            return null;
          }
        },
      },
      /** For compatibility with web-platform-tests. */
      toString: {
        value: function toString() {
          return '[object TreeWalker]';
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/NodeIterator.js
var require_NodeIterator = __commonJS({
  'node_modules/@mixmark-io/domino/lib/NodeIterator.js'(exports2, module2) {
    'use strict';
    module2.exports = NodeIterator;
    var NodeFilter = require_NodeFilter();
    var NodeTraversal = require_NodeTraversal();
    var utils = require_utils2();
    function move(node, stayWithin, directionIsNext) {
      if (directionIsNext) {
        return NodeTraversal.next(node, stayWithin);
      } else {
        if (node === stayWithin) {
          return null;
        }
        return NodeTraversal.previous(node, null);
      }
    }
    function isInclusiveAncestor(node, possibleChild) {
      for (; possibleChild; possibleChild = possibleChild.parentNode) {
        if (node === possibleChild) {
          return true;
        }
      }
      return false;
    }
    function traverse(ni, directionIsNext) {
      var node, beforeNode;
      node = ni._referenceNode;
      beforeNode = ni._pointerBeforeReferenceNode;
      while (true) {
        if (beforeNode === directionIsNext) {
          beforeNode = !beforeNode;
        } else {
          node = move(node, ni._root, directionIsNext);
          if (node === null) {
            return null;
          }
        }
        var result = ni._internalFilter(node);
        if (result === NodeFilter.FILTER_ACCEPT) {
          break;
        }
      }
      ni._referenceNode = node;
      ni._pointerBeforeReferenceNode = beforeNode;
      return node;
    }
    function NodeIterator(root, whatToShow, filter) {
      if (!root || !root.nodeType) {
        utils.NotSupportedError();
      }
      this._root = root;
      this._referenceNode = root;
      this._pointerBeforeReferenceNode = true;
      this._whatToShow = Number(whatToShow) || 0;
      this._filter = filter || null;
      this._active = false;
      root.doc._attachNodeIterator(this);
    }
    Object.defineProperties(NodeIterator.prototype, {
      root: {
        get: function root() {
          return this._root;
        },
      },
      referenceNode: {
        get: function referenceNode() {
          return this._referenceNode;
        },
      },
      pointerBeforeReferenceNode: {
        get: function pointerBeforeReferenceNode() {
          return this._pointerBeforeReferenceNode;
        },
      },
      whatToShow: {
        get: function whatToShow() {
          return this._whatToShow;
        },
      },
      filter: {
        get: function filter() {
          return this._filter;
        },
      },
      /**
       * @method
       * @param {Node} node
       * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
       *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
       */
      _internalFilter: {
        value: function _internalFilter(node) {
          var result, filter;
          if (this._active) {
            utils.InvalidStateError();
          }
          if (!((1 << (node.nodeType - 1)) & this._whatToShow)) {
            return NodeFilter.FILTER_SKIP;
          }
          filter = this._filter;
          if (filter === null) {
            result = NodeFilter.FILTER_ACCEPT;
          } else {
            this._active = true;
            try {
              if (typeof filter === 'function') {
                result = filter(node);
              } else {
                result = filter.acceptNode(node);
              }
            } finally {
              this._active = false;
            }
          }
          return +result;
        },
      },
      /**
       * @spec https://dom.spec.whatwg.org/#nodeiterator-pre-removing-steps
       * @method
       * @return void
       */
      _preremove: {
        value: function _preremove(toBeRemovedNode) {
          if (isInclusiveAncestor(toBeRemovedNode, this._root)) {
            return;
          }
          if (!isInclusiveAncestor(toBeRemovedNode, this._referenceNode)) {
            return;
          }
          if (this._pointerBeforeReferenceNode) {
            var next = toBeRemovedNode;
            while (next.lastChild) {
              next = next.lastChild;
            }
            next = NodeTraversal.next(next, this.root);
            if (next) {
              this._referenceNode = next;
              return;
            }
            this._pointerBeforeReferenceNode = false;
          }
          if (toBeRemovedNode.previousSibling === null) {
            this._referenceNode = toBeRemovedNode.parentNode;
          } else {
            this._referenceNode = toBeRemovedNode.previousSibling;
            var lastChild;
            for (lastChild = this._referenceNode.lastChild; lastChild; lastChild = this._referenceNode.lastChild) {
              this._referenceNode = lastChild;
            }
          }
        },
      },
      /**
       * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-nextnode
       * @method
       * @return {Node|null}
       */
      nextNode: {
        value: function nextNode() {
          return traverse(this, true);
        },
      },
      /**
       * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-previousnode
       * @method
       * @return {Node|null}
       */
      previousNode: {
        value: function previousNode() {
          return traverse(this, false);
        },
      },
      /**
       * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-detach
       * @method
       * @return void
       */
      detach: { value: function detach() {} },
      /** For compatibility with web-platform-tests. */
      toString: {
        value: function toString() {
          return '[object NodeIterator]';
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/URL.js
var require_URL = __commonJS({
  'node_modules/@mixmark-io/domino/lib/URL.js'(exports2, module2) {
    'use strict';
    module2.exports = URL3;
    function URL3(url) {
      if (!url) return Object.create(URL3.prototype);
      this.url = url.replace(/^[ \t\n\r\f]+|[ \t\n\r\f]+$/g, '');
      var match = URL3.pattern.exec(this.url);
      if (match) {
        if (match[2]) this.scheme = match[2];
        if (match[4]) {
          var userinfo = match[4].match(URL3.userinfoPattern);
          if (userinfo) {
            this.username = userinfo[1];
            this.password = userinfo[3];
            match[4] = match[4].substring(userinfo[0].length);
          }
          if (match[4].match(URL3.portPattern)) {
            var pos = match[4].lastIndexOf(':');
            this.host = match[4].substring(0, pos);
            this.port = match[4].substring(pos + 1);
          } else {
            this.host = match[4];
          }
        }
        if (match[5]) this.path = match[5];
        if (match[6]) this.query = match[7];
        if (match[8]) this.fragment = match[9];
      }
    }
    URL3.pattern = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/;
    URL3.userinfoPattern = /^([^@:]*)(:([^@]*))?@/;
    URL3.portPattern = /:\d+$/;
    URL3.authorityPattern = /^[^:\/?#]+:\/\//;
    URL3.hierarchyPattern = /^[^:\/?#]+:\//;
    URL3.percentEncode = function percentEncode(s) {
      var c = s.charCodeAt(0);
      if (c < 256) return '%' + c.toString(16);
      else throw Error("can't percent-encode codepoints > 255 yet");
    };
    URL3.prototype = {
      constructor: URL3,
      // XXX: not sure if this is the precise definition of absolute
      isAbsolute: function () {
        return !!this.scheme;
      },
      isAuthorityBased: function () {
        return URL3.authorityPattern.test(this.url);
      },
      isHierarchical: function () {
        return URL3.hierarchyPattern.test(this.url);
      },
      toString: function () {
        var s = '';
        if (this.scheme !== void 0) s += this.scheme + ':';
        if (this.isAbsolute()) {
          s += '//';
          if (this.username || this.password) {
            s += this.username || '';
            if (this.password) {
              s += ':' + this.password;
            }
            s += '@';
          }
          if (this.host) {
            s += this.host;
          }
        }
        if (this.port !== void 0) s += ':' + this.port;
        if (this.path !== void 0) s += this.path;
        if (this.query !== void 0) s += '?' + this.query;
        if (this.fragment !== void 0) s += '#' + this.fragment;
        return s;
      },
      // See: http://tools.ietf.org/html/rfc3986#section-5.2
      // and https://url.spec.whatwg.org/#constructors
      resolve: function (relative) {
        var base = this;
        var r = new URL3(relative);
        var t = new URL3();
        if (r.scheme !== void 0) {
          t.scheme = r.scheme;
          t.username = r.username;
          t.password = r.password;
          t.host = r.host;
          t.port = r.port;
          t.path = remove_dot_segments(r.path);
          t.query = r.query;
        } else {
          t.scheme = base.scheme;
          if (r.host !== void 0) {
            t.username = r.username;
            t.password = r.password;
            t.host = r.host;
            t.port = r.port;
            t.path = remove_dot_segments(r.path);
            t.query = r.query;
          } else {
            t.username = base.username;
            t.password = base.password;
            t.host = base.host;
            t.port = base.port;
            if (!r.path) {
              t.path = base.path;
              if (r.query !== void 0) t.query = r.query;
              else t.query = base.query;
            } else {
              if (r.path.charAt(0) === '/') {
                t.path = remove_dot_segments(r.path);
              } else {
                t.path = merge2(base.path, r.path);
                t.path = remove_dot_segments(t.path);
              }
              t.query = r.query;
            }
          }
        }
        t.fragment = r.fragment;
        return t.toString();
        function merge2(basepath, refpath) {
          if (base.host !== void 0 && !base.path) return '/' + refpath;
          var lastslash = basepath.lastIndexOf('/');
          if (lastslash === -1) return refpath;
          else return basepath.substring(0, lastslash + 1) + refpath;
        }
        function remove_dot_segments(path) {
          if (!path) return path;
          var output = '';
          while (path.length > 0) {
            if (path === '.' || path === '..') {
              path = '';
              break;
            }
            var twochars = path.substring(0, 2);
            var threechars = path.substring(0, 3);
            var fourchars = path.substring(0, 4);
            if (threechars === '../') {
              path = path.substring(3);
            } else if (twochars === './') {
              path = path.substring(2);
            } else if (threechars === '/./') {
              path = '/' + path.substring(3);
            } else if (twochars === '/.' && path.length === 2) {
              path = '/';
            } else if (fourchars === '/../' || (threechars === '/..' && path.length === 3)) {
              path = '/' + path.substring(4);
              output = output.replace(/\/?[^\/]*$/, '');
            } else {
              var segment = path.match(/(\/?([^\/]*))/)[0];
              output += segment;
              path = path.substring(segment.length);
            }
          }
          return output;
        }
      },
    };
  },
});

// node_modules/@mixmark-io/domino/lib/CustomEvent.js
var require_CustomEvent = __commonJS({
  'node_modules/@mixmark-io/domino/lib/CustomEvent.js'(exports2, module2) {
    'use strict';
    module2.exports = CustomEvent;
    var Event = require_Event();
    function CustomEvent(type, dictionary) {
      Event.call(this, type, dictionary);
    }
    CustomEvent.prototype = Object.create(Event.prototype, {
      constructor: { value: CustomEvent },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/events.js
var require_events = __commonJS({
  'node_modules/@mixmark-io/domino/lib/events.js'(exports2, module2) {
    'use strict';
    module2.exports = {
      Event: require_Event(),
      UIEvent: require_UIEvent(),
      MouseEvent: require_MouseEvent(),
      CustomEvent: require_CustomEvent(),
    };
  },
});

// node_modules/@mixmark-io/domino/lib/style_parser.js
var require_style_parser = __commonJS({
  'node_modules/@mixmark-io/domino/lib/style_parser.js'(exports2) {
    'use strict';
    Object.defineProperty(exports2, '__esModule', { value: true });
    exports2.hyphenate = exports2.parse = void 0;
    function parse2(value) {
      const styles3 = [];
      let i = 0;
      let parenDepth = 0;
      let quote = 0;
      let valueStart = 0;
      let propStart = 0;
      let currentProp = null;
      while (i < value.length) {
        const token = value.charCodeAt(i++);
        switch (token) {
          case 40:
            parenDepth++;
            break;
          case 41:
            parenDepth--;
            break;
          case 39:
            if (quote === 0) {
              quote = 39;
            } else if (quote === 39 && value.charCodeAt(i - 1) !== 92) {
              quote = 0;
            }
            break;
          case 34:
            if (quote === 0) {
              quote = 34;
            } else if (quote === 34 && value.charCodeAt(i - 1) !== 92) {
              quote = 0;
            }
            break;
          case 58:
            if (!currentProp && parenDepth === 0 && quote === 0) {
              currentProp = hyphenate(value.substring(propStart, i - 1).trim());
              valueStart = i;
            }
            break;
          case 59:
            if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0) {
              const styleVal = value.substring(valueStart, i - 1).trim();
              styles3.push(currentProp, styleVal);
              propStart = i;
              valueStart = 0;
              currentProp = null;
            }
            break;
        }
      }
      if (currentProp && valueStart) {
        const styleVal = value.slice(valueStart).trim();
        styles3.push(currentProp, styleVal);
      }
      return styles3;
    }
    exports2.parse = parse2;
    function hyphenate(value) {
      return value
        .replace(/[a-z][A-Z]/g, (v) => {
          return v.charAt(0) + '-' + v.charAt(1);
        })
        .toLowerCase();
    }
    exports2.hyphenate = hyphenate;
  },
});

// node_modules/@mixmark-io/domino/lib/CSSStyleDeclaration.js
var require_CSSStyleDeclaration = __commonJS({
  'node_modules/@mixmark-io/domino/lib/CSSStyleDeclaration.js'(exports2, module2) {
    'use strict';
    var { parse: parse2 } = require_style_parser();
    module2.exports = function (elt) {
      const style = new CSSStyleDeclaration(elt);
      const handler2 = {
        get: function (target, property) {
          return property in target ? target[property] : target.getPropertyValue(dasherizeProperty(property));
        },
        has: function (target, key) {
          return true;
        },
        set: function (target, property, value) {
          if (property in target) {
            target[property] = value;
          } else {
            target.setProperty(dasherizeProperty(property), value ?? void 0);
          }
          return true;
        },
      };
      return new Proxy(style, handler2);
    };
    function dasherizeProperty(property) {
      return property.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    }
    function CSSStyleDeclaration(elt) {
      this._element = elt;
    }
    var IMPORTANT_BANG = '!important';
    function parseStyles(value) {
      const result = {
        property: {},
        priority: {},
      };
      if (!value) {
        return result;
      }
      const styleValues = parse2(value);
      if (styleValues.length < 2) {
        return result;
      }
      for (let i = 0; i < styleValues.length; i += 2) {
        const name = styleValues[i];
        let value2 = styleValues[i + 1];
        if (value2.endsWith(IMPORTANT_BANG)) {
          result.priority[name] = 'important';
          value2 = value2.slice(0, -IMPORTANT_BANG.length).trim();
        }
        result.property[name] = value2;
      }
      return result;
    }
    var NO_CHANGE = {};
    CSSStyleDeclaration.prototype = Object.create(Object.prototype, {
      // Return the parsed form of the element's style attribute.
      // If the element's style attribute has never been parsed
      // or if it has changed since the last parse, then reparse it
      // Note that the styles don't get parsed until they're actually needed
      _parsed: {
        get: function () {
          if (!this._parsedStyles || this.cssText !== this._lastParsedText) {
            var text = this.cssText;
            this._parsedStyles = parseStyles(text);
            this._lastParsedText = text;
            delete this._names;
          }
          return this._parsedStyles;
        },
      },
      // Call this method any time the parsed representation of the
      // style changes.  It converts the style properties to a string and
      // sets cssText and the element's style attribute
      _serialize: {
        value: function () {
          var styles3 = this._parsed;
          var s = '';
          for (var name in styles3.property) {
            if (s) s += ' ';
            s += name + ': ' + styles3.property[name];
            if (styles3.priority[name]) {
              s += ' !' + styles3.priority[name];
            }
            s += ';';
          }
          this.cssText = s;
          this._lastParsedText = s;
          delete this._names;
        },
      },
      cssText: {
        get: function () {
          return this._element.getAttribute('style');
        },
        set: function (value) {
          this._element.setAttribute('style', value);
        },
      },
      length: {
        get: function () {
          if (!this._names) this._names = Object.getOwnPropertyNames(this._parsed.property);
          return this._names.length;
        },
      },
      item: {
        value: function (n) {
          if (!this._names) this._names = Object.getOwnPropertyNames(this._parsed.property);
          return this._names[n];
        },
      },
      getPropertyValue: {
        value: function (property) {
          property = property.toLowerCase();
          return this._parsed.property[property] || '';
        },
      },
      getPropertyPriority: {
        value: function (property) {
          property = property.toLowerCase();
          return this._parsed.priority[property] || '';
        },
      },
      setProperty: {
        value: function (property, value, priority) {
          property = property.toLowerCase();
          if (value === null || value === void 0) {
            value = '';
          }
          if (priority === null || priority === void 0) {
            priority = '';
          }
          if (value !== NO_CHANGE) {
            value = '' + value;
          }
          value = value.trim();
          if (value === '') {
            this.removeProperty(property);
            return;
          }
          if (priority !== '' && priority !== NO_CHANGE && !/^important$/i.test(priority)) {
            return;
          }
          var styles3 = this._parsed;
          if (value === NO_CHANGE) {
            if (!styles3.property[property]) {
              return;
            }
            if (priority !== '') {
              styles3.priority[property] = 'important';
            } else {
              delete styles3.priority[property];
            }
          } else {
            if (value.indexOf(';') !== -1) return;
            var newprops = parseStyles(property + ':' + value);
            if (Object.getOwnPropertyNames(newprops.property).length === 0) {
              return;
            }
            if (Object.getOwnPropertyNames(newprops.priority).length !== 0) {
              return;
            }
            for (var p in newprops.property) {
              styles3.property[p] = newprops.property[p];
              if (priority === NO_CHANGE) {
                continue;
              } else if (priority !== '') {
                styles3.priority[p] = 'important';
              } else if (styles3.priority[p]) {
                delete styles3.priority[p];
              }
            }
          }
          this._serialize();
        },
      },
      setPropertyValue: {
        value: function (property, value) {
          return this.setProperty(property, value, NO_CHANGE);
        },
      },
      setPropertyPriority: {
        value: function (property, priority) {
          return this.setProperty(property, NO_CHANGE, priority);
        },
      },
      removeProperty: {
        value: function (property) {
          property = property.toLowerCase();
          var styles3 = this._parsed;
          if (property in styles3.property) {
            delete styles3.property[property];
            delete styles3.priority[property];
            this._serialize();
          }
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/URLUtils.js
var require_URLUtils = __commonJS({
  'node_modules/@mixmark-io/domino/lib/URLUtils.js'(exports2, module2) {
    'use strict';
    var URL3 = require_URL();
    module2.exports = URLUtils;
    function URLUtils() {}
    URLUtils.prototype = Object.create(Object.prototype, {
      _url: {
        get: function () {
          return new URL3(this.href);
        },
      },
      protocol: {
        get: function () {
          var url = this._url;
          if (url && url.scheme) return url.scheme + ':';
          else return ':';
        },
        set: function (v) {
          var output = this.href;
          var url = new URL3(output);
          if (url.isAbsolute()) {
            v = v.replace(/:+$/, '');
            v = v.replace(/[^-+\.a-zA-Z0-9]/g, URL3.percentEncode);
            if (v.length > 0) {
              url.scheme = v;
              output = url.toString();
            }
          }
          this.href = output;
        },
      },
      host: {
        get: function () {
          var url = this._url;
          if (url.isAbsolute() && url.isAuthorityBased()) return url.host + (url.port ? ':' + url.port : '');
          else return '';
        },
        set: function (v) {
          var output = this.href;
          var url = new URL3(output);
          if (url.isAbsolute() && url.isAuthorityBased()) {
            v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL3.percentEncode);
            if (v.length > 0) {
              url.host = v;
              delete url.port;
              output = url.toString();
            }
          }
          this.href = output;
        },
      },
      hostname: {
        get: function () {
          var url = this._url;
          if (url.isAbsolute() && url.isAuthorityBased()) return url.host;
          else return '';
        },
        set: function (v) {
          var output = this.href;
          var url = new URL3(output);
          if (url.isAbsolute() && url.isAuthorityBased()) {
            v = v.replace(/^\/+/, '');
            v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL3.percentEncode);
            if (v.length > 0) {
              url.host = v;
              output = url.toString();
            }
          }
          this.href = output;
        },
      },
      port: {
        get: function () {
          var url = this._url;
          if (url.isAbsolute() && url.isAuthorityBased() && url.port !== void 0) return url.port;
          else return '';
        },
        set: function (v) {
          var output = this.href;
          var url = new URL3(output);
          if (url.isAbsolute() && url.isAuthorityBased()) {
            v = '' + v;
            v = v.replace(/[^0-9].*$/, '');
            v = v.replace(/^0+/, '');
            if (v.length === 0) v = '0';
            if (parseInt(v, 10) <= 65535) {
              url.port = v;
              output = url.toString();
            }
          }
          this.href = output;
        },
      },
      pathname: {
        get: function () {
          var url = this._url;
          if (url.isAbsolute() && url.isHierarchical()) return url.path;
          else return '';
        },
        set: function (v) {
          var output = this.href;
          var url = new URL3(output);
          if (url.isAbsolute() && url.isHierarchical()) {
            if (v.charAt(0) !== '/') v = '/' + v;
            v = v.replace(/[^-+\._~!$&'()*,;:=@\/a-zA-Z0-9]/g, URL3.percentEncode);
            url.path = v;
            output = url.toString();
          }
          this.href = output;
        },
      },
      search: {
        get: function () {
          var url = this._url;
          if (url.isAbsolute() && url.isHierarchical() && url.query !== void 0) return '?' + url.query;
          else return '';
        },
        set: function (v) {
          var output = this.href;
          var url = new URL3(output);
          if (url.isAbsolute() && url.isHierarchical()) {
            if (v.charAt(0) === '?') v = v.substring(1);
            v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL3.percentEncode);
            url.query = v;
            output = url.toString();
          }
          this.href = output;
        },
      },
      hash: {
        get: function () {
          var url = this._url;
          if (url == null || url.fragment == null || url.fragment === '') {
            return '';
          } else {
            return '#' + url.fragment;
          }
        },
        set: function (v) {
          var output = this.href;
          var url = new URL3(output);
          if (v.charAt(0) === '#') v = v.substring(1);
          v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL3.percentEncode);
          url.fragment = v;
          output = url.toString();
          this.href = output;
        },
      },
      username: {
        get: function () {
          var url = this._url;
          return url.username || '';
        },
        set: function (v) {
          var output = this.href;
          var url = new URL3(output);
          if (url.isAbsolute()) {
            v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\:]/g, URL3.percentEncode);
            url.username = v;
            output = url.toString();
          }
          this.href = output;
        },
      },
      password: {
        get: function () {
          var url = this._url;
          return url.password || '';
        },
        set: function (v) {
          var output = this.href;
          var url = new URL3(output);
          if (url.isAbsolute()) {
            if (v === '') {
              url.password = null;
            } else {
              v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\]/g, URL3.percentEncode);
              url.password = v;
            }
            output = url.toString();
          }
          this.href = output;
        },
      },
      origin: {
        get: function () {
          var url = this._url;
          if (url == null) {
            return '';
          }
          var originForPort = function (defaultPort) {
            var origin = [url.scheme, url.host, +url.port || defaultPort];
            return origin[0] + '://' + origin[1] + (origin[2] === defaultPort ? '' : ':' + origin[2]);
          };
          switch (url.scheme) {
            case 'ftp':
              return originForPort(21);
            case 'gopher':
              return originForPort(70);
            case 'http':
            case 'ws':
              return originForPort(80);
            case 'https':
            case 'wss':
              return originForPort(443);
            default:
              return url.scheme + '://';
          }
        },
      },
      /*
      searchParams: {
        get: function() {
          var url = this._url;
          // XXX
        },
        set: function(v) {
          var output = this.href;
          var url = new URL(output);
          // XXX
          this.href = output;
        },
      },
      */
    });
    URLUtils._inherit = function (proto2) {
      Object.getOwnPropertyNames(URLUtils.prototype).forEach(function (p) {
        if (p === 'constructor' || p === 'href') {
          return;
        }
        var desc = Object.getOwnPropertyDescriptor(URLUtils.prototype, p);
        Object.defineProperty(proto2, p, desc);
      });
    };
  },
});

// node_modules/@mixmark-io/domino/lib/defineElement.js
var require_defineElement = __commonJS({
  'node_modules/@mixmark-io/domino/lib/defineElement.js'(exports2, module2) {
    'use strict';
    var attributes = require_attributes();
    var isApiWritable = require_config().isApiWritable;
    module2.exports = function (spec, defaultConstructor, tagList, tagNameToImpl) {
      var c = spec.ctor;
      if (c) {
        var props = spec.props || {};
        if (spec.attributes) {
          for (var n in spec.attributes) {
            var attr = spec.attributes[n];
            if (typeof attr !== 'object' || Array.isArray(attr)) attr = { type: attr };
            if (!attr.name) attr.name = n.toLowerCase();
            props[n] = attributes.property(attr);
          }
        }
        props.constructor = { value: c, writable: isApiWritable };
        c.prototype = Object.create((spec.superclass || defaultConstructor).prototype, props);
        if (spec.events) {
          addEventHandlers(c, spec.events);
        }
        tagList[spec.name] = c;
      } else {
        c = defaultConstructor;
      }
      (spec.tags || (spec.tag && [spec.tag]) || []).forEach(function (tag) {
        tagNameToImpl[tag] = c;
      });
      return c;
    };
    function EventHandlerBuilder(body, document, form, element) {
      this.body = body;
      this.document = document;
      this.form = form;
      this.element = element;
    }
    EventHandlerBuilder.prototype.build = function () {
      return () => {};
    };
    function EventHandlerChangeHandler(elt, name, oldval, newval) {
      var doc = elt.ownerDocument || /* @__PURE__ */ Object.create(null);
      var form = elt.form || /* @__PURE__ */ Object.create(null);
      elt[name] = new EventHandlerBuilder(newval, doc, form, elt).build();
    }
    function addEventHandlers(c, eventHandlerTypes) {
      var p = c.prototype;
      eventHandlerTypes.forEach(function (type) {
        Object.defineProperty(p, 'on' + type, {
          get: function () {
            return this._getEventHandler(type);
          },
          set: function (v) {
            this._setEventHandler(type, v);
          },
        });
        attributes.registerChangeHandler(c, 'on' + type, EventHandlerChangeHandler);
      });
    }
  },
});

// node_modules/@mixmark-io/domino/lib/htmlelts.js
var require_htmlelts = __commonJS({
  'node_modules/@mixmark-io/domino/lib/htmlelts.js'(exports2) {
    'use strict';
    var Node = require_Node();
    var Element = require_Element();
    var CSSStyleDeclaration = require_CSSStyleDeclaration();
    var utils = require_utils2();
    var URLUtils = require_URLUtils();
    var defineElement = require_defineElement();
    var htmlElements = (exports2.elements = {});
    var htmlNameToImpl = /* @__PURE__ */ Object.create(null);
    exports2.createElement = function (doc, localName, prefix) {
      var impl = htmlNameToImpl[localName] || HTMLUnknownElement;
      return new impl(doc, localName, prefix);
    };
    function define(spec) {
      return defineElement(spec, HTMLElement, htmlElements, htmlNameToImpl);
    }
    function URL3(attr) {
      return {
        get: function () {
          var v = this._getattr(attr);
          if (v === null) {
            return '';
          }
          var url = this.doc._resolve(v);
          return url === null ? v : url;
        },
        set: function (value) {
          this._setattr(attr, value);
        },
      };
    }
    function CORS(attr) {
      return {
        get: function () {
          var v = this._getattr(attr);
          if (v === null) {
            return null;
          }
          if (v.toLowerCase() === 'use-credentials') {
            return 'use-credentials';
          }
          return 'anonymous';
        },
        set: function (value) {
          if (value === null || value === void 0) {
            this.removeAttribute(attr);
          } else {
            this._setattr(attr, value);
          }
        },
      };
    }
    var REFERRER = {
      type: [
        '',
        'no-referrer',
        'no-referrer-when-downgrade',
        'same-origin',
        'origin',
        'strict-origin',
        'origin-when-cross-origin',
        'strict-origin-when-cross-origin',
        'unsafe-url',
      ],
      missing: '',
    };
    var focusableElements = {
      A: true,
      LINK: true,
      BUTTON: true,
      INPUT: true,
      SELECT: true,
      TEXTAREA: true,
      COMMAND: true,
    };
    var HTMLFormElement = function (doc, localName, prefix) {
      HTMLElement.call(this, doc, localName, prefix);
      this._form = null;
    };
    var HTMLElement = (exports2.HTMLElement = define({
      superclass: Element,
      name: 'HTMLElement',
      ctor: function HTMLElement2(doc, localName, prefix) {
        Element.call(this, doc, localName, utils.NAMESPACE.HTML, prefix);
      },
      props: {
        dangerouslySetInnerHTML: {
          set: function (v) {
            this._innerHTML = v;
          },
        },
        innerHTML: {
          get: function () {
            return this.serialize();
          },
          set: function (v) {
            var parser = this.ownerDocument.implementation.mozHTMLParser(this.ownerDocument._address, this);
            parser.parse(v === null ? '' : String(v), true);
            var target = this instanceof htmlNameToImpl.template ? this.content : this;
            while (target.hasChildNodes()) target.removeChild(target.firstChild);
            target.appendChild(parser._asDocumentFragment());
          },
        },
        style: {
          get: function () {
            if (!this._style) this._style = new CSSStyleDeclaration(this);
            return this._style;
          },
          set: function (v) {
            if (v === null || v === void 0) {
              v = '';
            }
            this._setattr('style', String(v));
          },
        },
        // These can't really be implemented server-side in a reasonable way.
        blur: { value: function () {} },
        focus: { value: function () {} },
        forceSpellCheck: { value: function () {} },
        click: {
          value: function () {
            if (this._click_in_progress) return;
            this._click_in_progress = true;
            try {
              if (this._pre_click_activation_steps) this._pre_click_activation_steps();
              var event = this.ownerDocument.createEvent('MouseEvent');
              event.initMouseEvent(
                'click',
                true,
                true,
                this.ownerDocument.defaultView,
                1,
                0,
                0,
                0,
                0,
                // These 4 should be initialized with
                // the actually current keyboard state
                // somehow...
                false,
                false,
                false,
                false,
                0,
                null,
              );
              var success = this.dispatchEvent(event);
              if (success) {
                if (this._post_click_activation_steps) this._post_click_activation_steps(event);
              } else {
                if (this._cancelled_activation_steps) this._cancelled_activation_steps();
              }
            } finally {
              this._click_in_progress = false;
            }
          },
        },
        submit: { value: utils.nyi },
      },
      attributes: {
        title: String,
        lang: String,
        dir: { type: ['ltr', 'rtl', 'auto'], missing: '' },
        draggable: { type: ['true', 'false'], treatNullAsEmptyString: true },
        spellcheck: { type: ['true', 'false'], missing: '' },
        enterKeyHint: { type: ['enter', 'done', 'go', 'next', 'previous', 'search', 'send'], missing: '' },
        autoCapitalize: { type: ['off', 'on', 'none', 'sentences', 'words', 'characters'], missing: '' },
        autoFocus: Boolean,
        accessKey: String,
        nonce: String,
        hidden: Boolean,
        translate: { type: ['no', 'yes'], missing: '' },
        tabIndex: {
          type: 'long',
          default: function () {
            if (this.tagName in focusableElements || this.contentEditable) return 0;
            else return -1;
          },
        },
      },
      events: [
        'abort',
        'canplay',
        'canplaythrough',
        'change',
        'click',
        'contextmenu',
        'cuechange',
        'dblclick',
        'drag',
        'dragend',
        'dragenter',
        'dragleave',
        'dragover',
        'dragstart',
        'drop',
        'durationchange',
        'emptied',
        'ended',
        'input',
        'invalid',
        'keydown',
        'keypress',
        'keyup',
        'loadeddata',
        'loadedmetadata',
        'loadstart',
        'mousedown',
        'mousemove',
        'mouseout',
        'mouseover',
        'mouseup',
        'mousewheel',
        'pause',
        'play',
        'playing',
        'progress',
        'ratechange',
        'readystatechange',
        'reset',
        'seeked',
        'seeking',
        'select',
        'show',
        'stalled',
        'submit',
        'suspend',
        'timeupdate',
        'volumechange',
        'waiting',
        // These last 5 event types will be overriden by HTMLBodyElement
        'blur',
        'error',
        'focus',
        'load',
        'scroll',
      ],
    }));
    var HTMLUnknownElement = define({
      name: 'HTMLUnknownElement',
      ctor: function HTMLUnknownElement2(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
    });
    var formAssociatedProps = {
      // See http://www.w3.org/TR/html5/association-of-controls-and-forms.html#form-owner
      form: {
        get: function () {
          return this._form;
        },
      },
    };
    define({
      tag: 'a',
      name: 'HTMLAnchorElement',
      ctor: function HTMLAnchorElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      props: {
        _post_click_activation_steps: {
          value: function (e) {
            if (this.href) {
              this.ownerDocument.defaultView.location = this.href;
            }
          },
        },
      },
      attributes: {
        href: URL3,
        ping: String,
        download: String,
        target: String,
        rel: String,
        media: String,
        hreflang: String,
        type: String,
        referrerPolicy: REFERRER,
        // Obsolete
        coords: String,
        charset: String,
        name: String,
        rev: String,
        shape: String,
      },
    });
    URLUtils._inherit(htmlNameToImpl.a.prototype);
    define({
      tag: 'area',
      name: 'HTMLAreaElement',
      ctor: function HTMLAreaElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        alt: String,
        target: String,
        download: String,
        rel: String,
        media: String,
        href: URL3,
        hreflang: String,
        type: String,
        shape: String,
        coords: String,
        ping: String,
        // XXX: also reflect relList
        referrerPolicy: REFERRER,
        // Obsolete
        noHref: Boolean,
      },
    });
    URLUtils._inherit(htmlNameToImpl.area.prototype);
    define({
      tag: 'br',
      name: 'HTMLBRElement',
      ctor: function HTMLBRElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        // Obsolete
        clear: String,
      },
    });
    define({
      tag: 'base',
      name: 'HTMLBaseElement',
      ctor: function HTMLBaseElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        target: String,
      },
    });
    define({
      tag: 'body',
      name: 'HTMLBodyElement',
      ctor: function HTMLBodyElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      // Certain event handler attributes on a <body> tag actually set
      // handlers for the window rather than just that element.  Define
      // getters and setters for those here.  Note that some of these override
      // properties on HTMLElement.prototype.
      // XXX: If I add support for <frameset>, these have to go there, too
      // XXX
      // When the Window object is implemented, these attribute will have
      // to work with the same-named attributes on the Window.
      events: [
        'afterprint',
        'beforeprint',
        'beforeunload',
        'blur',
        'error',
        'focus',
        'hashchange',
        'load',
        'message',
        'offline',
        'online',
        'pagehide',
        'pageshow',
        'popstate',
        'resize',
        'scroll',
        'storage',
        'unload',
      ],
      attributes: {
        // Obsolete
        text: { type: String, treatNullAsEmptyString: true },
        link: { type: String, treatNullAsEmptyString: true },
        vLink: { type: String, treatNullAsEmptyString: true },
        aLink: { type: String, treatNullAsEmptyString: true },
        bgColor: { type: String, treatNullAsEmptyString: true },
        background: String,
      },
    });
    define({
      tag: 'button',
      name: 'HTMLButtonElement',
      ctor: function HTMLButtonElement(doc, localName, prefix) {
        HTMLFormElement.call(this, doc, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        name: String,
        value: String,
        disabled: Boolean,
        autofocus: Boolean,
        type: { type: ['submit', 'reset', 'button', 'menu'], missing: 'submit' },
        formTarget: String,
        formAction: URL3,
        formNoValidate: Boolean,
        formMethod: { type: ['get', 'post', 'dialog'], invalid: 'get', missing: '' },
        formEnctype: {
          type: ['application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain'],
          invalid: 'application/x-www-form-urlencoded',
          missing: '',
        },
      },
    });
    define({
      tag: 'dl',
      name: 'HTMLDListElement',
      ctor: function HTMLDListElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        // Obsolete
        compact: Boolean,
      },
    });
    define({
      tag: 'data',
      name: 'HTMLDataElement',
      ctor: function HTMLDataElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        value: String,
      },
    });
    define({
      tag: 'datalist',
      name: 'HTMLDataListElement',
      ctor: function HTMLDataListElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
    });
    define({
      tag: 'details',
      name: 'HTMLDetailsElement',
      ctor: function HTMLDetailsElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        open: Boolean,
      },
    });
    define({
      tag: 'div',
      name: 'HTMLDivElement',
      ctor: function HTMLDivElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String,
      },
    });
    define({
      tag: 'embed',
      name: 'HTMLEmbedElement',
      ctor: function HTMLEmbedElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        src: URL3,
        type: String,
        width: String,
        height: String,
        // Obsolete
        align: String,
        name: String,
      },
    });
    define({
      tag: 'fieldset',
      name: 'HTMLFieldSetElement',
      ctor: function HTMLFieldSetElement(doc, localName, prefix) {
        HTMLFormElement.call(this, doc, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        disabled: Boolean,
        name: String,
      },
    });
    define({
      tag: 'form',
      name: 'HTMLFormElement',
      ctor: function HTMLFormElement2(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        action: String,
        autocomplete: { type: ['on', 'off'], missing: 'on' },
        name: String,
        acceptCharset: { name: 'accept-charset' },
        target: String,
        noValidate: Boolean,
        method: { type: ['get', 'post', 'dialog'], invalid: 'get', missing: 'get' },
        // Both enctype and encoding reflect the enctype content attribute
        enctype: {
          type: ['application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain'],
          invalid: 'application/x-www-form-urlencoded',
          missing: 'application/x-www-form-urlencoded',
        },
        encoding: {
          name: 'enctype',
          type: ['application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain'],
          invalid: 'application/x-www-form-urlencoded',
          missing: 'application/x-www-form-urlencoded',
        },
      },
    });
    define({
      tag: 'hr',
      name: 'HTMLHRElement',
      ctor: function HTMLHRElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String,
        color: String,
        noShade: Boolean,
        size: String,
        width: String,
      },
    });
    define({
      tag: 'head',
      name: 'HTMLHeadElement',
      ctor: function HTMLHeadElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
    });
    define({
      tags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
      name: 'HTMLHeadingElement',
      ctor: function HTMLHeadingElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String,
      },
    });
    define({
      tag: 'html',
      name: 'HTMLHtmlElement',
      ctor: function HTMLHtmlElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        xmlns: URL3,
        // Obsolete
        version: String,
      },
    });
    define({
      tag: 'iframe',
      name: 'HTMLIFrameElement',
      ctor: function HTMLIFrameElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        src: URL3,
        srcdoc: String,
        name: String,
        width: String,
        height: String,
        // XXX: sandbox is a reflected settable token list
        seamless: Boolean,
        allow: Boolean,
        allowFullscreen: Boolean,
        allowUserMedia: Boolean,
        allowPaymentRequest: Boolean,
        referrerPolicy: REFERRER,
        loading: { type: ['eager', 'lazy'], treatNullAsEmptyString: true },
        // Obsolete
        align: String,
        scrolling: String,
        frameBorder: String,
        longDesc: URL3,
        marginHeight: { type: String, treatNullAsEmptyString: true },
        marginWidth: { type: String, treatNullAsEmptyString: true },
      },
    });
    define({
      tag: 'img',
      name: 'HTMLImageElement',
      ctor: function HTMLImageElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        alt: String,
        src: URL3,
        srcset: String,
        crossOrigin: CORS,
        useMap: String,
        isMap: Boolean,
        sizes: String,
        height: { type: 'unsigned long', default: 0 },
        width: { type: 'unsigned long', default: 0 },
        referrerPolicy: REFERRER,
        loading: { type: ['eager', 'lazy'], missing: '' },
        // Obsolete:
        name: String,
        lowsrc: URL3,
        align: String,
        hspace: { type: 'unsigned long', default: 0 },
        vspace: { type: 'unsigned long', default: 0 },
        longDesc: URL3,
        border: { type: String, treatNullAsEmptyString: true },
      },
    });
    define({
      tag: 'input',
      name: 'HTMLInputElement',
      ctor: function HTMLInputElement(doc, localName, prefix) {
        HTMLFormElement.call(this, doc, localName, prefix);
      },
      props: {
        form: formAssociatedProps.form,
        _post_click_activation_steps: {
          value: function (e) {
            if (this.type === 'checkbox') {
              this.checked = !this.checked;
            } else if (this.type === 'radio') {
              var group = this.form.getElementsByName(this.name);
              for (var i = group.length - 1; i >= 0; i--) {
                var el = group[i];
                el.checked = el === this;
              }
            }
          },
        },
      },
      attributes: {
        name: String,
        disabled: Boolean,
        autofocus: Boolean,
        accept: String,
        alt: String,
        max: String,
        min: String,
        pattern: String,
        placeholder: String,
        step: String,
        dirName: String,
        defaultValue: { name: 'value' },
        multiple: Boolean,
        required: Boolean,
        readOnly: Boolean,
        checked: Boolean,
        value: String,
        src: URL3,
        defaultChecked: { name: 'checked', type: Boolean },
        size: { type: 'unsigned long', default: 20, min: 1, setmin: 1 },
        width: { type: 'unsigned long', min: 0, setmin: 0, default: 0 },
        height: { type: 'unsigned long', min: 0, setmin: 0, default: 0 },
        minLength: { type: 'unsigned long', min: 0, setmin: 0, default: -1 },
        maxLength: { type: 'unsigned long', min: 0, setmin: 0, default: -1 },
        autocomplete: String,
        // It's complicated
        type: {
          type: [
            'text',
            'hidden',
            'search',
            'tel',
            'url',
            'email',
            'password',
            'datetime',
            'date',
            'month',
            'week',
            'time',
            'datetime-local',
            'number',
            'range',
            'color',
            'checkbox',
            'radio',
            'file',
            'submit',
            'image',
            'reset',
            'button',
          ],
          missing: 'text',
        },
        formTarget: String,
        formNoValidate: Boolean,
        formMethod: { type: ['get', 'post'], invalid: 'get', missing: '' },
        formEnctype: {
          type: ['application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain'],
          invalid: 'application/x-www-form-urlencoded',
          missing: '',
        },
        inputMode: {
          type: [
            'verbatim',
            'latin',
            'latin-name',
            'latin-prose',
            'full-width-latin',
            'kana',
            'kana-name',
            'katakana',
            'numeric',
            'tel',
            'email',
            'url',
          ],
          missing: '',
        },
        // Obsolete
        align: String,
        useMap: String,
      },
    });
    define({
      tag: 'keygen',
      name: 'HTMLKeygenElement',
      ctor: function HTMLKeygenElement(doc, localName, prefix) {
        HTMLFormElement.call(this, doc, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        name: String,
        disabled: Boolean,
        autofocus: Boolean,
        challenge: String,
        keytype: { type: ['rsa'], missing: '' },
      },
    });
    define({
      tag: 'li',
      name: 'HTMLLIElement',
      ctor: function HTMLLIElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        value: { type: 'long', default: 0 },
        // Obsolete
        type: String,
      },
    });
    define({
      tag: 'label',
      name: 'HTMLLabelElement',
      ctor: function HTMLLabelElement(doc, localName, prefix) {
        HTMLFormElement.call(this, doc, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        htmlFor: { name: 'for', type: String },
      },
    });
    define({
      tag: 'legend',
      name: 'HTMLLegendElement',
      ctor: function HTMLLegendElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String,
      },
    });
    define({
      tag: 'link',
      name: 'HTMLLinkElement',
      ctor: function HTMLLinkElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        // XXX Reflect DOMSettableTokenList sizes also DOMTokenList relList
        href: URL3,
        rel: String,
        media: String,
        hreflang: String,
        type: String,
        crossOrigin: CORS,
        nonce: String,
        integrity: String,
        referrerPolicy: REFERRER,
        imageSizes: String,
        imageSrcset: String,
        // Obsolete
        charset: String,
        rev: String,
        target: String,
      },
    });
    define({
      tag: 'map',
      name: 'HTMLMapElement',
      ctor: function HTMLMapElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        name: String,
      },
    });
    define({
      tag: 'menu',
      name: 'HTMLMenuElement',
      ctor: function HTMLMenuElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        // XXX: not quite right, default should be popup if parent element is
        // popup.
        type: { type: ['context', 'popup', 'toolbar'], missing: 'toolbar' },
        label: String,
        // Obsolete
        compact: Boolean,
      },
    });
    define({
      tag: 'meta',
      name: 'HTMLMetaElement',
      ctor: function HTMLMetaElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        name: String,
        content: String,
        httpEquiv: { name: 'http-equiv', type: String },
        // Obsolete
        scheme: String,
      },
    });
    define({
      tag: 'meter',
      name: 'HTMLMeterElement',
      ctor: function HTMLMeterElement(doc, localName, prefix) {
        HTMLFormElement.call(this, doc, localName, prefix);
      },
      props: formAssociatedProps,
    });
    define({
      tags: ['ins', 'del'],
      name: 'HTMLModElement',
      ctor: function HTMLModElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        cite: URL3,
        dateTime: String,
      },
    });
    define({
      tag: 'ol',
      name: 'HTMLOListElement',
      ctor: function HTMLOListElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      props: {
        // Utility function (see the start attribute default value). Returns
        // the number of <li> children of this element
        _numitems: {
          get: function () {
            var items = 0;
            this.childNodes.forEach(function (n) {
              if (n.nodeType === Node.ELEMENT_NODE && n.tagName === 'LI') items++;
            });
            return items;
          },
        },
      },
      attributes: {
        type: String,
        reversed: Boolean,
        start: {
          type: 'long',
          default: function () {
            if (this.reversed) return this._numitems;
            else return 1;
          },
        },
        // Obsolete
        compact: Boolean,
      },
    });
    define({
      tag: 'object',
      name: 'HTMLObjectElement',
      ctor: function HTMLObjectElement(doc, localName, prefix) {
        HTMLFormElement.call(this, doc, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        data: URL3,
        type: String,
        name: String,
        useMap: String,
        typeMustMatch: Boolean,
        width: String,
        height: String,
        // Obsolete
        align: String,
        archive: String,
        code: String,
        declare: Boolean,
        hspace: { type: 'unsigned long', default: 0 },
        standby: String,
        vspace: { type: 'unsigned long', default: 0 },
        codeBase: URL3,
        codeType: String,
        border: { type: String, treatNullAsEmptyString: true },
      },
    });
    define({
      tag: 'optgroup',
      name: 'HTMLOptGroupElement',
      ctor: function HTMLOptGroupElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        disabled: Boolean,
        label: String,
      },
    });
    define({
      tag: 'option',
      name: 'HTMLOptionElement',
      ctor: function HTMLOptionElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      props: {
        form: {
          get: function () {
            var p = this.parentNode;
            while (p && p.nodeType === Node.ELEMENT_NODE) {
              if (p.localName === 'select') return p.form;
              p = p.parentNode;
            }
          },
        },
        value: {
          get: function () {
            return this._getattr('value') || this.text;
          },
          set: function (v) {
            this._setattr('value', v);
          },
        },
        text: {
          get: function () {
            return this.textContent.replace(/[ \t\n\f\r]+/g, ' ').trim();
          },
          set: function (v) {
            this.textContent = v;
          },
        },
        // missing: index
      },
      attributes: {
        disabled: Boolean,
        defaultSelected: { name: 'selected', type: Boolean },
        label: String,
      },
    });
    define({
      tag: 'output',
      name: 'HTMLOutputElement',
      ctor: function HTMLOutputElement(doc, localName, prefix) {
        HTMLFormElement.call(this, doc, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        // XXX Reflect for/htmlFor as a settable token list
        name: String,
      },
    });
    define({
      tag: 'p',
      name: 'HTMLParagraphElement',
      ctor: function HTMLParagraphElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String,
      },
    });
    define({
      tag: 'param',
      name: 'HTMLParamElement',
      ctor: function HTMLParamElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        name: String,
        value: String,
        // Obsolete
        type: String,
        valueType: String,
      },
    });
    define({
      tags: [
        'pre',
        /*legacy elements:*/
        'listing',
        'xmp',
      ],
      name: 'HTMLPreElement',
      ctor: function HTMLPreElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        // Obsolete
        width: { type: 'long', default: 0 },
      },
    });
    define({
      tag: 'progress',
      name: 'HTMLProgressElement',
      ctor: function HTMLProgressElement(doc, localName, prefix) {
        HTMLFormElement.call(this, doc, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        max: { type: Number, float: true, default: 1, min: 0 },
      },
    });
    define({
      tags: ['q', 'blockquote'],
      name: 'HTMLQuoteElement',
      ctor: function HTMLQuoteElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        cite: URL3,
      },
    });
    define({
      tag: 'script',
      name: 'HTMLScriptElement',
      ctor: function HTMLScriptElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      props: {
        text: {
          get: function () {
            var s = '';
            for (var i = 0, n = this.childNodes.length; i < n; i++) {
              var child = this.childNodes[i];
              if (child.nodeType === Node.TEXT_NODE) s += child._data;
            }
            return s;
          },
          set: function (value) {
            this.removeChildren();
            if (value !== null && value !== '') {
              this.appendChild(this.ownerDocument.createTextNode(value));
            }
          },
        },
      },
      attributes: {
        src: URL3,
        type: String,
        charset: String,
        referrerPolicy: REFERRER,
        defer: Boolean,
        async: Boolean,
        nomodule: Boolean,
        crossOrigin: CORS,
        nonce: String,
        integrity: String,
      },
    });
    define({
      tag: 'select',
      name: 'HTMLSelectElement',
      ctor: function HTMLSelectElement(doc, localName, prefix) {
        HTMLFormElement.call(this, doc, localName, prefix);
      },
      props: {
        form: formAssociatedProps.form,
        options: {
          get: function () {
            return this.getElementsByTagName('option');
          },
        },
      },
      attributes: {
        autocomplete: String,
        // It's complicated
        name: String,
        disabled: Boolean,
        autofocus: Boolean,
        multiple: Boolean,
        required: Boolean,
        size: { type: 'unsigned long', default: 0 },
      },
    });
    define({
      tag: 'span',
      name: 'HTMLSpanElement',
      ctor: function HTMLSpanElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
    });
    define({
      tag: 'style',
      name: 'HTMLStyleElement',
      ctor: function HTMLStyleElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        media: String,
        type: String,
        scoped: Boolean,
      },
    });
    define({
      tag: 'caption',
      name: 'HTMLTableCaptionElement',
      ctor: function HTMLTableCaptionElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String,
      },
    });
    define({
      name: 'HTMLTableCellElement',
      ctor: function HTMLTableCellElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        colSpan: { type: 'unsigned long', default: 1 },
        rowSpan: { type: 'unsigned long', default: 1 },
        //XXX Also reflect settable token list headers
        scope: { type: ['row', 'col', 'rowgroup', 'colgroup'], missing: '' },
        abbr: String,
        // Obsolete
        align: String,
        axis: String,
        height: String,
        width: String,
        ch: { name: 'char', type: String },
        chOff: { name: 'charoff', type: String },
        noWrap: Boolean,
        vAlign: String,
        bgColor: { type: String, treatNullAsEmptyString: true },
      },
    });
    define({
      tags: ['col', 'colgroup'],
      name: 'HTMLTableColElement',
      ctor: function HTMLTableColElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        span: { type: 'limited unsigned long with fallback', default: 1, min: 1 },
        // Obsolete
        align: String,
        ch: { name: 'char', type: String },
        chOff: { name: 'charoff', type: String },
        vAlign: String,
        width: String,
      },
    });
    define({
      tag: 'table',
      name: 'HTMLTableElement',
      ctor: function HTMLTableElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      props: {
        rows: {
          get: function () {
            return this.getElementsByTagName('tr');
          },
        },
      },
      attributes: {
        // Obsolete
        align: String,
        border: String,
        frame: String,
        rules: String,
        summary: String,
        width: String,
        bgColor: { type: String, treatNullAsEmptyString: true },
        cellPadding: { type: String, treatNullAsEmptyString: true },
        cellSpacing: { type: String, treatNullAsEmptyString: true },
      },
    });
    define({
      tag: 'template',
      name: 'HTMLTemplateElement',
      ctor: function HTMLTemplateElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
        this._contentFragment = doc._templateDoc.createDocumentFragment();
      },
      props: {
        content: {
          get: function () {
            return this._contentFragment;
          },
        },
        serialize: {
          value: function () {
            return this.content.serialize();
          },
        },
      },
    });
    define({
      tag: 'tr',
      name: 'HTMLTableRowElement',
      ctor: function HTMLTableRowElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      props: {
        cells: {
          get: function () {
            return this.querySelectorAll('td,th');
          },
        },
      },
      attributes: {
        // Obsolete
        align: String,
        ch: { name: 'char', type: String },
        chOff: { name: 'charoff', type: String },
        vAlign: String,
        bgColor: { type: String, treatNullAsEmptyString: true },
      },
    });
    define({
      tags: ['thead', 'tfoot', 'tbody'],
      name: 'HTMLTableSectionElement',
      ctor: function HTMLTableSectionElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      props: {
        rows: {
          get: function () {
            return this.getElementsByTagName('tr');
          },
        },
      },
      attributes: {
        // Obsolete
        align: String,
        ch: { name: 'char', type: String },
        chOff: { name: 'charoff', type: String },
        vAlign: String,
      },
    });
    define({
      tag: 'textarea',
      name: 'HTMLTextAreaElement',
      ctor: function HTMLTextAreaElement(doc, localName, prefix) {
        HTMLFormElement.call(this, doc, localName, prefix);
      },
      props: {
        form: formAssociatedProps.form,
        type: {
          get: function () {
            return 'textarea';
          },
        },
        defaultValue: {
          get: function () {
            return this.textContent;
          },
          set: function (v) {
            this.textContent = v;
          },
        },
        value: {
          get: function () {
            return this.defaultValue;
          },
          set: function (v) {
            this.defaultValue = v;
          },
        },
        textLength: {
          get: function () {
            return this.value.length;
          },
        },
      },
      attributes: {
        autocomplete: String,
        // It's complicated
        name: String,
        disabled: Boolean,
        autofocus: Boolean,
        placeholder: String,
        wrap: String,
        dirName: String,
        required: Boolean,
        readOnly: Boolean,
        rows: { type: 'limited unsigned long with fallback', default: 2 },
        cols: { type: 'limited unsigned long with fallback', default: 20 },
        maxLength: { type: 'unsigned long', min: 0, setmin: 0, default: -1 },
        minLength: { type: 'unsigned long', min: 0, setmin: 0, default: -1 },
        inputMode: {
          type: [
            'verbatim',
            'latin',
            'latin-name',
            'latin-prose',
            'full-width-latin',
            'kana',
            'kana-name',
            'katakana',
            'numeric',
            'tel',
            'email',
            'url',
          ],
          missing: '',
        },
      },
    });
    define({
      tag: 'time',
      name: 'HTMLTimeElement',
      ctor: function HTMLTimeElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        dateTime: String,
        pubDate: Boolean,
      },
    });
    define({
      tag: 'title',
      name: 'HTMLTitleElement',
      ctor: function HTMLTitleElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      props: {
        text: {
          get: function () {
            return this.textContent;
          },
        },
      },
    });
    define({
      tag: 'ul',
      name: 'HTMLUListElement',
      ctor: function HTMLUListElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        type: String,
        // Obsolete
        compact: Boolean,
      },
    });
    define({
      name: 'HTMLMediaElement',
      ctor: function HTMLMediaElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        src: URL3,
        crossOrigin: CORS,
        preload: { type: ['metadata', 'none', 'auto', { value: '', alias: 'auto' }], missing: 'auto' },
        loop: Boolean,
        autoplay: Boolean,
        mediaGroup: String,
        controls: Boolean,
        defaultMuted: { name: 'muted', type: Boolean },
      },
    });
    define({
      name: 'HTMLAudioElement',
      tag: 'audio',
      superclass: htmlElements.HTMLMediaElement,
      ctor: function HTMLAudioElement(doc, localName, prefix) {
        htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
      },
    });
    define({
      name: 'HTMLVideoElement',
      tag: 'video',
      superclass: htmlElements.HTMLMediaElement,
      ctor: function HTMLVideoElement(doc, localName, prefix) {
        htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
      },
      attributes: {
        poster: URL3,
        width: { type: 'unsigned long', min: 0, default: 0 },
        height: { type: 'unsigned long', min: 0, default: 0 },
      },
    });
    define({
      tag: 'td',
      name: 'HTMLTableDataCellElement',
      superclass: htmlElements.HTMLTableCellElement,
      ctor: function HTMLTableDataCellElement(doc, localName, prefix) {
        htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
      },
    });
    define({
      tag: 'th',
      name: 'HTMLTableHeaderCellElement',
      superclass: htmlElements.HTMLTableCellElement,
      ctor: function HTMLTableHeaderCellElement(doc, localName, prefix) {
        htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
      },
    });
    define({
      tag: 'frameset',
      name: 'HTMLFrameSetElement',
      ctor: function HTMLFrameSetElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
    });
    define({
      tag: 'frame',
      name: 'HTMLFrameElement',
      ctor: function HTMLFrameElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
    });
    define({
      tag: 'canvas',
      name: 'HTMLCanvasElement',
      ctor: function HTMLCanvasElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      props: {
        getContext: { value: utils.nyi },
        probablySupportsContext: { value: utils.nyi },
        setContext: { value: utils.nyi },
        transferControlToProxy: { value: utils.nyi },
        toDataURL: { value: utils.nyi },
        toBlob: { value: utils.nyi },
      },
      attributes: {
        width: { type: 'unsigned long', default: 300 },
        height: { type: 'unsigned long', default: 150 },
      },
    });
    define({
      tag: 'dialog',
      name: 'HTMLDialogElement',
      ctor: function HTMLDialogElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      props: {
        show: { value: utils.nyi },
        showModal: { value: utils.nyi },
        close: { value: utils.nyi },
      },
      attributes: {
        open: Boolean,
        returnValue: String,
      },
    });
    define({
      tag: 'menuitem',
      name: 'HTMLMenuItemElement',
      ctor: function HTMLMenuItemElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      props: {
        // The menuitem's label
        _label: {
          get: function () {
            var val = this._getattr('label');
            if (val !== null && val !== '') {
              return val;
            }
            val = this.textContent;
            return val.replace(/[ \t\n\f\r]+/g, ' ').trim();
          },
        },
        // The menuitem label IDL attribute
        label: {
          get: function () {
            var val = this._getattr('label');
            if (val !== null) {
              return val;
            }
            return this._label;
          },
          set: function (v) {
            this._setattr('label', v);
          },
        },
      },
      attributes: {
        type: { type: ['command', 'checkbox', 'radio'], missing: 'command' },
        icon: URL3,
        disabled: Boolean,
        checked: Boolean,
        radiogroup: String,
        default: Boolean,
      },
    });
    define({
      tag: 'source',
      name: 'HTMLSourceElement',
      ctor: function HTMLSourceElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        srcset: String,
        sizes: String,
        media: String,
        src: URL3,
        type: String,
        width: String,
        height: String,
      },
    });
    define({
      tag: 'track',
      name: 'HTMLTrackElement',
      ctor: function HTMLTrackElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        src: URL3,
        srclang: String,
        label: String,
        default: Boolean,
        kind: {
          type: ['subtitles', 'captions', 'descriptions', 'chapters', 'metadata'],
          missing: 'subtitles',
          invalid: 'metadata',
        },
      },
      props: {
        NONE: {
          get: function () {
            return 0;
          },
        },
        LOADING: {
          get: function () {
            return 1;
          },
        },
        LOADED: {
          get: function () {
            return 2;
          },
        },
        ERROR: {
          get: function () {
            return 3;
          },
        },
        readyState: { get: utils.nyi },
        track: { get: utils.nyi },
      },
    });
    define({
      // obsolete
      tag: 'font',
      name: 'HTMLFontElement',
      ctor: function HTMLFontElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        color: { type: String, treatNullAsEmptyString: true },
        face: { type: String },
        size: { type: String },
      },
    });
    define({
      // obsolete
      tag: 'dir',
      name: 'HTMLDirectoryElement',
      ctor: function HTMLDirectoryElement(doc, localName, prefix) {
        HTMLElement.call(this, doc, localName, prefix);
      },
      attributes: {
        compact: Boolean,
      },
    });
    define({
      tags: [
        'abbr',
        'address',
        'article',
        'aside',
        'b',
        'bdi',
        'bdo',
        'cite',
        'content',
        'code',
        'dd',
        'dfn',
        'dt',
        'em',
        'figcaption',
        'figure',
        'footer',
        'header',
        'hgroup',
        'i',
        'kbd',
        'main',
        'mark',
        'nav',
        'noscript',
        'rb',
        'rp',
        'rt',
        'rtc',
        'ruby',
        's',
        'samp',
        'section',
        'small',
        'strong',
        'sub',
        'summary',
        'sup',
        'u',
        'var',
        'wbr',
        // Legacy elements
        'acronym',
        'basefont',
        'big',
        'center',
        'nobr',
        'noembed',
        'noframes',
        'plaintext',
        'strike',
        'tt',
      ],
    });
  },
});

// node_modules/@mixmark-io/domino/lib/svg.js
var require_svg = __commonJS({
  'node_modules/@mixmark-io/domino/lib/svg.js'(exports2) {
    'use strict';
    var Element = require_Element();
    var defineElement = require_defineElement();
    var utils = require_utils2();
    var CSSStyleDeclaration = require_CSSStyleDeclaration();
    var svgElements = (exports2.elements = {});
    var svgNameToImpl = /* @__PURE__ */ Object.create(null);
    exports2.createElement = function (doc, localName, prefix) {
      var impl = svgNameToImpl[localName] || SVGElement;
      return new impl(doc, localName, prefix);
    };
    function define(spec) {
      return defineElement(spec, SVGElement, svgElements, svgNameToImpl);
    }
    var SVGElement = define({
      superclass: Element,
      name: 'SVGElement',
      ctor: function SVGElement2(doc, localName, prefix) {
        Element.call(this, doc, localName, utils.NAMESPACE.SVG, prefix);
      },
      props: {
        style: {
          get: function () {
            if (!this._style) this._style = new CSSStyleDeclaration(this);
            return this._style;
          },
        },
      },
    });
    define({
      name: 'SVGSVGElement',
      ctor: function SVGSVGElement(doc, localName, prefix) {
        SVGElement.call(this, doc, localName, prefix);
      },
      tag: 'svg',
      props: {
        createSVGRect: {
          value: function () {
            return exports2.createElement(this.ownerDocument, 'rect', null);
          },
        },
      },
    });
    define({
      tags: [
        'a',
        'altGlyph',
        'altGlyphDef',
        'altGlyphItem',
        'animate',
        'animateColor',
        'animateMotion',
        'animateTransform',
        'circle',
        'clipPath',
        'color-profile',
        'cursor',
        'defs',
        'desc',
        'ellipse',
        'feBlend',
        'feColorMatrix',
        'feComponentTransfer',
        'feComposite',
        'feConvolveMatrix',
        'feDiffuseLighting',
        'feDisplacementMap',
        'feDistantLight',
        'feFlood',
        'feFuncA',
        'feFuncB',
        'feFuncG',
        'feFuncR',
        'feGaussianBlur',
        'feImage',
        'feMerge',
        'feMergeNode',
        'feMorphology',
        'feOffset',
        'fePointLight',
        'feSpecularLighting',
        'feSpotLight',
        'feTile',
        'feTurbulence',
        'filter',
        'font',
        'font-face',
        'font-face-format',
        'font-face-name',
        'font-face-src',
        'font-face-uri',
        'foreignObject',
        'g',
        'glyph',
        'glyphRef',
        'hkern',
        'image',
        'line',
        'linearGradient',
        'marker',
        'mask',
        'metadata',
        'missing-glyph',
        'mpath',
        'path',
        'pattern',
        'polygon',
        'polyline',
        'radialGradient',
        'rect',
        'script',
        'set',
        'stop',
        'style',
        'switch',
        'symbol',
        'text',
        'textPath',
        'title',
        'tref',
        'tspan',
        'use',
        'view',
        'vkern',
      ],
    });
  },
});

// node_modules/@mixmark-io/domino/lib/MutationConstants.js
var require_MutationConstants = __commonJS({
  'node_modules/@mixmark-io/domino/lib/MutationConstants.js'(exports2, module2) {
    'use strict';
    module2.exports = {
      VALUE: 1,
      // The value of a Text, Comment or PI node changed
      ATTR: 2,
      // A new attribute was added or an attribute value and/or prefix changed
      REMOVE_ATTR: 3,
      // An attribute was removed
      REMOVE: 4,
      // A node was removed
      MOVE: 5,
      // A node was moved
      INSERT: 6,
      // A node (or a subtree of nodes) was inserted
    };
  },
});

// node_modules/@mixmark-io/domino/lib/Document.js
var require_Document = __commonJS({
  'node_modules/@mixmark-io/domino/lib/Document.js'(exports2, module2) {
    'use strict';
    module2.exports = Document;
    var Node = require_Node();
    var NodeList = require_NodeList();
    var ContainerNode = require_ContainerNode();
    var Element = require_Element();
    var Text = require_Text();
    var Comment = require_Comment();
    var Event = require_Event();
    var DocumentFragment = require_DocumentFragment();
    var ProcessingInstruction = require_ProcessingInstruction();
    var DOMImplementation = require_DOMImplementation();
    var TreeWalker = require_TreeWalker();
    var NodeIterator = require_NodeIterator();
    var NodeFilter = require_NodeFilter();
    var URL3 = require_URL();
    var select = require_select();
    var events = require_events();
    var xml = require_xmlnames();
    var html = require_htmlelts();
    var svg = require_svg();
    var utils = require_utils2();
    var MUTATE = require_MutationConstants();
    var NAMESPACE = utils.NAMESPACE;
    var isApiWritable = require_config().isApiWritable;
    function Document(isHTML, address) {
      ContainerNode.call(this);
      this.nodeType = Node.DOCUMENT_NODE;
      this.isHTML = isHTML;
      this._address = address || 'about:blank';
      this.readyState = 'loading';
      this.implementation = new DOMImplementation(this);
      this.ownerDocument = null;
      this._contentType = isHTML ? 'text/html' : 'application/xml';
      this.doctype = null;
      this.documentElement = null;
      this._templateDocCache = null;
      this._nodeIterators = null;
      this._nid = 1;
      this._nextnid = 2;
      this._nodes = [null, this];
      this.byId = /* @__PURE__ */ Object.create(null);
      this.modclock = 0;
    }
    var supportedEvents = {
      event: 'Event',
      customevent: 'CustomEvent',
      uievent: 'UIEvent',
      mouseevent: 'MouseEvent',
    };
    var replacementEvent = {
      events: 'event',
      htmlevents: 'event',
      mouseevents: 'mouseevent',
      mutationevents: 'mutationevent',
      uievents: 'uievent',
    };
    var mirrorAttr = function (f, name, defaultValue) {
      return {
        get: function () {
          var o = f.call(this);
          if (o) {
            return o[name];
          }
          return defaultValue;
        },
        set: function (value) {
          var o = f.call(this);
          if (o) {
            o[name] = value;
          }
        },
      };
    };
    function validateAndExtract(namespace, qualifiedName) {
      var prefix, localName, pos;
      if (namespace === '') {
        namespace = null;
      }
      if (!xml.isValidQName(qualifiedName)) {
        utils.InvalidCharacterError();
      }
      prefix = null;
      localName = qualifiedName;
      pos = qualifiedName.indexOf(':');
      if (pos >= 0) {
        prefix = qualifiedName.substring(0, pos);
        localName = qualifiedName.substring(pos + 1);
      }
      if (prefix !== null && namespace === null) {
        utils.NamespaceError();
      }
      if (prefix === 'xml' && namespace !== NAMESPACE.XML) {
        utils.NamespaceError();
      }
      if ((prefix === 'xmlns' || qualifiedName === 'xmlns') && namespace !== NAMESPACE.XMLNS) {
        utils.NamespaceError();
      }
      if (namespace === NAMESPACE.XMLNS && !(prefix === 'xmlns' || qualifiedName === 'xmlns')) {
        utils.NamespaceError();
      }
      return { namespace, prefix, localName };
    }
    Document.prototype = Object.create(ContainerNode.prototype, {
      // This method allows dom.js to communicate with a renderer
      // that displays the document in some way
      // XXX: I should probably move this to the window object
      _setMutationHandler: {
        value: function (handler2) {
          this.mutationHandler = handler2;
        },
      },
      // This method allows dom.js to receive event notifications
      // from the renderer.
      // XXX: I should probably move this to the window object
      _dispatchRendererEvent: {
        value: function (targetNid, type, details) {
          var target = this._nodes[targetNid];
          if (!target) return;
          target._dispatchEvent(new Event(type, details), true);
        },
      },
      nodeName: { value: '#document' },
      nodeValue: {
        get: function () {
          return null;
        },
        set: function () {},
      },
      // XXX: DOMCore may remove documentURI, so it is NYI for now
      documentURI: {
        get: function () {
          return this._address;
        },
        set: utils.nyi,
      },
      compatMode: {
        get: function () {
          return this._quirks ? 'BackCompat' : 'CSS1Compat';
        },
      },
      createTextNode: {
        value: function (data) {
          return new Text(this, String(data));
        },
      },
      createComment: {
        value: function (data) {
          return new Comment(this, data);
        },
      },
      createDocumentFragment: {
        value: function () {
          return new DocumentFragment(this);
        },
      },
      createProcessingInstruction: {
        value: function (target, data) {
          if (!xml.isValidName(target) || data.indexOf('?>') !== -1) utils.InvalidCharacterError();
          return new ProcessingInstruction(this, target, data);
        },
      },
      createAttribute: {
        value: function (localName) {
          localName = String(localName);
          if (!xml.isValidName(localName)) utils.InvalidCharacterError();
          if (this.isHTML) {
            localName = utils.toASCIILowerCase(localName);
          }
          return new Element._Attr(null, localName, null, null, '');
        },
      },
      createAttributeNS: {
        value: function (namespace, qualifiedName) {
          namespace = namespace === null || namespace === void 0 || namespace === '' ? null : String(namespace);
          qualifiedName = String(qualifiedName);
          var ve = validateAndExtract(namespace, qualifiedName);
          return new Element._Attr(null, ve.localName, ve.prefix, ve.namespace, '');
        },
      },
      createElement: {
        value: function (localName) {
          localName = String(localName);
          if (!xml.isValidName(localName)) utils.InvalidCharacterError();
          if (this.isHTML) {
            if (/[A-Z]/.test(localName)) localName = utils.toASCIILowerCase(localName);
            return html.createElement(this, localName, null);
          } else if (this.contentType === 'application/xhtml+xml') {
            return html.createElement(this, localName, null);
          } else {
            return new Element(this, localName, null, null);
          }
        },
        writable: isApiWritable,
      },
      createElementNS: {
        value: function (namespace, qualifiedName) {
          namespace = namespace === null || namespace === void 0 || namespace === '' ? null : String(namespace);
          qualifiedName = String(qualifiedName);
          var ve = validateAndExtract(namespace, qualifiedName);
          return this._createElementNS(ve.localName, ve.namespace, ve.prefix);
        },
        writable: isApiWritable,
      },
      // This is used directly by HTML parser, which allows it to create
      // elements with localNames containing ':' and non-default namespaces
      _createElementNS: {
        value: function (localName, namespace, prefix) {
          if (namespace === NAMESPACE.HTML) {
            return html.createElement(this, localName, prefix);
          } else if (namespace === NAMESPACE.SVG) {
            return svg.createElement(this, localName, prefix);
          }
          return new Element(this, localName, namespace, prefix);
        },
      },
      createEvent: {
        value: function createEvent(interfaceName) {
          interfaceName = interfaceName.toLowerCase();
          var name = replacementEvent[interfaceName] || interfaceName;
          var constructor = events[supportedEvents[name]];
          if (constructor) {
            var e = new constructor();
            e._initialized = false;
            return e;
          } else {
            utils.NotSupportedError();
          }
        },
      },
      // See: http://www.w3.org/TR/dom/#dom-document-createtreewalker
      createTreeWalker: {
        value: function (root2, whatToShow, filter) {
          if (!root2) {
            throw new TypeError('root argument is required');
          }
          if (!(root2 instanceof Node)) {
            throw new TypeError('root not a node');
          }
          whatToShow = whatToShow === void 0 ? NodeFilter.SHOW_ALL : +whatToShow;
          filter = filter === void 0 ? null : filter;
          return new TreeWalker(root2, whatToShow, filter);
        },
      },
      // See: http://www.w3.org/TR/dom/#dom-document-createnodeiterator
      createNodeIterator: {
        value: function (root2, whatToShow, filter) {
          if (!root2) {
            throw new TypeError('root argument is required');
          }
          if (!(root2 instanceof Node)) {
            throw new TypeError('root not a node');
          }
          whatToShow = whatToShow === void 0 ? NodeFilter.SHOW_ALL : +whatToShow;
          filter = filter === void 0 ? null : filter;
          return new NodeIterator(root2, whatToShow, filter);
        },
      },
      _attachNodeIterator: {
        value: function (ni) {
          if (!this._nodeIterators) {
            this._nodeIterators = [];
          }
          this._nodeIterators.push(ni);
        },
      },
      _detachNodeIterator: {
        value: function (ni) {
          var idx = this._nodeIterators.indexOf(ni);
          this._nodeIterators.splice(idx, 1);
        },
      },
      _preremoveNodeIterators: {
        value: function (toBeRemoved) {
          if (this._nodeIterators) {
            this._nodeIterators.forEach(function (ni) {
              ni._preremove(toBeRemoved);
            });
          }
        },
      },
      // Maintain the documentElement and
      // doctype properties of the document.  Each of the following
      // methods chains to the Node implementation of the method
      // to do the actual inserting, removal or replacement.
      _updateDocTypeElement: {
        value: function _updateDocTypeElement() {
          this.doctype = this.documentElement = null;
          for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
            if (kid.nodeType === Node.DOCUMENT_TYPE_NODE) this.doctype = kid;
            else if (kid.nodeType === Node.ELEMENT_NODE) this.documentElement = kid;
          }
        },
      },
      insertBefore: {
        value: function insertBefore(child, refChild) {
          Node.prototype.insertBefore.call(this, child, refChild);
          this._updateDocTypeElement();
          return child;
        },
      },
      replaceChild: {
        value: function replaceChild(node, child) {
          Node.prototype.replaceChild.call(this, node, child);
          this._updateDocTypeElement();
          return child;
        },
      },
      removeChild: {
        value: function removeChild(child) {
          Node.prototype.removeChild.call(this, child);
          this._updateDocTypeElement();
          return child;
        },
      },
      getElementById: {
        value: function (id) {
          var n = this.byId[id];
          if (!n) return null;
          if (n instanceof MultiId) {
            return n.getFirst();
          }
          return n;
        },
      },
      _hasMultipleElementsWithId: {
        value: function (id) {
          return this.byId[id] instanceof MultiId;
        },
      },
      // Just copy this method from the Element prototype
      getElementsByName: { value: Element.prototype.getElementsByName },
      getElementsByTagName: { value: Element.prototype.getElementsByTagName },
      getElementsByTagNameNS: { value: Element.prototype.getElementsByTagNameNS },
      getElementsByClassName: { value: Element.prototype.getElementsByClassName },
      adoptNode: {
        value: function adoptNode(node) {
          if (node.nodeType === Node.DOCUMENT_NODE) utils.NotSupportedError();
          if (node.nodeType === Node.ATTRIBUTE_NODE) {
            return node;
          }
          if (node.parentNode) node.parentNode.removeChild(node);
          if (node.ownerDocument !== this) recursivelySetOwner(node, this);
          return node;
        },
      },
      importNode: {
        value: function importNode(node, deep) {
          return this.adoptNode(node.cloneNode(deep));
        },
        writable: isApiWritable,
      },
      // The following attributes and methods are from the HTML spec
      origin: {
        get: function origin() {
          return null;
        },
      },
      characterSet: {
        get: function characterSet() {
          return 'UTF-8';
        },
      },
      contentType: {
        get: function contentType() {
          return this._contentType;
        },
      },
      URL: {
        get: function URL4() {
          return this._address;
        },
      },
      domain: { get: utils.nyi, set: utils.nyi },
      referrer: { get: utils.nyi },
      cookie: { get: utils.nyi, set: utils.nyi },
      lastModified: { get: utils.nyi },
      location: {
        get: function () {
          return this.defaultView ? this.defaultView.location : null;
        },
        set: utils.nyi,
      },
      _titleElement: {
        get: function () {
          return this.getElementsByTagName('title').item(0) || null;
        },
      },
      title: {
        get: function () {
          var elt = this._titleElement;
          var value = elt ? elt.textContent : '';
          return value.replace(/[ \t\n\r\f]+/g, ' ').replace(/(^ )|( $)/g, '');
        },
        set: function (value) {
          var elt = this._titleElement;
          var head = this.head;
          if (!elt && !head) {
            return;
          }
          if (!elt) {
            elt = this.createElement('title');
            head.appendChild(elt);
          }
          elt.textContent = value;
        },
      },
      dir: mirrorAttr(
        function () {
          var htmlElement = this.documentElement;
          if (htmlElement && htmlElement.tagName === 'HTML') {
            return htmlElement;
          }
        },
        'dir',
        '',
      ),
      fgColor: mirrorAttr(
        function () {
          return this.body;
        },
        'text',
        '',
      ),
      linkColor: mirrorAttr(
        function () {
          return this.body;
        },
        'link',
        '',
      ),
      vlinkColor: mirrorAttr(
        function () {
          return this.body;
        },
        'vLink',
        '',
      ),
      alinkColor: mirrorAttr(
        function () {
          return this.body;
        },
        'aLink',
        '',
      ),
      bgColor: mirrorAttr(
        function () {
          return this.body;
        },
        'bgColor',
        '',
      ),
      // Historical aliases of Document#characterSet
      charset: {
        get: function () {
          return this.characterSet;
        },
      },
      inputEncoding: {
        get: function () {
          return this.characterSet;
        },
      },
      scrollingElement: {
        get: function () {
          return this._quirks ? this.body : this.documentElement;
        },
      },
      // Return the first <body> child of the document element.
      // XXX For now, setting this attribute is not implemented.
      body: {
        get: function () {
          return namedHTMLChild(this.documentElement, 'body');
        },
        set: utils.nyi,
      },
      // Return the first <head> child of the document element.
      head: {
        get: function () {
          return namedHTMLChild(this.documentElement, 'head');
        },
      },
      images: { get: utils.nyi },
      embeds: { get: utils.nyi },
      plugins: { get: utils.nyi },
      links: { get: utils.nyi },
      forms: { get: utils.nyi },
      scripts: { get: utils.nyi },
      applets: {
        get: function () {
          return [];
        },
      },
      activeElement: {
        get: function () {
          return null;
        },
      },
      innerHTML: {
        get: function () {
          return this.serialize();
        },
        set: utils.nyi,
      },
      outerHTML: {
        get: function () {
          return this.serialize();
        },
        set: utils.nyi,
      },
      write: {
        value: function (args) {
          if (!this.isHTML) utils.InvalidStateError();
          if (!this._parser) return;
          if (!this._parser) {
          }
          var s = arguments.join('');
          this._parser.parse(s);
        },
      },
      writeln: {
        value: function writeln(args) {
          this.write(Array.prototype.join.call(arguments, '') + '\n');
        },
      },
      open: {
        value: function () {
          this.documentElement = null;
        },
      },
      close: {
        value: function () {
          this.readyState = 'interactive';
          this._dispatchEvent(new Event('readystatechange'), true);
          this._dispatchEvent(new Event('DOMContentLoaded'), true);
          this.readyState = 'complete';
          this._dispatchEvent(new Event('readystatechange'), true);
          if (this.defaultView) {
            this.defaultView._dispatchEvent(new Event('load'), true);
          }
        },
      },
      // Utility methods
      clone: {
        value: function clone() {
          var d = new Document(this.isHTML, this._address);
          d._quirks = this._quirks;
          d._contentType = this._contentType;
          return d;
        },
      },
      // We need to adopt the nodes if we do a deep clone
      cloneNode: {
        value: function cloneNode(deep) {
          var clone = Node.prototype.cloneNode.call(this, false);
          if (deep) {
            for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
              clone._appendChild(clone.importNode(kid, true));
            }
          }
          clone._updateDocTypeElement();
          return clone;
        },
      },
      isEqual: {
        value: function isEqual(n) {
          return true;
        },
      },
      // Implementation-specific function.  Called when a text, comment,
      // or pi value changes.
      mutateValue: {
        value: function (node) {
          if (this.mutationHandler) {
            this.mutationHandler({
              type: MUTATE.VALUE,
              target: node,
              data: node.data,
            });
          }
        },
      },
      // Invoked when an attribute's value changes. Attr holds the new
      // value.  oldval is the old value.  Attribute mutations can also
      // involve changes to the prefix (and therefore the qualified name)
      mutateAttr: {
        value: function (attr, oldval) {
          if (this.mutationHandler) {
            this.mutationHandler({
              type: MUTATE.ATTR,
              target: attr.ownerElement,
              attr,
            });
          }
        },
      },
      // Used by removeAttribute and removeAttributeNS for attributes.
      mutateRemoveAttr: {
        value: function (attr) {
          if (this.mutationHandler) {
            this.mutationHandler({
              type: MUTATE.REMOVE_ATTR,
              target: attr.ownerElement,
              attr,
            });
          }
        },
      },
      // Called by Node.removeChild, etc. to remove a rooted element from
      // the tree. Only needs to generate a single mutation event when a
      // node is removed, but must recursively mark all descendants as not
      // rooted.
      mutateRemove: {
        value: function (node) {
          if (this.mutationHandler) {
            this.mutationHandler({
              type: MUTATE.REMOVE,
              target: node.parentNode,
              node,
            });
          }
          recursivelyUproot(node);
        },
      },
      // Called when a new element becomes rooted.  It must recursively
      // generate mutation events for each of the children, and mark them all
      // as rooted.
      mutateInsert: {
        value: function (node) {
          recursivelyRoot(node);
          if (this.mutationHandler) {
            this.mutationHandler({
              type: MUTATE.INSERT,
              target: node.parentNode,
              node,
            });
          }
        },
      },
      // Called when a rooted element is moved within the document
      mutateMove: {
        value: function (node) {
          if (this.mutationHandler) {
            this.mutationHandler({
              type: MUTATE.MOVE,
              target: node,
            });
          }
        },
      },
      // Add a mapping from  id to n for n.ownerDocument
      addId: {
        value: function addId(id, n) {
          var val = this.byId[id];
          if (!val) {
            this.byId[id] = n;
          } else {
            if (!(val instanceof MultiId)) {
              val = new MultiId(val);
              this.byId[id] = val;
            }
            val.add(n);
          }
        },
      },
      // Delete the mapping from id to n for n.ownerDocument
      delId: {
        value: function delId(id, n) {
          var val = this.byId[id];
          utils.assert(val);
          if (val instanceof MultiId) {
            val.del(n);
            if (val.length === 1) {
              this.byId[id] = val.downgrade();
            }
          } else {
            this.byId[id] = void 0;
          }
        },
      },
      _resolve: {
        value: function (href) {
          return new URL3(this._documentBaseURL).resolve(href);
        },
      },
      _documentBaseURL: {
        get: function () {
          var url = this._address;
          if (url === 'about:blank') url = '/';
          var base = this.querySelector('base[href]');
          if (base) {
            return new URL3(url).resolve(base.getAttribute('href'));
          }
          return url;
        },
      },
      _templateDoc: {
        get: function () {
          if (!this._templateDocCache) {
            var newDoc = new Document(this.isHTML, this._address);
            this._templateDocCache = newDoc._templateDocCache = newDoc;
          }
          return this._templateDocCache;
        },
      },
      querySelector: {
        value: function (selector) {
          return select(selector, this)[0];
        },
      },
      querySelectorAll: {
        value: function (selector) {
          var nodes = select(selector, this);
          return nodes.item ? nodes : new NodeList(nodes);
        },
      },
    });
    var eventHandlerTypes = [
      'abort',
      'canplay',
      'canplaythrough',
      'change',
      'click',
      'contextmenu',
      'cuechange',
      'dblclick',
      'drag',
      'dragend',
      'dragenter',
      'dragleave',
      'dragover',
      'dragstart',
      'drop',
      'durationchange',
      'emptied',
      'ended',
      'input',
      'invalid',
      'keydown',
      'keypress',
      'keyup',
      'loadeddata',
      'loadedmetadata',
      'loadstart',
      'mousedown',
      'mousemove',
      'mouseout',
      'mouseover',
      'mouseup',
      'mousewheel',
      'pause',
      'play',
      'playing',
      'progress',
      'ratechange',
      'readystatechange',
      'reset',
      'seeked',
      'seeking',
      'select',
      'show',
      'stalled',
      'submit',
      'suspend',
      'timeupdate',
      'volumechange',
      'waiting',
      'blur',
      'error',
      'focus',
      'load',
      'scroll',
    ];
    eventHandlerTypes.forEach(function (type) {
      Object.defineProperty(Document.prototype, 'on' + type, {
        get: function () {
          return this._getEventHandler(type);
        },
        set: function (v) {
          this._setEventHandler(type, v);
        },
      });
    });
    function namedHTMLChild(parent, name) {
      if (parent && parent.isHTML) {
        for (var kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {
          if (kid.nodeType === Node.ELEMENT_NODE && kid.localName === name && kid.namespaceURI === NAMESPACE.HTML) {
            return kid;
          }
        }
      }
      return null;
    }
    function root(n) {
      n._nid = n.ownerDocument._nextnid++;
      n.ownerDocument._nodes[n._nid] = n;
      if (n.nodeType === Node.ELEMENT_NODE) {
        var id = n.getAttribute('id');
        if (id) n.ownerDocument.addId(id, n);
        if (n._roothook) n._roothook();
      }
    }
    function uproot(n) {
      if (n.nodeType === Node.ELEMENT_NODE) {
        var id = n.getAttribute('id');
        if (id) n.ownerDocument.delId(id, n);
      }
      n.ownerDocument._nodes[n._nid] = void 0;
      n._nid = void 0;
    }
    function recursivelyRoot(node) {
      root(node);
      if (node.nodeType === Node.ELEMENT_NODE) {
        for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling) recursivelyRoot(kid);
      }
    }
    function recursivelyUproot(node) {
      uproot(node);
      for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling) recursivelyUproot(kid);
    }
    function recursivelySetOwner(node, owner) {
      node.ownerDocument = owner;
      node._lastModTime = void 0;
      if (Object.prototype.hasOwnProperty.call(node, '_tagName')) {
        node._tagName = void 0;
      }
      for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling) recursivelySetOwner(kid, owner);
    }
    function MultiId(node) {
      this.nodes = /* @__PURE__ */ Object.create(null);
      this.nodes[node._nid] = node;
      this.length = 1;
      this.firstNode = void 0;
    }
    MultiId.prototype.add = function (node) {
      if (!this.nodes[node._nid]) {
        this.nodes[node._nid] = node;
        this.length++;
        this.firstNode = void 0;
      }
    };
    MultiId.prototype.del = function (node) {
      if (this.nodes[node._nid]) {
        delete this.nodes[node._nid];
        this.length--;
        this.firstNode = void 0;
      }
    };
    MultiId.prototype.getFirst = function () {
      if (!this.firstNode) {
        var nid;
        for (nid in this.nodes) {
          if (
            this.firstNode === void 0 ||
            this.firstNode.compareDocumentPosition(this.nodes[nid]) & Node.DOCUMENT_POSITION_PRECEDING
          ) {
            this.firstNode = this.nodes[nid];
          }
        }
      }
      return this.firstNode;
    };
    MultiId.prototype.downgrade = function () {
      if (this.length === 1) {
        var nid;
        for (nid in this.nodes) {
          return this.nodes[nid];
        }
      }
      return this;
    };
  },
});

// node_modules/@mixmark-io/domino/lib/DocumentType.js
var require_DocumentType = __commonJS({
  'node_modules/@mixmark-io/domino/lib/DocumentType.js'(exports2, module2) {
    'use strict';
    module2.exports = DocumentType;
    var Node = require_Node();
    var Leaf = require_Leaf();
    var ChildNode = require_ChildNode();
    function DocumentType(ownerDocument, name, publicId, systemId) {
      Leaf.call(this);
      this.nodeType = Node.DOCUMENT_TYPE_NODE;
      this.ownerDocument = ownerDocument || null;
      this.name = name;
      this.publicId = publicId || '';
      this.systemId = systemId || '';
    }
    DocumentType.prototype = Object.create(Leaf.prototype, {
      nodeName: {
        get: function () {
          return this.name;
        },
      },
      nodeValue: {
        get: function () {
          return null;
        },
        set: function () {},
      },
      // Utility methods
      clone: {
        value: function clone() {
          return new DocumentType(this.ownerDocument, this.name, this.publicId, this.systemId);
        },
      },
      isEqual: {
        value: function isEqual(n) {
          return this.name === n.name && this.publicId === n.publicId && this.systemId === n.systemId;
        },
      },
    });
    Object.defineProperties(DocumentType.prototype, ChildNode);
  },
});

// node_modules/@mixmark-io/domino/lib/HTMLParser.js
var require_HTMLParser = __commonJS({
  'node_modules/@mixmark-io/domino/lib/HTMLParser.js'(exports2, module2) {
    'use strict';
    module2.exports = HTMLParser;
    var Document = require_Document();
    var DocumentType = require_DocumentType();
    var Node = require_Node();
    var NAMESPACE = require_utils2().NAMESPACE;
    var html = require_htmlelts();
    var impl = html.elements;
    var pushAll = Function.prototype.apply.bind(Array.prototype.push);
    var EOF = -1;
    var TEXT = 1;
    var TAG = 2;
    var ENDTAG = 3;
    var COMMENT = 4;
    var DOCTYPE = 5;
    var NOATTRS = [];
    var quirkyPublicIds =
      /^HTML$|^-\/\/W3O\/\/DTD W3 HTML Strict 3\.0\/\/EN\/\/$|^-\/W3C\/DTD HTML 4\.0 Transitional\/EN$|^\+\/\/Silmaril\/\/dtd html Pro v0r11 19970101\/\/|^-\/\/AdvaSoft Ltd\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/AS\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict\/\/|^-\/\/IETF\/\/DTD HTML 2\.0\/\/|^-\/\/IETF\/\/DTD HTML 2\.1E\/\/|^-\/\/IETF\/\/DTD HTML 3\.0\/\/|^-\/\/IETF\/\/DTD HTML 3\.2 Final\/\/|^-\/\/IETF\/\/DTD HTML 3\.2\/\/|^-\/\/IETF\/\/DTD HTML 3\/\/|^-\/\/IETF\/\/DTD HTML Level 0\/\/|^-\/\/IETF\/\/DTD HTML Level 1\/\/|^-\/\/IETF\/\/DTD HTML Level 2\/\/|^-\/\/IETF\/\/DTD HTML Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 0\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict\/\/|^-\/\/IETF\/\/DTD HTML\/\/|^-\/\/Metrius\/\/DTD Metrius Presentational\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 Tables\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 Tables\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD HTML\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD Strict HTML\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML 2\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended 1\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended Relaxed 1\.0\/\/|^-\/\/SoftQuad Software\/\/DTD HoTMetaL PRO 6\.0::19990601::extensions to HTML 4\.0\/\/|^-\/\/SoftQuad\/\/DTD HoTMetaL PRO 4\.0::19971010::extensions to HTML 4\.0\/\/|^-\/\/Spyglass\/\/DTD HTML 2\.0 Extended\/\/|^-\/\/SQ\/\/DTD HTML 2\.0 HoTMetaL \+ extensions\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava HTML\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava Strict HTML\/\/|^-\/\/W3C\/\/DTD HTML 3 1995-03-24\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Draft\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Final\/\/|^-\/\/W3C\/\/DTD HTML 3\.2\/\/|^-\/\/W3C\/\/DTD HTML 3\.2S Draft\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Transitional\/\/|^-\/\/W3C\/\/DTD HTML Experimental 19960712\/\/|^-\/\/W3C\/\/DTD HTML Experimental 970421\/\/|^-\/\/W3C\/\/DTD W3 HTML\/\/|^-\/\/W3O\/\/DTD W3 HTML 3\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML 2\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML\/\//i;
    var quirkySystemId = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';
    var conditionallyQuirkyPublicIds =
      /^-\/\/W3C\/\/DTD HTML 4\.01 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.01 Transitional\/\//i;
    var limitedQuirkyPublicIds =
      /^-\/\/W3C\/\/DTD XHTML 1\.0 Frameset\/\/|^-\/\/W3C\/\/DTD XHTML 1\.0 Transitional\/\//i;
    var specialSet = /* @__PURE__ */ Object.create(null);
    specialSet[NAMESPACE.HTML] = {
      __proto__: null,
      address: true,
      applet: true,
      area: true,
      article: true,
      aside: true,
      base: true,
      basefont: true,
      bgsound: true,
      blockquote: true,
      body: true,
      br: true,
      button: true,
      caption: true,
      center: true,
      col: true,
      colgroup: true,
      dd: true,
      details: true,
      dir: true,
      div: true,
      dl: true,
      dt: true,
      embed: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      frame: true,
      frameset: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      head: true,
      header: true,
      hgroup: true,
      hr: true,
      html: true,
      iframe: true,
      img: true,
      input: true,
      li: true,
      link: true,
      listing: true,
      main: true,
      marquee: true,
      menu: true,
      meta: true,
      nav: true,
      noembed: true,
      noframes: true,
      noscript: true,
      object: true,
      ol: true,
      p: true,
      param: true,
      plaintext: true,
      pre: true,
      script: true,
      section: true,
      select: true,
      source: true,
      style: true,
      summary: true,
      table: true,
      tbody: true,
      td: true,
      template: true,
      textarea: true,
      tfoot: true,
      th: true,
      thead: true,
      title: true,
      tr: true,
      track: true,
      // Note that "xmp" was removed from the "special" set in the latest
      // spec, apparently by accident; see
      // https://github.com/whatwg/html/pull/1919
      ul: true,
      wbr: true,
      xmp: true,
    };
    specialSet[NAMESPACE.SVG] = {
      __proto__: null,
      foreignObject: true,
      desc: true,
      title: true,
    };
    specialSet[NAMESPACE.MATHML] = {
      __proto__: null,
      mi: true,
      mo: true,
      mn: true,
      ms: true,
      mtext: true,
      'annotation-xml': true,
    };
    var addressdivpSet = /* @__PURE__ */ Object.create(null);
    addressdivpSet[NAMESPACE.HTML] = {
      __proto__: null,
      address: true,
      div: true,
      p: true,
    };
    var dddtSet = /* @__PURE__ */ Object.create(null);
    dddtSet[NAMESPACE.HTML] = {
      __proto__: null,
      dd: true,
      dt: true,
    };
    var tablesectionrowSet = /* @__PURE__ */ Object.create(null);
    tablesectionrowSet[NAMESPACE.HTML] = {
      __proto__: null,
      table: true,
      thead: true,
      tbody: true,
      tfoot: true,
      tr: true,
    };
    var impliedEndTagsSet = /* @__PURE__ */ Object.create(null);
    impliedEndTagsSet[NAMESPACE.HTML] = {
      __proto__: null,
      dd: true,
      dt: true,
      li: true,
      menuitem: true,
      optgroup: true,
      option: true,
      p: true,
      rb: true,
      rp: true,
      rt: true,
      rtc: true,
    };
    var thoroughImpliedEndTagsSet = /* @__PURE__ */ Object.create(null);
    thoroughImpliedEndTagsSet[NAMESPACE.HTML] = {
      __proto__: null,
      caption: true,
      colgroup: true,
      dd: true,
      dt: true,
      li: true,
      optgroup: true,
      option: true,
      p: true,
      rb: true,
      rp: true,
      rt: true,
      rtc: true,
      tbody: true,
      td: true,
      tfoot: true,
      th: true,
      thead: true,
      tr: true,
    };
    var tableContextSet = /* @__PURE__ */ Object.create(null);
    tableContextSet[NAMESPACE.HTML] = {
      __proto__: null,
      table: true,
      template: true,
      html: true,
    };
    var tableBodyContextSet = /* @__PURE__ */ Object.create(null);
    tableBodyContextSet[NAMESPACE.HTML] = {
      __proto__: null,
      tbody: true,
      tfoot: true,
      thead: true,
      template: true,
      html: true,
    };
    var tableRowContextSet = /* @__PURE__ */ Object.create(null);
    tableRowContextSet[NAMESPACE.HTML] = {
      __proto__: null,
      tr: true,
      template: true,
      html: true,
    };
    var formassociatedSet = /* @__PURE__ */ Object.create(null);
    formassociatedSet[NAMESPACE.HTML] = {
      __proto__: null,
      button: true,
      fieldset: true,
      input: true,
      keygen: true,
      object: true,
      output: true,
      select: true,
      textarea: true,
      img: true,
    };
    var inScopeSet = /* @__PURE__ */ Object.create(null);
    inScopeSet[NAMESPACE.HTML] = {
      __proto__: null,
      applet: true,
      caption: true,
      html: true,
      table: true,
      td: true,
      th: true,
      marquee: true,
      object: true,
      template: true,
    };
    inScopeSet[NAMESPACE.MATHML] = {
      __proto__: null,
      mi: true,
      mo: true,
      mn: true,
      ms: true,
      mtext: true,
      'annotation-xml': true,
    };
    inScopeSet[NAMESPACE.SVG] = {
      __proto__: null,
      foreignObject: true,
      desc: true,
      title: true,
    };
    var inListItemScopeSet = Object.create(inScopeSet);
    inListItemScopeSet[NAMESPACE.HTML] = Object.create(inScopeSet[NAMESPACE.HTML]);
    inListItemScopeSet[NAMESPACE.HTML].ol = true;
    inListItemScopeSet[NAMESPACE.HTML].ul = true;
    var inButtonScopeSet = Object.create(inScopeSet);
    inButtonScopeSet[NAMESPACE.HTML] = Object.create(inScopeSet[NAMESPACE.HTML]);
    inButtonScopeSet[NAMESPACE.HTML].button = true;
    var inTableScopeSet = /* @__PURE__ */ Object.create(null);
    inTableScopeSet[NAMESPACE.HTML] = {
      __proto__: null,
      html: true,
      table: true,
      template: true,
    };
    var invertedSelectScopeSet = /* @__PURE__ */ Object.create(null);
    invertedSelectScopeSet[NAMESPACE.HTML] = {
      __proto__: null,
      optgroup: true,
      option: true,
    };
    var mathmlTextIntegrationPointSet = /* @__PURE__ */ Object.create(null);
    mathmlTextIntegrationPointSet[NAMESPACE.MATHML] = {
      __proto__: null,
      mi: true,
      mo: true,
      mn: true,
      ms: true,
      mtext: true,
    };
    var htmlIntegrationPointSet = /* @__PURE__ */ Object.create(null);
    htmlIntegrationPointSet[NAMESPACE.SVG] = {
      __proto__: null,
      foreignObject: true,
      desc: true,
      title: true,
    };
    var foreignAttributes = {
      __proto__: null,
      'xlink:actuate': NAMESPACE.XLINK,
      'xlink:arcrole': NAMESPACE.XLINK,
      'xlink:href': NAMESPACE.XLINK,
      'xlink:role': NAMESPACE.XLINK,
      'xlink:show': NAMESPACE.XLINK,
      'xlink:title': NAMESPACE.XLINK,
      'xlink:type': NAMESPACE.XLINK,
      'xml:base': NAMESPACE.XML,
      'xml:lang': NAMESPACE.XML,
      'xml:space': NAMESPACE.XML,
      xmlns: NAMESPACE.XMLNS,
      'xmlns:xlink': NAMESPACE.XMLNS,
    };
    var svgAttrAdjustments = {
      __proto__: null,
      attributename: 'attributeName',
      attributetype: 'attributeType',
      basefrequency: 'baseFrequency',
      baseprofile: 'baseProfile',
      calcmode: 'calcMode',
      clippathunits: 'clipPathUnits',
      diffuseconstant: 'diffuseConstant',
      edgemode: 'edgeMode',
      filterunits: 'filterUnits',
      glyphref: 'glyphRef',
      gradienttransform: 'gradientTransform',
      gradientunits: 'gradientUnits',
      kernelmatrix: 'kernelMatrix',
      kernelunitlength: 'kernelUnitLength',
      keypoints: 'keyPoints',
      keysplines: 'keySplines',
      keytimes: 'keyTimes',
      lengthadjust: 'lengthAdjust',
      limitingconeangle: 'limitingConeAngle',
      markerheight: 'markerHeight',
      markerunits: 'markerUnits',
      markerwidth: 'markerWidth',
      maskcontentunits: 'maskContentUnits',
      maskunits: 'maskUnits',
      numoctaves: 'numOctaves',
      pathlength: 'pathLength',
      patterncontentunits: 'patternContentUnits',
      patterntransform: 'patternTransform',
      patternunits: 'patternUnits',
      pointsatx: 'pointsAtX',
      pointsaty: 'pointsAtY',
      pointsatz: 'pointsAtZ',
      preservealpha: 'preserveAlpha',
      preserveaspectratio: 'preserveAspectRatio',
      primitiveunits: 'primitiveUnits',
      refx: 'refX',
      refy: 'refY',
      repeatcount: 'repeatCount',
      repeatdur: 'repeatDur',
      requiredextensions: 'requiredExtensions',
      requiredfeatures: 'requiredFeatures',
      specularconstant: 'specularConstant',
      specularexponent: 'specularExponent',
      spreadmethod: 'spreadMethod',
      startoffset: 'startOffset',
      stddeviation: 'stdDeviation',
      stitchtiles: 'stitchTiles',
      surfacescale: 'surfaceScale',
      systemlanguage: 'systemLanguage',
      tablevalues: 'tableValues',
      targetx: 'targetX',
      targety: 'targetY',
      textlength: 'textLength',
      viewbox: 'viewBox',
      viewtarget: 'viewTarget',
      xchannelselector: 'xChannelSelector',
      ychannelselector: 'yChannelSelector',
      zoomandpan: 'zoomAndPan',
    };
    var svgTagNameAdjustments = {
      __proto__: null,
      altglyph: 'altGlyph',
      altglyphdef: 'altGlyphDef',
      altglyphitem: 'altGlyphItem',
      animatecolor: 'animateColor',
      animatemotion: 'animateMotion',
      animatetransform: 'animateTransform',
      clippath: 'clipPath',
      feblend: 'feBlend',
      fecolormatrix: 'feColorMatrix',
      fecomponenttransfer: 'feComponentTransfer',
      fecomposite: 'feComposite',
      feconvolvematrix: 'feConvolveMatrix',
      fediffuselighting: 'feDiffuseLighting',
      fedisplacementmap: 'feDisplacementMap',
      fedistantlight: 'feDistantLight',
      feflood: 'feFlood',
      fefunca: 'feFuncA',
      fefuncb: 'feFuncB',
      fefuncg: 'feFuncG',
      fefuncr: 'feFuncR',
      fegaussianblur: 'feGaussianBlur',
      feimage: 'feImage',
      femerge: 'feMerge',
      femergenode: 'feMergeNode',
      femorphology: 'feMorphology',
      feoffset: 'feOffset',
      fepointlight: 'fePointLight',
      fespecularlighting: 'feSpecularLighting',
      fespotlight: 'feSpotLight',
      fetile: 'feTile',
      feturbulence: 'feTurbulence',
      foreignobject: 'foreignObject',
      glyphref: 'glyphRef',
      lineargradient: 'linearGradient',
      radialgradient: 'radialGradient',
      textpath: 'textPath',
    };
    var numericCharRefReplacements = {
      __proto__: null,
      0: 65533,
      128: 8364,
      130: 8218,
      131: 402,
      132: 8222,
      133: 8230,
      134: 8224,
      135: 8225,
      136: 710,
      137: 8240,
      138: 352,
      139: 8249,
      140: 338,
      142: 381,
      145: 8216,
      146: 8217,
      147: 8220,
      148: 8221,
      149: 8226,
      150: 8211,
      151: 8212,
      152: 732,
      153: 8482,
      154: 353,
      155: 8250,
      156: 339,
      158: 382,
      159: 376,
    };
    var namedCharRefs = {
      __proto__: null,
      AElig: 198,
      'AElig;': 198,
      AMP: 38,
      'AMP;': 38,
      Aacute: 193,
      'Aacute;': 193,
      'Abreve;': 258,
      Acirc: 194,
      'Acirc;': 194,
      'Acy;': 1040,
      'Afr;': [55349, 56580],
      Agrave: 192,
      'Agrave;': 192,
      'Alpha;': 913,
      'Amacr;': 256,
      'And;': 10835,
      'Aogon;': 260,
      'Aopf;': [55349, 56632],
      'ApplyFunction;': 8289,
      Aring: 197,
      'Aring;': 197,
      'Ascr;': [55349, 56476],
      'Assign;': 8788,
      Atilde: 195,
      'Atilde;': 195,
      Auml: 196,
      'Auml;': 196,
      'Backslash;': 8726,
      'Barv;': 10983,
      'Barwed;': 8966,
      'Bcy;': 1041,
      'Because;': 8757,
      'Bernoullis;': 8492,
      'Beta;': 914,
      'Bfr;': [55349, 56581],
      'Bopf;': [55349, 56633],
      'Breve;': 728,
      'Bscr;': 8492,
      'Bumpeq;': 8782,
      'CHcy;': 1063,
      COPY: 169,
      'COPY;': 169,
      'Cacute;': 262,
      'Cap;': 8914,
      'CapitalDifferentialD;': 8517,
      'Cayleys;': 8493,
      'Ccaron;': 268,
      Ccedil: 199,
      'Ccedil;': 199,
      'Ccirc;': 264,
      'Cconint;': 8752,
      'Cdot;': 266,
      'Cedilla;': 184,
      'CenterDot;': 183,
      'Cfr;': 8493,
      'Chi;': 935,
      'CircleDot;': 8857,
      'CircleMinus;': 8854,
      'CirclePlus;': 8853,
      'CircleTimes;': 8855,
      'ClockwiseContourIntegral;': 8754,
      'CloseCurlyDoubleQuote;': 8221,
      'CloseCurlyQuote;': 8217,
      'Colon;': 8759,
      'Colone;': 10868,
      'Congruent;': 8801,
      'Conint;': 8751,
      'ContourIntegral;': 8750,
      'Copf;': 8450,
      'Coproduct;': 8720,
      'CounterClockwiseContourIntegral;': 8755,
      'Cross;': 10799,
      'Cscr;': [55349, 56478],
      'Cup;': 8915,
      'CupCap;': 8781,
      'DD;': 8517,
      'DDotrahd;': 10513,
      'DJcy;': 1026,
      'DScy;': 1029,
      'DZcy;': 1039,
      'Dagger;': 8225,
      'Darr;': 8609,
      'Dashv;': 10980,
      'Dcaron;': 270,
      'Dcy;': 1044,
      'Del;': 8711,
      'Delta;': 916,
      'Dfr;': [55349, 56583],
      'DiacriticalAcute;': 180,
      'DiacriticalDot;': 729,
      'DiacriticalDoubleAcute;': 733,
      'DiacriticalGrave;': 96,
      'DiacriticalTilde;': 732,
      'Diamond;': 8900,
      'DifferentialD;': 8518,
      'Dopf;': [55349, 56635],
      'Dot;': 168,
      'DotDot;': 8412,
      'DotEqual;': 8784,
      'DoubleContourIntegral;': 8751,
      'DoubleDot;': 168,
      'DoubleDownArrow;': 8659,
      'DoubleLeftArrow;': 8656,
      'DoubleLeftRightArrow;': 8660,
      'DoubleLeftTee;': 10980,
      'DoubleLongLeftArrow;': 10232,
      'DoubleLongLeftRightArrow;': 10234,
      'DoubleLongRightArrow;': 10233,
      'DoubleRightArrow;': 8658,
      'DoubleRightTee;': 8872,
      'DoubleUpArrow;': 8657,
      'DoubleUpDownArrow;': 8661,
      'DoubleVerticalBar;': 8741,
      'DownArrow;': 8595,
      'DownArrowBar;': 10515,
      'DownArrowUpArrow;': 8693,
      'DownBreve;': 785,
      'DownLeftRightVector;': 10576,
      'DownLeftTeeVector;': 10590,
      'DownLeftVector;': 8637,
      'DownLeftVectorBar;': 10582,
      'DownRightTeeVector;': 10591,
      'DownRightVector;': 8641,
      'DownRightVectorBar;': 10583,
      'DownTee;': 8868,
      'DownTeeArrow;': 8615,
      'Downarrow;': 8659,
      'Dscr;': [55349, 56479],
      'Dstrok;': 272,
      'ENG;': 330,
      ETH: 208,
      'ETH;': 208,
      Eacute: 201,
      'Eacute;': 201,
      'Ecaron;': 282,
      Ecirc: 202,
      'Ecirc;': 202,
      'Ecy;': 1069,
      'Edot;': 278,
      'Efr;': [55349, 56584],
      Egrave: 200,
      'Egrave;': 200,
      'Element;': 8712,
      'Emacr;': 274,
      'EmptySmallSquare;': 9723,
      'EmptyVerySmallSquare;': 9643,
      'Eogon;': 280,
      'Eopf;': [55349, 56636],
      'Epsilon;': 917,
      'Equal;': 10869,
      'EqualTilde;': 8770,
      'Equilibrium;': 8652,
      'Escr;': 8496,
      'Esim;': 10867,
      'Eta;': 919,
      Euml: 203,
      'Euml;': 203,
      'Exists;': 8707,
      'ExponentialE;': 8519,
      'Fcy;': 1060,
      'Ffr;': [55349, 56585],
      'FilledSmallSquare;': 9724,
      'FilledVerySmallSquare;': 9642,
      'Fopf;': [55349, 56637],
      'ForAll;': 8704,
      'Fouriertrf;': 8497,
      'Fscr;': 8497,
      'GJcy;': 1027,
      GT: 62,
      'GT;': 62,
      'Gamma;': 915,
      'Gammad;': 988,
      'Gbreve;': 286,
      'Gcedil;': 290,
      'Gcirc;': 284,
      'Gcy;': 1043,
      'Gdot;': 288,
      'Gfr;': [55349, 56586],
      'Gg;': 8921,
      'Gopf;': [55349, 56638],
      'GreaterEqual;': 8805,
      'GreaterEqualLess;': 8923,
      'GreaterFullEqual;': 8807,
      'GreaterGreater;': 10914,
      'GreaterLess;': 8823,
      'GreaterSlantEqual;': 10878,
      'GreaterTilde;': 8819,
      'Gscr;': [55349, 56482],
      'Gt;': 8811,
      'HARDcy;': 1066,
      'Hacek;': 711,
      'Hat;': 94,
      'Hcirc;': 292,
      'Hfr;': 8460,
      'HilbertSpace;': 8459,
      'Hopf;': 8461,
      'HorizontalLine;': 9472,
      'Hscr;': 8459,
      'Hstrok;': 294,
      'HumpDownHump;': 8782,
      'HumpEqual;': 8783,
      'IEcy;': 1045,
      'IJlig;': 306,
      'IOcy;': 1025,
      Iacute: 205,
      'Iacute;': 205,
      Icirc: 206,
      'Icirc;': 206,
      'Icy;': 1048,
      'Idot;': 304,
      'Ifr;': 8465,
      Igrave: 204,
      'Igrave;': 204,
      'Im;': 8465,
      'Imacr;': 298,
      'ImaginaryI;': 8520,
      'Implies;': 8658,
      'Int;': 8748,
      'Integral;': 8747,
      'Intersection;': 8898,
      'InvisibleComma;': 8291,
      'InvisibleTimes;': 8290,
      'Iogon;': 302,
      'Iopf;': [55349, 56640],
      'Iota;': 921,
      'Iscr;': 8464,
      'Itilde;': 296,
      'Iukcy;': 1030,
      Iuml: 207,
      'Iuml;': 207,
      'Jcirc;': 308,
      'Jcy;': 1049,
      'Jfr;': [55349, 56589],
      'Jopf;': [55349, 56641],
      'Jscr;': [55349, 56485],
      'Jsercy;': 1032,
      'Jukcy;': 1028,
      'KHcy;': 1061,
      'KJcy;': 1036,
      'Kappa;': 922,
      'Kcedil;': 310,
      'Kcy;': 1050,
      'Kfr;': [55349, 56590],
      'Kopf;': [55349, 56642],
      'Kscr;': [55349, 56486],
      'LJcy;': 1033,
      LT: 60,
      'LT;': 60,
      'Lacute;': 313,
      'Lambda;': 923,
      'Lang;': 10218,
      'Laplacetrf;': 8466,
      'Larr;': 8606,
      'Lcaron;': 317,
      'Lcedil;': 315,
      'Lcy;': 1051,
      'LeftAngleBracket;': 10216,
      'LeftArrow;': 8592,
      'LeftArrowBar;': 8676,
      'LeftArrowRightArrow;': 8646,
      'LeftCeiling;': 8968,
      'LeftDoubleBracket;': 10214,
      'LeftDownTeeVector;': 10593,
      'LeftDownVector;': 8643,
      'LeftDownVectorBar;': 10585,
      'LeftFloor;': 8970,
      'LeftRightArrow;': 8596,
      'LeftRightVector;': 10574,
      'LeftTee;': 8867,
      'LeftTeeArrow;': 8612,
      'LeftTeeVector;': 10586,
      'LeftTriangle;': 8882,
      'LeftTriangleBar;': 10703,
      'LeftTriangleEqual;': 8884,
      'LeftUpDownVector;': 10577,
      'LeftUpTeeVector;': 10592,
      'LeftUpVector;': 8639,
      'LeftUpVectorBar;': 10584,
      'LeftVector;': 8636,
      'LeftVectorBar;': 10578,
      'Leftarrow;': 8656,
      'Leftrightarrow;': 8660,
      'LessEqualGreater;': 8922,
      'LessFullEqual;': 8806,
      'LessGreater;': 8822,
      'LessLess;': 10913,
      'LessSlantEqual;': 10877,
      'LessTilde;': 8818,
      'Lfr;': [55349, 56591],
      'Ll;': 8920,
      'Lleftarrow;': 8666,
      'Lmidot;': 319,
      'LongLeftArrow;': 10229,
      'LongLeftRightArrow;': 10231,
      'LongRightArrow;': 10230,
      'Longleftarrow;': 10232,
      'Longleftrightarrow;': 10234,
      'Longrightarrow;': 10233,
      'Lopf;': [55349, 56643],
      'LowerLeftArrow;': 8601,
      'LowerRightArrow;': 8600,
      'Lscr;': 8466,
      'Lsh;': 8624,
      'Lstrok;': 321,
      'Lt;': 8810,
      'Map;': 10501,
      'Mcy;': 1052,
      'MediumSpace;': 8287,
      'Mellintrf;': 8499,
      'Mfr;': [55349, 56592],
      'MinusPlus;': 8723,
      'Mopf;': [55349, 56644],
      'Mscr;': 8499,
      'Mu;': 924,
      'NJcy;': 1034,
      'Nacute;': 323,
      'Ncaron;': 327,
      'Ncedil;': 325,
      'Ncy;': 1053,
      'NegativeMediumSpace;': 8203,
      'NegativeThickSpace;': 8203,
      'NegativeThinSpace;': 8203,
      'NegativeVeryThinSpace;': 8203,
      'NestedGreaterGreater;': 8811,
      'NestedLessLess;': 8810,
      'NewLine;': 10,
      'Nfr;': [55349, 56593],
      'NoBreak;': 8288,
      'NonBreakingSpace;': 160,
      'Nopf;': 8469,
      'Not;': 10988,
      'NotCongruent;': 8802,
      'NotCupCap;': 8813,
      'NotDoubleVerticalBar;': 8742,
      'NotElement;': 8713,
      'NotEqual;': 8800,
      'NotEqualTilde;': [8770, 824],
      'NotExists;': 8708,
      'NotGreater;': 8815,
      'NotGreaterEqual;': 8817,
      'NotGreaterFullEqual;': [8807, 824],
      'NotGreaterGreater;': [8811, 824],
      'NotGreaterLess;': 8825,
      'NotGreaterSlantEqual;': [10878, 824],
      'NotGreaterTilde;': 8821,
      'NotHumpDownHump;': [8782, 824],
      'NotHumpEqual;': [8783, 824],
      'NotLeftTriangle;': 8938,
      'NotLeftTriangleBar;': [10703, 824],
      'NotLeftTriangleEqual;': 8940,
      'NotLess;': 8814,
      'NotLessEqual;': 8816,
      'NotLessGreater;': 8824,
      'NotLessLess;': [8810, 824],
      'NotLessSlantEqual;': [10877, 824],
      'NotLessTilde;': 8820,
      'NotNestedGreaterGreater;': [10914, 824],
      'NotNestedLessLess;': [10913, 824],
      'NotPrecedes;': 8832,
      'NotPrecedesEqual;': [10927, 824],
      'NotPrecedesSlantEqual;': 8928,
      'NotReverseElement;': 8716,
      'NotRightTriangle;': 8939,
      'NotRightTriangleBar;': [10704, 824],
      'NotRightTriangleEqual;': 8941,
      'NotSquareSubset;': [8847, 824],
      'NotSquareSubsetEqual;': 8930,
      'NotSquareSuperset;': [8848, 824],
      'NotSquareSupersetEqual;': 8931,
      'NotSubset;': [8834, 8402],
      'NotSubsetEqual;': 8840,
      'NotSucceeds;': 8833,
      'NotSucceedsEqual;': [10928, 824],
      'NotSucceedsSlantEqual;': 8929,
      'NotSucceedsTilde;': [8831, 824],
      'NotSuperset;': [8835, 8402],
      'NotSupersetEqual;': 8841,
      'NotTilde;': 8769,
      'NotTildeEqual;': 8772,
      'NotTildeFullEqual;': 8775,
      'NotTildeTilde;': 8777,
      'NotVerticalBar;': 8740,
      'Nscr;': [55349, 56489],
      Ntilde: 209,
      'Ntilde;': 209,
      'Nu;': 925,
      'OElig;': 338,
      Oacute: 211,
      'Oacute;': 211,
      Ocirc: 212,
      'Ocirc;': 212,
      'Ocy;': 1054,
      'Odblac;': 336,
      'Ofr;': [55349, 56594],
      Ograve: 210,
      'Ograve;': 210,
      'Omacr;': 332,
      'Omega;': 937,
      'Omicron;': 927,
      'Oopf;': [55349, 56646],
      'OpenCurlyDoubleQuote;': 8220,
      'OpenCurlyQuote;': 8216,
      'Or;': 10836,
      'Oscr;': [55349, 56490],
      Oslash: 216,
      'Oslash;': 216,
      Otilde: 213,
      'Otilde;': 213,
      'Otimes;': 10807,
      Ouml: 214,
      'Ouml;': 214,
      'OverBar;': 8254,
      'OverBrace;': 9182,
      'OverBracket;': 9140,
      'OverParenthesis;': 9180,
      'PartialD;': 8706,
      'Pcy;': 1055,
      'Pfr;': [55349, 56595],
      'Phi;': 934,
      'Pi;': 928,
      'PlusMinus;': 177,
      'Poincareplane;': 8460,
      'Popf;': 8473,
      'Pr;': 10939,
      'Precedes;': 8826,
      'PrecedesEqual;': 10927,
      'PrecedesSlantEqual;': 8828,
      'PrecedesTilde;': 8830,
      'Prime;': 8243,
      'Product;': 8719,
      'Proportion;': 8759,
      'Proportional;': 8733,
      'Pscr;': [55349, 56491],
      'Psi;': 936,
      QUOT: 34,
      'QUOT;': 34,
      'Qfr;': [55349, 56596],
      'Qopf;': 8474,
      'Qscr;': [55349, 56492],
      'RBarr;': 10512,
      REG: 174,
      'REG;': 174,
      'Racute;': 340,
      'Rang;': 10219,
      'Rarr;': 8608,
      'Rarrtl;': 10518,
      'Rcaron;': 344,
      'Rcedil;': 342,
      'Rcy;': 1056,
      'Re;': 8476,
      'ReverseElement;': 8715,
      'ReverseEquilibrium;': 8651,
      'ReverseUpEquilibrium;': 10607,
      'Rfr;': 8476,
      'Rho;': 929,
      'RightAngleBracket;': 10217,
      'RightArrow;': 8594,
      'RightArrowBar;': 8677,
      'RightArrowLeftArrow;': 8644,
      'RightCeiling;': 8969,
      'RightDoubleBracket;': 10215,
      'RightDownTeeVector;': 10589,
      'RightDownVector;': 8642,
      'RightDownVectorBar;': 10581,
      'RightFloor;': 8971,
      'RightTee;': 8866,
      'RightTeeArrow;': 8614,
      'RightTeeVector;': 10587,
      'RightTriangle;': 8883,
      'RightTriangleBar;': 10704,
      'RightTriangleEqual;': 8885,
      'RightUpDownVector;': 10575,
      'RightUpTeeVector;': 10588,
      'RightUpVector;': 8638,
      'RightUpVectorBar;': 10580,
      'RightVector;': 8640,
      'RightVectorBar;': 10579,
      'Rightarrow;': 8658,
      'Ropf;': 8477,
      'RoundImplies;': 10608,
      'Rrightarrow;': 8667,
      'Rscr;': 8475,
      'Rsh;': 8625,
      'RuleDelayed;': 10740,
      'SHCHcy;': 1065,
      'SHcy;': 1064,
      'SOFTcy;': 1068,
      'Sacute;': 346,
      'Sc;': 10940,
      'Scaron;': 352,
      'Scedil;': 350,
      'Scirc;': 348,
      'Scy;': 1057,
      'Sfr;': [55349, 56598],
      'ShortDownArrow;': 8595,
      'ShortLeftArrow;': 8592,
      'ShortRightArrow;': 8594,
      'ShortUpArrow;': 8593,
      'Sigma;': 931,
      'SmallCircle;': 8728,
      'Sopf;': [55349, 56650],
      'Sqrt;': 8730,
      'Square;': 9633,
      'SquareIntersection;': 8851,
      'SquareSubset;': 8847,
      'SquareSubsetEqual;': 8849,
      'SquareSuperset;': 8848,
      'SquareSupersetEqual;': 8850,
      'SquareUnion;': 8852,
      'Sscr;': [55349, 56494],
      'Star;': 8902,
      'Sub;': 8912,
      'Subset;': 8912,
      'SubsetEqual;': 8838,
      'Succeeds;': 8827,
      'SucceedsEqual;': 10928,
      'SucceedsSlantEqual;': 8829,
      'SucceedsTilde;': 8831,
      'SuchThat;': 8715,
      'Sum;': 8721,
      'Sup;': 8913,
      'Superset;': 8835,
      'SupersetEqual;': 8839,
      'Supset;': 8913,
      THORN: 222,
      'THORN;': 222,
      'TRADE;': 8482,
      'TSHcy;': 1035,
      'TScy;': 1062,
      'Tab;': 9,
      'Tau;': 932,
      'Tcaron;': 356,
      'Tcedil;': 354,
      'Tcy;': 1058,
      'Tfr;': [55349, 56599],
      'Therefore;': 8756,
      'Theta;': 920,
      'ThickSpace;': [8287, 8202],
      'ThinSpace;': 8201,
      'Tilde;': 8764,
      'TildeEqual;': 8771,
      'TildeFullEqual;': 8773,
      'TildeTilde;': 8776,
      'Topf;': [55349, 56651],
      'TripleDot;': 8411,
      'Tscr;': [55349, 56495],
      'Tstrok;': 358,
      Uacute: 218,
      'Uacute;': 218,
      'Uarr;': 8607,
      'Uarrocir;': 10569,
      'Ubrcy;': 1038,
      'Ubreve;': 364,
      Ucirc: 219,
      'Ucirc;': 219,
      'Ucy;': 1059,
      'Udblac;': 368,
      'Ufr;': [55349, 56600],
      Ugrave: 217,
      'Ugrave;': 217,
      'Umacr;': 362,
      'UnderBar;': 95,
      'UnderBrace;': 9183,
      'UnderBracket;': 9141,
      'UnderParenthesis;': 9181,
      'Union;': 8899,
      'UnionPlus;': 8846,
      'Uogon;': 370,
      'Uopf;': [55349, 56652],
      'UpArrow;': 8593,
      'UpArrowBar;': 10514,
      'UpArrowDownArrow;': 8645,
      'UpDownArrow;': 8597,
      'UpEquilibrium;': 10606,
      'UpTee;': 8869,
      'UpTeeArrow;': 8613,
      'Uparrow;': 8657,
      'Updownarrow;': 8661,
      'UpperLeftArrow;': 8598,
      'UpperRightArrow;': 8599,
      'Upsi;': 978,
      'Upsilon;': 933,
      'Uring;': 366,
      'Uscr;': [55349, 56496],
      'Utilde;': 360,
      Uuml: 220,
      'Uuml;': 220,
      'VDash;': 8875,
      'Vbar;': 10987,
      'Vcy;': 1042,
      'Vdash;': 8873,
      'Vdashl;': 10982,
      'Vee;': 8897,
      'Verbar;': 8214,
      'Vert;': 8214,
      'VerticalBar;': 8739,
      'VerticalLine;': 124,
      'VerticalSeparator;': 10072,
      'VerticalTilde;': 8768,
      'VeryThinSpace;': 8202,
      'Vfr;': [55349, 56601],
      'Vopf;': [55349, 56653],
      'Vscr;': [55349, 56497],
      'Vvdash;': 8874,
      'Wcirc;': 372,
      'Wedge;': 8896,
      'Wfr;': [55349, 56602],
      'Wopf;': [55349, 56654],
      'Wscr;': [55349, 56498],
      'Xfr;': [55349, 56603],
      'Xi;': 926,
      'Xopf;': [55349, 56655],
      'Xscr;': [55349, 56499],
      'YAcy;': 1071,
      'YIcy;': 1031,
      'YUcy;': 1070,
      Yacute: 221,
      'Yacute;': 221,
      'Ycirc;': 374,
      'Ycy;': 1067,
      'Yfr;': [55349, 56604],
      'Yopf;': [55349, 56656],
      'Yscr;': [55349, 56500],
      'Yuml;': 376,
      'ZHcy;': 1046,
      'Zacute;': 377,
      'Zcaron;': 381,
      'Zcy;': 1047,
      'Zdot;': 379,
      'ZeroWidthSpace;': 8203,
      'Zeta;': 918,
      'Zfr;': 8488,
      'Zopf;': 8484,
      'Zscr;': [55349, 56501],
      aacute: 225,
      'aacute;': 225,
      'abreve;': 259,
      'ac;': 8766,
      'acE;': [8766, 819],
      'acd;': 8767,
      acirc: 226,
      'acirc;': 226,
      acute: 180,
      'acute;': 180,
      'acy;': 1072,
      aelig: 230,
      'aelig;': 230,
      'af;': 8289,
      'afr;': [55349, 56606],
      agrave: 224,
      'agrave;': 224,
      'alefsym;': 8501,
      'aleph;': 8501,
      'alpha;': 945,
      'amacr;': 257,
      'amalg;': 10815,
      amp: 38,
      'amp;': 38,
      'and;': 8743,
      'andand;': 10837,
      'andd;': 10844,
      'andslope;': 10840,
      'andv;': 10842,
      'ang;': 8736,
      'ange;': 10660,
      'angle;': 8736,
      'angmsd;': 8737,
      'angmsdaa;': 10664,
      'angmsdab;': 10665,
      'angmsdac;': 10666,
      'angmsdad;': 10667,
      'angmsdae;': 10668,
      'angmsdaf;': 10669,
      'angmsdag;': 10670,
      'angmsdah;': 10671,
      'angrt;': 8735,
      'angrtvb;': 8894,
      'angrtvbd;': 10653,
      'angsph;': 8738,
      'angst;': 197,
      'angzarr;': 9084,
      'aogon;': 261,
      'aopf;': [55349, 56658],
      'ap;': 8776,
      'apE;': 10864,
      'apacir;': 10863,
      'ape;': 8778,
      'apid;': 8779,
      'apos;': 39,
      'approx;': 8776,
      'approxeq;': 8778,
      aring: 229,
      'aring;': 229,
      'ascr;': [55349, 56502],
      'ast;': 42,
      'asymp;': 8776,
      'asympeq;': 8781,
      atilde: 227,
      'atilde;': 227,
      auml: 228,
      'auml;': 228,
      'awconint;': 8755,
      'awint;': 10769,
      'bNot;': 10989,
      'backcong;': 8780,
      'backepsilon;': 1014,
      'backprime;': 8245,
      'backsim;': 8765,
      'backsimeq;': 8909,
      'barvee;': 8893,
      'barwed;': 8965,
      'barwedge;': 8965,
      'bbrk;': 9141,
      'bbrktbrk;': 9142,
      'bcong;': 8780,
      'bcy;': 1073,
      'bdquo;': 8222,
      'becaus;': 8757,
      'because;': 8757,
      'bemptyv;': 10672,
      'bepsi;': 1014,
      'bernou;': 8492,
      'beta;': 946,
      'beth;': 8502,
      'between;': 8812,
      'bfr;': [55349, 56607],
      'bigcap;': 8898,
      'bigcirc;': 9711,
      'bigcup;': 8899,
      'bigodot;': 10752,
      'bigoplus;': 10753,
      'bigotimes;': 10754,
      'bigsqcup;': 10758,
      'bigstar;': 9733,
      'bigtriangledown;': 9661,
      'bigtriangleup;': 9651,
      'biguplus;': 10756,
      'bigvee;': 8897,
      'bigwedge;': 8896,
      'bkarow;': 10509,
      'blacklozenge;': 10731,
      'blacksquare;': 9642,
      'blacktriangle;': 9652,
      'blacktriangledown;': 9662,
      'blacktriangleleft;': 9666,
      'blacktriangleright;': 9656,
      'blank;': 9251,
      'blk12;': 9618,
      'blk14;': 9617,
      'blk34;': 9619,
      'block;': 9608,
      'bne;': [61, 8421],
      'bnequiv;': [8801, 8421],
      'bnot;': 8976,
      'bopf;': [55349, 56659],
      'bot;': 8869,
      'bottom;': 8869,
      'bowtie;': 8904,
      'boxDL;': 9559,
      'boxDR;': 9556,
      'boxDl;': 9558,
      'boxDr;': 9555,
      'boxH;': 9552,
      'boxHD;': 9574,
      'boxHU;': 9577,
      'boxHd;': 9572,
      'boxHu;': 9575,
      'boxUL;': 9565,
      'boxUR;': 9562,
      'boxUl;': 9564,
      'boxUr;': 9561,
      'boxV;': 9553,
      'boxVH;': 9580,
      'boxVL;': 9571,
      'boxVR;': 9568,
      'boxVh;': 9579,
      'boxVl;': 9570,
      'boxVr;': 9567,
      'boxbox;': 10697,
      'boxdL;': 9557,
      'boxdR;': 9554,
      'boxdl;': 9488,
      'boxdr;': 9484,
      'boxh;': 9472,
      'boxhD;': 9573,
      'boxhU;': 9576,
      'boxhd;': 9516,
      'boxhu;': 9524,
      'boxminus;': 8863,
      'boxplus;': 8862,
      'boxtimes;': 8864,
      'boxuL;': 9563,
      'boxuR;': 9560,
      'boxul;': 9496,
      'boxur;': 9492,
      'boxv;': 9474,
      'boxvH;': 9578,
      'boxvL;': 9569,
      'boxvR;': 9566,
      'boxvh;': 9532,
      'boxvl;': 9508,
      'boxvr;': 9500,
      'bprime;': 8245,
      'breve;': 728,
      brvbar: 166,
      'brvbar;': 166,
      'bscr;': [55349, 56503],
      'bsemi;': 8271,
      'bsim;': 8765,
      'bsime;': 8909,
      'bsol;': 92,
      'bsolb;': 10693,
      'bsolhsub;': 10184,
      'bull;': 8226,
      'bullet;': 8226,
      'bump;': 8782,
      'bumpE;': 10926,
      'bumpe;': 8783,
      'bumpeq;': 8783,
      'cacute;': 263,
      'cap;': 8745,
      'capand;': 10820,
      'capbrcup;': 10825,
      'capcap;': 10827,
      'capcup;': 10823,
      'capdot;': 10816,
      'caps;': [8745, 65024],
      'caret;': 8257,
      'caron;': 711,
      'ccaps;': 10829,
      'ccaron;': 269,
      ccedil: 231,
      'ccedil;': 231,
      'ccirc;': 265,
      'ccups;': 10828,
      'ccupssm;': 10832,
      'cdot;': 267,
      cedil: 184,
      'cedil;': 184,
      'cemptyv;': 10674,
      cent: 162,
      'cent;': 162,
      'centerdot;': 183,
      'cfr;': [55349, 56608],
      'chcy;': 1095,
      'check;': 10003,
      'checkmark;': 10003,
      'chi;': 967,
      'cir;': 9675,
      'cirE;': 10691,
      'circ;': 710,
      'circeq;': 8791,
      'circlearrowleft;': 8634,
      'circlearrowright;': 8635,
      'circledR;': 174,
      'circledS;': 9416,
      'circledast;': 8859,
      'circledcirc;': 8858,
      'circleddash;': 8861,
      'cire;': 8791,
      'cirfnint;': 10768,
      'cirmid;': 10991,
      'cirscir;': 10690,
      'clubs;': 9827,
      'clubsuit;': 9827,
      'colon;': 58,
      'colone;': 8788,
      'coloneq;': 8788,
      'comma;': 44,
      'commat;': 64,
      'comp;': 8705,
      'compfn;': 8728,
      'complement;': 8705,
      'complexes;': 8450,
      'cong;': 8773,
      'congdot;': 10861,
      'conint;': 8750,
      'copf;': [55349, 56660],
      'coprod;': 8720,
      copy: 169,
      'copy;': 169,
      'copysr;': 8471,
      'crarr;': 8629,
      'cross;': 10007,
      'cscr;': [55349, 56504],
      'csub;': 10959,
      'csube;': 10961,
      'csup;': 10960,
      'csupe;': 10962,
      'ctdot;': 8943,
      'cudarrl;': 10552,
      'cudarrr;': 10549,
      'cuepr;': 8926,
      'cuesc;': 8927,
      'cularr;': 8630,
      'cularrp;': 10557,
      'cup;': 8746,
      'cupbrcap;': 10824,
      'cupcap;': 10822,
      'cupcup;': 10826,
      'cupdot;': 8845,
      'cupor;': 10821,
      'cups;': [8746, 65024],
      'curarr;': 8631,
      'curarrm;': 10556,
      'curlyeqprec;': 8926,
      'curlyeqsucc;': 8927,
      'curlyvee;': 8910,
      'curlywedge;': 8911,
      curren: 164,
      'curren;': 164,
      'curvearrowleft;': 8630,
      'curvearrowright;': 8631,
      'cuvee;': 8910,
      'cuwed;': 8911,
      'cwconint;': 8754,
      'cwint;': 8753,
      'cylcty;': 9005,
      'dArr;': 8659,
      'dHar;': 10597,
      'dagger;': 8224,
      'daleth;': 8504,
      'darr;': 8595,
      'dash;': 8208,
      'dashv;': 8867,
      'dbkarow;': 10511,
      'dblac;': 733,
      'dcaron;': 271,
      'dcy;': 1076,
      'dd;': 8518,
      'ddagger;': 8225,
      'ddarr;': 8650,
      'ddotseq;': 10871,
      deg: 176,
      'deg;': 176,
      'delta;': 948,
      'demptyv;': 10673,
      'dfisht;': 10623,
      'dfr;': [55349, 56609],
      'dharl;': 8643,
      'dharr;': 8642,
      'diam;': 8900,
      'diamond;': 8900,
      'diamondsuit;': 9830,
      'diams;': 9830,
      'die;': 168,
      'digamma;': 989,
      'disin;': 8946,
      'div;': 247,
      divide: 247,
      'divide;': 247,
      'divideontimes;': 8903,
      'divonx;': 8903,
      'djcy;': 1106,
      'dlcorn;': 8990,
      'dlcrop;': 8973,
      'dollar;': 36,
      'dopf;': [55349, 56661],
      'dot;': 729,
      'doteq;': 8784,
      'doteqdot;': 8785,
      'dotminus;': 8760,
      'dotplus;': 8724,
      'dotsquare;': 8865,
      'doublebarwedge;': 8966,
      'downarrow;': 8595,
      'downdownarrows;': 8650,
      'downharpoonleft;': 8643,
      'downharpoonright;': 8642,
      'drbkarow;': 10512,
      'drcorn;': 8991,
      'drcrop;': 8972,
      'dscr;': [55349, 56505],
      'dscy;': 1109,
      'dsol;': 10742,
      'dstrok;': 273,
      'dtdot;': 8945,
      'dtri;': 9663,
      'dtrif;': 9662,
      'duarr;': 8693,
      'duhar;': 10607,
      'dwangle;': 10662,
      'dzcy;': 1119,
      'dzigrarr;': 10239,
      'eDDot;': 10871,
      'eDot;': 8785,
      eacute: 233,
      'eacute;': 233,
      'easter;': 10862,
      'ecaron;': 283,
      'ecir;': 8790,
      ecirc: 234,
      'ecirc;': 234,
      'ecolon;': 8789,
      'ecy;': 1101,
      'edot;': 279,
      'ee;': 8519,
      'efDot;': 8786,
      'efr;': [55349, 56610],
      'eg;': 10906,
      egrave: 232,
      'egrave;': 232,
      'egs;': 10902,
      'egsdot;': 10904,
      'el;': 10905,
      'elinters;': 9191,
      'ell;': 8467,
      'els;': 10901,
      'elsdot;': 10903,
      'emacr;': 275,
      'empty;': 8709,
      'emptyset;': 8709,
      'emptyv;': 8709,
      'emsp13;': 8196,
      'emsp14;': 8197,
      'emsp;': 8195,
      'eng;': 331,
      'ensp;': 8194,
      'eogon;': 281,
      'eopf;': [55349, 56662],
      'epar;': 8917,
      'eparsl;': 10723,
      'eplus;': 10865,
      'epsi;': 949,
      'epsilon;': 949,
      'epsiv;': 1013,
      'eqcirc;': 8790,
      'eqcolon;': 8789,
      'eqsim;': 8770,
      'eqslantgtr;': 10902,
      'eqslantless;': 10901,
      'equals;': 61,
      'equest;': 8799,
      'equiv;': 8801,
      'equivDD;': 10872,
      'eqvparsl;': 10725,
      'erDot;': 8787,
      'erarr;': 10609,
      'escr;': 8495,
      'esdot;': 8784,
      'esim;': 8770,
      'eta;': 951,
      eth: 240,
      'eth;': 240,
      euml: 235,
      'euml;': 235,
      'euro;': 8364,
      'excl;': 33,
      'exist;': 8707,
      'expectation;': 8496,
      'exponentiale;': 8519,
      'fallingdotseq;': 8786,
      'fcy;': 1092,
      'female;': 9792,
      'ffilig;': 64259,
      'fflig;': 64256,
      'ffllig;': 64260,
      'ffr;': [55349, 56611],
      'filig;': 64257,
      'fjlig;': [102, 106],
      'flat;': 9837,
      'fllig;': 64258,
      'fltns;': 9649,
      'fnof;': 402,
      'fopf;': [55349, 56663],
      'forall;': 8704,
      'fork;': 8916,
      'forkv;': 10969,
      'fpartint;': 10765,
      frac12: 189,
      'frac12;': 189,
      'frac13;': 8531,
      frac14: 188,
      'frac14;': 188,
      'frac15;': 8533,
      'frac16;': 8537,
      'frac18;': 8539,
      'frac23;': 8532,
      'frac25;': 8534,
      frac34: 190,
      'frac34;': 190,
      'frac35;': 8535,
      'frac38;': 8540,
      'frac45;': 8536,
      'frac56;': 8538,
      'frac58;': 8541,
      'frac78;': 8542,
      'frasl;': 8260,
      'frown;': 8994,
      'fscr;': [55349, 56507],
      'gE;': 8807,
      'gEl;': 10892,
      'gacute;': 501,
      'gamma;': 947,
      'gammad;': 989,
      'gap;': 10886,
      'gbreve;': 287,
      'gcirc;': 285,
      'gcy;': 1075,
      'gdot;': 289,
      'ge;': 8805,
      'gel;': 8923,
      'geq;': 8805,
      'geqq;': 8807,
      'geqslant;': 10878,
      'ges;': 10878,
      'gescc;': 10921,
      'gesdot;': 10880,
      'gesdoto;': 10882,
      'gesdotol;': 10884,
      'gesl;': [8923, 65024],
      'gesles;': 10900,
      'gfr;': [55349, 56612],
      'gg;': 8811,
      'ggg;': 8921,
      'gimel;': 8503,
      'gjcy;': 1107,
      'gl;': 8823,
      'glE;': 10898,
      'gla;': 10917,
      'glj;': 10916,
      'gnE;': 8809,
      'gnap;': 10890,
      'gnapprox;': 10890,
      'gne;': 10888,
      'gneq;': 10888,
      'gneqq;': 8809,
      'gnsim;': 8935,
      'gopf;': [55349, 56664],
      'grave;': 96,
      'gscr;': 8458,
      'gsim;': 8819,
      'gsime;': 10894,
      'gsiml;': 10896,
      gt: 62,
      'gt;': 62,
      'gtcc;': 10919,
      'gtcir;': 10874,
      'gtdot;': 8919,
      'gtlPar;': 10645,
      'gtquest;': 10876,
      'gtrapprox;': 10886,
      'gtrarr;': 10616,
      'gtrdot;': 8919,
      'gtreqless;': 8923,
      'gtreqqless;': 10892,
      'gtrless;': 8823,
      'gtrsim;': 8819,
      'gvertneqq;': [8809, 65024],
      'gvnE;': [8809, 65024],
      'hArr;': 8660,
      'hairsp;': 8202,
      'half;': 189,
      'hamilt;': 8459,
      'hardcy;': 1098,
      'harr;': 8596,
      'harrcir;': 10568,
      'harrw;': 8621,
      'hbar;': 8463,
      'hcirc;': 293,
      'hearts;': 9829,
      'heartsuit;': 9829,
      'hellip;': 8230,
      'hercon;': 8889,
      'hfr;': [55349, 56613],
      'hksearow;': 10533,
      'hkswarow;': 10534,
      'hoarr;': 8703,
      'homtht;': 8763,
      'hookleftarrow;': 8617,
      'hookrightarrow;': 8618,
      'hopf;': [55349, 56665],
      'horbar;': 8213,
      'hscr;': [55349, 56509],
      'hslash;': 8463,
      'hstrok;': 295,
      'hybull;': 8259,
      'hyphen;': 8208,
      iacute: 237,
      'iacute;': 237,
      'ic;': 8291,
      icirc: 238,
      'icirc;': 238,
      'icy;': 1080,
      'iecy;': 1077,
      iexcl: 161,
      'iexcl;': 161,
      'iff;': 8660,
      'ifr;': [55349, 56614],
      igrave: 236,
      'igrave;': 236,
      'ii;': 8520,
      'iiiint;': 10764,
      'iiint;': 8749,
      'iinfin;': 10716,
      'iiota;': 8489,
      'ijlig;': 307,
      'imacr;': 299,
      'image;': 8465,
      'imagline;': 8464,
      'imagpart;': 8465,
      'imath;': 305,
      'imof;': 8887,
      'imped;': 437,
      'in;': 8712,
      'incare;': 8453,
      'infin;': 8734,
      'infintie;': 10717,
      'inodot;': 305,
      'int;': 8747,
      'intcal;': 8890,
      'integers;': 8484,
      'intercal;': 8890,
      'intlarhk;': 10775,
      'intprod;': 10812,
      'iocy;': 1105,
      'iogon;': 303,
      'iopf;': [55349, 56666],
      'iota;': 953,
      'iprod;': 10812,
      iquest: 191,
      'iquest;': 191,
      'iscr;': [55349, 56510],
      'isin;': 8712,
      'isinE;': 8953,
      'isindot;': 8949,
      'isins;': 8948,
      'isinsv;': 8947,
      'isinv;': 8712,
      'it;': 8290,
      'itilde;': 297,
      'iukcy;': 1110,
      iuml: 239,
      'iuml;': 239,
      'jcirc;': 309,
      'jcy;': 1081,
      'jfr;': [55349, 56615],
      'jmath;': 567,
      'jopf;': [55349, 56667],
      'jscr;': [55349, 56511],
      'jsercy;': 1112,
      'jukcy;': 1108,
      'kappa;': 954,
      'kappav;': 1008,
      'kcedil;': 311,
      'kcy;': 1082,
      'kfr;': [55349, 56616],
      'kgreen;': 312,
      'khcy;': 1093,
      'kjcy;': 1116,
      'kopf;': [55349, 56668],
      'kscr;': [55349, 56512],
      'lAarr;': 8666,
      'lArr;': 8656,
      'lAtail;': 10523,
      'lBarr;': 10510,
      'lE;': 8806,
      'lEg;': 10891,
      'lHar;': 10594,
      'lacute;': 314,
      'laemptyv;': 10676,
      'lagran;': 8466,
      'lambda;': 955,
      'lang;': 10216,
      'langd;': 10641,
      'langle;': 10216,
      'lap;': 10885,
      laquo: 171,
      'laquo;': 171,
      'larr;': 8592,
      'larrb;': 8676,
      'larrbfs;': 10527,
      'larrfs;': 10525,
      'larrhk;': 8617,
      'larrlp;': 8619,
      'larrpl;': 10553,
      'larrsim;': 10611,
      'larrtl;': 8610,
      'lat;': 10923,
      'latail;': 10521,
      'late;': 10925,
      'lates;': [10925, 65024],
      'lbarr;': 10508,
      'lbbrk;': 10098,
      'lbrace;': 123,
      'lbrack;': 91,
      'lbrke;': 10635,
      'lbrksld;': 10639,
      'lbrkslu;': 10637,
      'lcaron;': 318,
      'lcedil;': 316,
      'lceil;': 8968,
      'lcub;': 123,
      'lcy;': 1083,
      'ldca;': 10550,
      'ldquo;': 8220,
      'ldquor;': 8222,
      'ldrdhar;': 10599,
      'ldrushar;': 10571,
      'ldsh;': 8626,
      'le;': 8804,
      'leftarrow;': 8592,
      'leftarrowtail;': 8610,
      'leftharpoondown;': 8637,
      'leftharpoonup;': 8636,
      'leftleftarrows;': 8647,
      'leftrightarrow;': 8596,
      'leftrightarrows;': 8646,
      'leftrightharpoons;': 8651,
      'leftrightsquigarrow;': 8621,
      'leftthreetimes;': 8907,
      'leg;': 8922,
      'leq;': 8804,
      'leqq;': 8806,
      'leqslant;': 10877,
      'les;': 10877,
      'lescc;': 10920,
      'lesdot;': 10879,
      'lesdoto;': 10881,
      'lesdotor;': 10883,
      'lesg;': [8922, 65024],
      'lesges;': 10899,
      'lessapprox;': 10885,
      'lessdot;': 8918,
      'lesseqgtr;': 8922,
      'lesseqqgtr;': 10891,
      'lessgtr;': 8822,
      'lesssim;': 8818,
      'lfisht;': 10620,
      'lfloor;': 8970,
      'lfr;': [55349, 56617],
      'lg;': 8822,
      'lgE;': 10897,
      'lhard;': 8637,
      'lharu;': 8636,
      'lharul;': 10602,
      'lhblk;': 9604,
      'ljcy;': 1113,
      'll;': 8810,
      'llarr;': 8647,
      'llcorner;': 8990,
      'llhard;': 10603,
      'lltri;': 9722,
      'lmidot;': 320,
      'lmoust;': 9136,
      'lmoustache;': 9136,
      'lnE;': 8808,
      'lnap;': 10889,
      'lnapprox;': 10889,
      'lne;': 10887,
      'lneq;': 10887,
      'lneqq;': 8808,
      'lnsim;': 8934,
      'loang;': 10220,
      'loarr;': 8701,
      'lobrk;': 10214,
      'longleftarrow;': 10229,
      'longleftrightarrow;': 10231,
      'longmapsto;': 10236,
      'longrightarrow;': 10230,
      'looparrowleft;': 8619,
      'looparrowright;': 8620,
      'lopar;': 10629,
      'lopf;': [55349, 56669],
      'loplus;': 10797,
      'lotimes;': 10804,
      'lowast;': 8727,
      'lowbar;': 95,
      'loz;': 9674,
      'lozenge;': 9674,
      'lozf;': 10731,
      'lpar;': 40,
      'lparlt;': 10643,
      'lrarr;': 8646,
      'lrcorner;': 8991,
      'lrhar;': 8651,
      'lrhard;': 10605,
      'lrm;': 8206,
      'lrtri;': 8895,
      'lsaquo;': 8249,
      'lscr;': [55349, 56513],
      'lsh;': 8624,
      'lsim;': 8818,
      'lsime;': 10893,
      'lsimg;': 10895,
      'lsqb;': 91,
      'lsquo;': 8216,
      'lsquor;': 8218,
      'lstrok;': 322,
      lt: 60,
      'lt;': 60,
      'ltcc;': 10918,
      'ltcir;': 10873,
      'ltdot;': 8918,
      'lthree;': 8907,
      'ltimes;': 8905,
      'ltlarr;': 10614,
      'ltquest;': 10875,
      'ltrPar;': 10646,
      'ltri;': 9667,
      'ltrie;': 8884,
      'ltrif;': 9666,
      'lurdshar;': 10570,
      'luruhar;': 10598,
      'lvertneqq;': [8808, 65024],
      'lvnE;': [8808, 65024],
      'mDDot;': 8762,
      macr: 175,
      'macr;': 175,
      'male;': 9794,
      'malt;': 10016,
      'maltese;': 10016,
      'map;': 8614,
      'mapsto;': 8614,
      'mapstodown;': 8615,
      'mapstoleft;': 8612,
      'mapstoup;': 8613,
      'marker;': 9646,
      'mcomma;': 10793,
      'mcy;': 1084,
      'mdash;': 8212,
      'measuredangle;': 8737,
      'mfr;': [55349, 56618],
      'mho;': 8487,
      micro: 181,
      'micro;': 181,
      'mid;': 8739,
      'midast;': 42,
      'midcir;': 10992,
      middot: 183,
      'middot;': 183,
      'minus;': 8722,
      'minusb;': 8863,
      'minusd;': 8760,
      'minusdu;': 10794,
      'mlcp;': 10971,
      'mldr;': 8230,
      'mnplus;': 8723,
      'models;': 8871,
      'mopf;': [55349, 56670],
      'mp;': 8723,
      'mscr;': [55349, 56514],
      'mstpos;': 8766,
      'mu;': 956,
      'multimap;': 8888,
      'mumap;': 8888,
      'nGg;': [8921, 824],
      'nGt;': [8811, 8402],
      'nGtv;': [8811, 824],
      'nLeftarrow;': 8653,
      'nLeftrightarrow;': 8654,
      'nLl;': [8920, 824],
      'nLt;': [8810, 8402],
      'nLtv;': [8810, 824],
      'nRightarrow;': 8655,
      'nVDash;': 8879,
      'nVdash;': 8878,
      'nabla;': 8711,
      'nacute;': 324,
      'nang;': [8736, 8402],
      'nap;': 8777,
      'napE;': [10864, 824],
      'napid;': [8779, 824],
      'napos;': 329,
      'napprox;': 8777,
      'natur;': 9838,
      'natural;': 9838,
      'naturals;': 8469,
      nbsp: 160,
      'nbsp;': 160,
      'nbump;': [8782, 824],
      'nbumpe;': [8783, 824],
      'ncap;': 10819,
      'ncaron;': 328,
      'ncedil;': 326,
      'ncong;': 8775,
      'ncongdot;': [10861, 824],
      'ncup;': 10818,
      'ncy;': 1085,
      'ndash;': 8211,
      'ne;': 8800,
      'neArr;': 8663,
      'nearhk;': 10532,
      'nearr;': 8599,
      'nearrow;': 8599,
      'nedot;': [8784, 824],
      'nequiv;': 8802,
      'nesear;': 10536,
      'nesim;': [8770, 824],
      'nexist;': 8708,
      'nexists;': 8708,
      'nfr;': [55349, 56619],
      'ngE;': [8807, 824],
      'nge;': 8817,
      'ngeq;': 8817,
      'ngeqq;': [8807, 824],
      'ngeqslant;': [10878, 824],
      'nges;': [10878, 824],
      'ngsim;': 8821,
      'ngt;': 8815,
      'ngtr;': 8815,
      'nhArr;': 8654,
      'nharr;': 8622,
      'nhpar;': 10994,
      'ni;': 8715,
      'nis;': 8956,
      'nisd;': 8954,
      'niv;': 8715,
      'njcy;': 1114,
      'nlArr;': 8653,
      'nlE;': [8806, 824],
      'nlarr;': 8602,
      'nldr;': 8229,
      'nle;': 8816,
      'nleftarrow;': 8602,
      'nleftrightarrow;': 8622,
      'nleq;': 8816,
      'nleqq;': [8806, 824],
      'nleqslant;': [10877, 824],
      'nles;': [10877, 824],
      'nless;': 8814,
      'nlsim;': 8820,
      'nlt;': 8814,
      'nltri;': 8938,
      'nltrie;': 8940,
      'nmid;': 8740,
      'nopf;': [55349, 56671],
      not: 172,
      'not;': 172,
      'notin;': 8713,
      'notinE;': [8953, 824],
      'notindot;': [8949, 824],
      'notinva;': 8713,
      'notinvb;': 8951,
      'notinvc;': 8950,
      'notni;': 8716,
      'notniva;': 8716,
      'notnivb;': 8958,
      'notnivc;': 8957,
      'npar;': 8742,
      'nparallel;': 8742,
      'nparsl;': [11005, 8421],
      'npart;': [8706, 824],
      'npolint;': 10772,
      'npr;': 8832,
      'nprcue;': 8928,
      'npre;': [10927, 824],
      'nprec;': 8832,
      'npreceq;': [10927, 824],
      'nrArr;': 8655,
      'nrarr;': 8603,
      'nrarrc;': [10547, 824],
      'nrarrw;': [8605, 824],
      'nrightarrow;': 8603,
      'nrtri;': 8939,
      'nrtrie;': 8941,
      'nsc;': 8833,
      'nsccue;': 8929,
      'nsce;': [10928, 824],
      'nscr;': [55349, 56515],
      'nshortmid;': 8740,
      'nshortparallel;': 8742,
      'nsim;': 8769,
      'nsime;': 8772,
      'nsimeq;': 8772,
      'nsmid;': 8740,
      'nspar;': 8742,
      'nsqsube;': 8930,
      'nsqsupe;': 8931,
      'nsub;': 8836,
      'nsubE;': [10949, 824],
      'nsube;': 8840,
      'nsubset;': [8834, 8402],
      'nsubseteq;': 8840,
      'nsubseteqq;': [10949, 824],
      'nsucc;': 8833,
      'nsucceq;': [10928, 824],
      'nsup;': 8837,
      'nsupE;': [10950, 824],
      'nsupe;': 8841,
      'nsupset;': [8835, 8402],
      'nsupseteq;': 8841,
      'nsupseteqq;': [10950, 824],
      'ntgl;': 8825,
      ntilde: 241,
      'ntilde;': 241,
      'ntlg;': 8824,
      'ntriangleleft;': 8938,
      'ntrianglelefteq;': 8940,
      'ntriangleright;': 8939,
      'ntrianglerighteq;': 8941,
      'nu;': 957,
      'num;': 35,
      'numero;': 8470,
      'numsp;': 8199,
      'nvDash;': 8877,
      'nvHarr;': 10500,
      'nvap;': [8781, 8402],
      'nvdash;': 8876,
      'nvge;': [8805, 8402],
      'nvgt;': [62, 8402],
      'nvinfin;': 10718,
      'nvlArr;': 10498,
      'nvle;': [8804, 8402],
      'nvlt;': [60, 8402],
      'nvltrie;': [8884, 8402],
      'nvrArr;': 10499,
      'nvrtrie;': [8885, 8402],
      'nvsim;': [8764, 8402],
      'nwArr;': 8662,
      'nwarhk;': 10531,
      'nwarr;': 8598,
      'nwarrow;': 8598,
      'nwnear;': 10535,
      'oS;': 9416,
      oacute: 243,
      'oacute;': 243,
      'oast;': 8859,
      'ocir;': 8858,
      ocirc: 244,
      'ocirc;': 244,
      'ocy;': 1086,
      'odash;': 8861,
      'odblac;': 337,
      'odiv;': 10808,
      'odot;': 8857,
      'odsold;': 10684,
      'oelig;': 339,
      'ofcir;': 10687,
      'ofr;': [55349, 56620],
      'ogon;': 731,
      ograve: 242,
      'ograve;': 242,
      'ogt;': 10689,
      'ohbar;': 10677,
      'ohm;': 937,
      'oint;': 8750,
      'olarr;': 8634,
      'olcir;': 10686,
      'olcross;': 10683,
      'oline;': 8254,
      'olt;': 10688,
      'omacr;': 333,
      'omega;': 969,
      'omicron;': 959,
      'omid;': 10678,
      'ominus;': 8854,
      'oopf;': [55349, 56672],
      'opar;': 10679,
      'operp;': 10681,
      'oplus;': 8853,
      'or;': 8744,
      'orarr;': 8635,
      'ord;': 10845,
      'order;': 8500,
      'orderof;': 8500,
      ordf: 170,
      'ordf;': 170,
      ordm: 186,
      'ordm;': 186,
      'origof;': 8886,
      'oror;': 10838,
      'orslope;': 10839,
      'orv;': 10843,
      'oscr;': 8500,
      oslash: 248,
      'oslash;': 248,
      'osol;': 8856,
      otilde: 245,
      'otilde;': 245,
      'otimes;': 8855,
      'otimesas;': 10806,
      ouml: 246,
      'ouml;': 246,
      'ovbar;': 9021,
      'par;': 8741,
      para: 182,
      'para;': 182,
      'parallel;': 8741,
      'parsim;': 10995,
      'parsl;': 11005,
      'part;': 8706,
      'pcy;': 1087,
      'percnt;': 37,
      'period;': 46,
      'permil;': 8240,
      'perp;': 8869,
      'pertenk;': 8241,
      'pfr;': [55349, 56621],
      'phi;': 966,
      'phiv;': 981,
      'phmmat;': 8499,
      'phone;': 9742,
      'pi;': 960,
      'pitchfork;': 8916,
      'piv;': 982,
      'planck;': 8463,
      'planckh;': 8462,
      'plankv;': 8463,
      'plus;': 43,
      'plusacir;': 10787,
      'plusb;': 8862,
      'pluscir;': 10786,
      'plusdo;': 8724,
      'plusdu;': 10789,
      'pluse;': 10866,
      plusmn: 177,
      'plusmn;': 177,
      'plussim;': 10790,
      'plustwo;': 10791,
      'pm;': 177,
      'pointint;': 10773,
      'popf;': [55349, 56673],
      pound: 163,
      'pound;': 163,
      'pr;': 8826,
      'prE;': 10931,
      'prap;': 10935,
      'prcue;': 8828,
      'pre;': 10927,
      'prec;': 8826,
      'precapprox;': 10935,
      'preccurlyeq;': 8828,
      'preceq;': 10927,
      'precnapprox;': 10937,
      'precneqq;': 10933,
      'precnsim;': 8936,
      'precsim;': 8830,
      'prime;': 8242,
      'primes;': 8473,
      'prnE;': 10933,
      'prnap;': 10937,
      'prnsim;': 8936,
      'prod;': 8719,
      'profalar;': 9006,
      'profline;': 8978,
      'profsurf;': 8979,
      'prop;': 8733,
      'propto;': 8733,
      'prsim;': 8830,
      'prurel;': 8880,
      'pscr;': [55349, 56517],
      'psi;': 968,
      'puncsp;': 8200,
      'qfr;': [55349, 56622],
      'qint;': 10764,
      'qopf;': [55349, 56674],
      'qprime;': 8279,
      'qscr;': [55349, 56518],
      'quaternions;': 8461,
      'quatint;': 10774,
      'quest;': 63,
      'questeq;': 8799,
      quot: 34,
      'quot;': 34,
      'rAarr;': 8667,
      'rArr;': 8658,
      'rAtail;': 10524,
      'rBarr;': 10511,
      'rHar;': 10596,
      'race;': [8765, 817],
      'racute;': 341,
      'radic;': 8730,
      'raemptyv;': 10675,
      'rang;': 10217,
      'rangd;': 10642,
      'range;': 10661,
      'rangle;': 10217,
      raquo: 187,
      'raquo;': 187,
      'rarr;': 8594,
      'rarrap;': 10613,
      'rarrb;': 8677,
      'rarrbfs;': 10528,
      'rarrc;': 10547,
      'rarrfs;': 10526,
      'rarrhk;': 8618,
      'rarrlp;': 8620,
      'rarrpl;': 10565,
      'rarrsim;': 10612,
      'rarrtl;': 8611,
      'rarrw;': 8605,
      'ratail;': 10522,
      'ratio;': 8758,
      'rationals;': 8474,
      'rbarr;': 10509,
      'rbbrk;': 10099,
      'rbrace;': 125,
      'rbrack;': 93,
      'rbrke;': 10636,
      'rbrksld;': 10638,
      'rbrkslu;': 10640,
      'rcaron;': 345,
      'rcedil;': 343,
      'rceil;': 8969,
      'rcub;': 125,
      'rcy;': 1088,
      'rdca;': 10551,
      'rdldhar;': 10601,
      'rdquo;': 8221,
      'rdquor;': 8221,
      'rdsh;': 8627,
      'real;': 8476,
      'realine;': 8475,
      'realpart;': 8476,
      'reals;': 8477,
      'rect;': 9645,
      reg: 174,
      'reg;': 174,
      'rfisht;': 10621,
      'rfloor;': 8971,
      'rfr;': [55349, 56623],
      'rhard;': 8641,
      'rharu;': 8640,
      'rharul;': 10604,
      'rho;': 961,
      'rhov;': 1009,
      'rightarrow;': 8594,
      'rightarrowtail;': 8611,
      'rightharpoondown;': 8641,
      'rightharpoonup;': 8640,
      'rightleftarrows;': 8644,
      'rightleftharpoons;': 8652,
      'rightrightarrows;': 8649,
      'rightsquigarrow;': 8605,
      'rightthreetimes;': 8908,
      'ring;': 730,
      'risingdotseq;': 8787,
      'rlarr;': 8644,
      'rlhar;': 8652,
      'rlm;': 8207,
      'rmoust;': 9137,
      'rmoustache;': 9137,
      'rnmid;': 10990,
      'roang;': 10221,
      'roarr;': 8702,
      'robrk;': 10215,
      'ropar;': 10630,
      'ropf;': [55349, 56675],
      'roplus;': 10798,
      'rotimes;': 10805,
      'rpar;': 41,
      'rpargt;': 10644,
      'rppolint;': 10770,
      'rrarr;': 8649,
      'rsaquo;': 8250,
      'rscr;': [55349, 56519],
      'rsh;': 8625,
      'rsqb;': 93,
      'rsquo;': 8217,
      'rsquor;': 8217,
      'rthree;': 8908,
      'rtimes;': 8906,
      'rtri;': 9657,
      'rtrie;': 8885,
      'rtrif;': 9656,
      'rtriltri;': 10702,
      'ruluhar;': 10600,
      'rx;': 8478,
      'sacute;': 347,
      'sbquo;': 8218,
      'sc;': 8827,
      'scE;': 10932,
      'scap;': 10936,
      'scaron;': 353,
      'sccue;': 8829,
      'sce;': 10928,
      'scedil;': 351,
      'scirc;': 349,
      'scnE;': 10934,
      'scnap;': 10938,
      'scnsim;': 8937,
      'scpolint;': 10771,
      'scsim;': 8831,
      'scy;': 1089,
      'sdot;': 8901,
      'sdotb;': 8865,
      'sdote;': 10854,
      'seArr;': 8664,
      'searhk;': 10533,
      'searr;': 8600,
      'searrow;': 8600,
      sect: 167,
      'sect;': 167,
      'semi;': 59,
      'seswar;': 10537,
      'setminus;': 8726,
      'setmn;': 8726,
      'sext;': 10038,
      'sfr;': [55349, 56624],
      'sfrown;': 8994,
      'sharp;': 9839,
      'shchcy;': 1097,
      'shcy;': 1096,
      'shortmid;': 8739,
      'shortparallel;': 8741,
      shy: 173,
      'shy;': 173,
      'sigma;': 963,
      'sigmaf;': 962,
      'sigmav;': 962,
      'sim;': 8764,
      'simdot;': 10858,
      'sime;': 8771,
      'simeq;': 8771,
      'simg;': 10910,
      'simgE;': 10912,
      'siml;': 10909,
      'simlE;': 10911,
      'simne;': 8774,
      'simplus;': 10788,
      'simrarr;': 10610,
      'slarr;': 8592,
      'smallsetminus;': 8726,
      'smashp;': 10803,
      'smeparsl;': 10724,
      'smid;': 8739,
      'smile;': 8995,
      'smt;': 10922,
      'smte;': 10924,
      'smtes;': [10924, 65024],
      'softcy;': 1100,
      'sol;': 47,
      'solb;': 10692,
      'solbar;': 9023,
      'sopf;': [55349, 56676],
      'spades;': 9824,
      'spadesuit;': 9824,
      'spar;': 8741,
      'sqcap;': 8851,
      'sqcaps;': [8851, 65024],
      'sqcup;': 8852,
      'sqcups;': [8852, 65024],
      'sqsub;': 8847,
      'sqsube;': 8849,
      'sqsubset;': 8847,
      'sqsubseteq;': 8849,
      'sqsup;': 8848,
      'sqsupe;': 8850,
      'sqsupset;': 8848,
      'sqsupseteq;': 8850,
      'squ;': 9633,
      'square;': 9633,
      'squarf;': 9642,
      'squf;': 9642,
      'srarr;': 8594,
      'sscr;': [55349, 56520],
      'ssetmn;': 8726,
      'ssmile;': 8995,
      'sstarf;': 8902,
      'star;': 9734,
      'starf;': 9733,
      'straightepsilon;': 1013,
      'straightphi;': 981,
      'strns;': 175,
      'sub;': 8834,
      'subE;': 10949,
      'subdot;': 10941,
      'sube;': 8838,
      'subedot;': 10947,
      'submult;': 10945,
      'subnE;': 10955,
      'subne;': 8842,
      'subplus;': 10943,
      'subrarr;': 10617,
      'subset;': 8834,
      'subseteq;': 8838,
      'subseteqq;': 10949,
      'subsetneq;': 8842,
      'subsetneqq;': 10955,
      'subsim;': 10951,
      'subsub;': 10965,
      'subsup;': 10963,
      'succ;': 8827,
      'succapprox;': 10936,
      'succcurlyeq;': 8829,
      'succeq;': 10928,
      'succnapprox;': 10938,
      'succneqq;': 10934,
      'succnsim;': 8937,
      'succsim;': 8831,
      'sum;': 8721,
      'sung;': 9834,
      sup1: 185,
      'sup1;': 185,
      sup2: 178,
      'sup2;': 178,
      sup3: 179,
      'sup3;': 179,
      'sup;': 8835,
      'supE;': 10950,
      'supdot;': 10942,
      'supdsub;': 10968,
      'supe;': 8839,
      'supedot;': 10948,
      'suphsol;': 10185,
      'suphsub;': 10967,
      'suplarr;': 10619,
      'supmult;': 10946,
      'supnE;': 10956,
      'supne;': 8843,
      'supplus;': 10944,
      'supset;': 8835,
      'supseteq;': 8839,
      'supseteqq;': 10950,
      'supsetneq;': 8843,
      'supsetneqq;': 10956,
      'supsim;': 10952,
      'supsub;': 10964,
      'supsup;': 10966,
      'swArr;': 8665,
      'swarhk;': 10534,
      'swarr;': 8601,
      'swarrow;': 8601,
      'swnwar;': 10538,
      szlig: 223,
      'szlig;': 223,
      'target;': 8982,
      'tau;': 964,
      'tbrk;': 9140,
      'tcaron;': 357,
      'tcedil;': 355,
      'tcy;': 1090,
      'tdot;': 8411,
      'telrec;': 8981,
      'tfr;': [55349, 56625],
      'there4;': 8756,
      'therefore;': 8756,
      'theta;': 952,
      'thetasym;': 977,
      'thetav;': 977,
      'thickapprox;': 8776,
      'thicksim;': 8764,
      'thinsp;': 8201,
      'thkap;': 8776,
      'thksim;': 8764,
      thorn: 254,
      'thorn;': 254,
      'tilde;': 732,
      times: 215,
      'times;': 215,
      'timesb;': 8864,
      'timesbar;': 10801,
      'timesd;': 10800,
      'tint;': 8749,
      'toea;': 10536,
      'top;': 8868,
      'topbot;': 9014,
      'topcir;': 10993,
      'topf;': [55349, 56677],
      'topfork;': 10970,
      'tosa;': 10537,
      'tprime;': 8244,
      'trade;': 8482,
      'triangle;': 9653,
      'triangledown;': 9663,
      'triangleleft;': 9667,
      'trianglelefteq;': 8884,
      'triangleq;': 8796,
      'triangleright;': 9657,
      'trianglerighteq;': 8885,
      'tridot;': 9708,
      'trie;': 8796,
      'triminus;': 10810,
      'triplus;': 10809,
      'trisb;': 10701,
      'tritime;': 10811,
      'trpezium;': 9186,
      'tscr;': [55349, 56521],
      'tscy;': 1094,
      'tshcy;': 1115,
      'tstrok;': 359,
      'twixt;': 8812,
      'twoheadleftarrow;': 8606,
      'twoheadrightarrow;': 8608,
      'uArr;': 8657,
      'uHar;': 10595,
      uacute: 250,
      'uacute;': 250,
      'uarr;': 8593,
      'ubrcy;': 1118,
      'ubreve;': 365,
      ucirc: 251,
      'ucirc;': 251,
      'ucy;': 1091,
      'udarr;': 8645,
      'udblac;': 369,
      'udhar;': 10606,
      'ufisht;': 10622,
      'ufr;': [55349, 56626],
      ugrave: 249,
      'ugrave;': 249,
      'uharl;': 8639,
      'uharr;': 8638,
      'uhblk;': 9600,
      'ulcorn;': 8988,
      'ulcorner;': 8988,
      'ulcrop;': 8975,
      'ultri;': 9720,
      'umacr;': 363,
      uml: 168,
      'uml;': 168,
      'uogon;': 371,
      'uopf;': [55349, 56678],
      'uparrow;': 8593,
      'updownarrow;': 8597,
      'upharpoonleft;': 8639,
      'upharpoonright;': 8638,
      'uplus;': 8846,
      'upsi;': 965,
      'upsih;': 978,
      'upsilon;': 965,
      'upuparrows;': 8648,
      'urcorn;': 8989,
      'urcorner;': 8989,
      'urcrop;': 8974,
      'uring;': 367,
      'urtri;': 9721,
      'uscr;': [55349, 56522],
      'utdot;': 8944,
      'utilde;': 361,
      'utri;': 9653,
      'utrif;': 9652,
      'uuarr;': 8648,
      uuml: 252,
      'uuml;': 252,
      'uwangle;': 10663,
      'vArr;': 8661,
      'vBar;': 10984,
      'vBarv;': 10985,
      'vDash;': 8872,
      'vangrt;': 10652,
      'varepsilon;': 1013,
      'varkappa;': 1008,
      'varnothing;': 8709,
      'varphi;': 981,
      'varpi;': 982,
      'varpropto;': 8733,
      'varr;': 8597,
      'varrho;': 1009,
      'varsigma;': 962,
      'varsubsetneq;': [8842, 65024],
      'varsubsetneqq;': [10955, 65024],
      'varsupsetneq;': [8843, 65024],
      'varsupsetneqq;': [10956, 65024],
      'vartheta;': 977,
      'vartriangleleft;': 8882,
      'vartriangleright;': 8883,
      'vcy;': 1074,
      'vdash;': 8866,
      'vee;': 8744,
      'veebar;': 8891,
      'veeeq;': 8794,
      'vellip;': 8942,
      'verbar;': 124,
      'vert;': 124,
      'vfr;': [55349, 56627],
      'vltri;': 8882,
      'vnsub;': [8834, 8402],
      'vnsup;': [8835, 8402],
      'vopf;': [55349, 56679],
      'vprop;': 8733,
      'vrtri;': 8883,
      'vscr;': [55349, 56523],
      'vsubnE;': [10955, 65024],
      'vsubne;': [8842, 65024],
      'vsupnE;': [10956, 65024],
      'vsupne;': [8843, 65024],
      'vzigzag;': 10650,
      'wcirc;': 373,
      'wedbar;': 10847,
      'wedge;': 8743,
      'wedgeq;': 8793,
      'weierp;': 8472,
      'wfr;': [55349, 56628],
      'wopf;': [55349, 56680],
      'wp;': 8472,
      'wr;': 8768,
      'wreath;': 8768,
      'wscr;': [55349, 56524],
      'xcap;': 8898,
      'xcirc;': 9711,
      'xcup;': 8899,
      'xdtri;': 9661,
      'xfr;': [55349, 56629],
      'xhArr;': 10234,
      'xharr;': 10231,
      'xi;': 958,
      'xlArr;': 10232,
      'xlarr;': 10229,
      'xmap;': 10236,
      'xnis;': 8955,
      'xodot;': 10752,
      'xopf;': [55349, 56681],
      'xoplus;': 10753,
      'xotime;': 10754,
      'xrArr;': 10233,
      'xrarr;': 10230,
      'xscr;': [55349, 56525],
      'xsqcup;': 10758,
      'xuplus;': 10756,
      'xutri;': 9651,
      'xvee;': 8897,
      'xwedge;': 8896,
      yacute: 253,
      'yacute;': 253,
      'yacy;': 1103,
      'ycirc;': 375,
      'ycy;': 1099,
      yen: 165,
      'yen;': 165,
      'yfr;': [55349, 56630],
      'yicy;': 1111,
      'yopf;': [55349, 56682],
      'yscr;': [55349, 56526],
      'yucy;': 1102,
      yuml: 255,
      'yuml;': 255,
      'zacute;': 378,
      'zcaron;': 382,
      'zcy;': 1079,
      'zdot;': 380,
      'zeetrf;': 8488,
      'zeta;': 950,
      'zfr;': [55349, 56631],
      'zhcy;': 1078,
      'zigrarr;': 8669,
      'zopf;': [55349, 56683],
      'zscr;': [55349, 56527],
      'zwj;': 8205,
      'zwnj;': 8204,
    };
    var NAMEDCHARREF =
      /(A(?:Elig;?|MP;?|acute;?|breve;|c(?:irc;?|y;)|fr;|grave;?|lpha;|macr;|nd;|o(?:gon;|pf;)|pplyFunction;|ring;?|s(?:cr;|sign;)|tilde;?|uml;?)|B(?:a(?:ckslash;|r(?:v;|wed;))|cy;|e(?:cause;|rnoullis;|ta;)|fr;|opf;|reve;|scr;|umpeq;)|C(?:Hcy;|OPY;?|a(?:cute;|p(?:;|italDifferentialD;)|yleys;)|c(?:aron;|edil;?|irc;|onint;)|dot;|e(?:dilla;|nterDot;)|fr;|hi;|ircle(?:Dot;|Minus;|Plus;|Times;)|lo(?:ckwiseContourIntegral;|seCurly(?:DoubleQuote;|Quote;))|o(?:lon(?:;|e;)|n(?:gruent;|int;|tourIntegral;)|p(?:f;|roduct;)|unterClockwiseContourIntegral;)|ross;|scr;|up(?:;|Cap;))|D(?:D(?:;|otrahd;)|Jcy;|Scy;|Zcy;|a(?:gger;|rr;|shv;)|c(?:aron;|y;)|el(?:;|ta;)|fr;|i(?:a(?:critical(?:Acute;|Do(?:t;|ubleAcute;)|Grave;|Tilde;)|mond;)|fferentialD;)|o(?:pf;|t(?:;|Dot;|Equal;)|uble(?:ContourIntegral;|Do(?:t;|wnArrow;)|L(?:eft(?:Arrow;|RightArrow;|Tee;)|ong(?:Left(?:Arrow;|RightArrow;)|RightArrow;))|Right(?:Arrow;|Tee;)|Up(?:Arrow;|DownArrow;)|VerticalBar;)|wn(?:Arrow(?:;|Bar;|UpArrow;)|Breve;|Left(?:RightVector;|TeeVector;|Vector(?:;|Bar;))|Right(?:TeeVector;|Vector(?:;|Bar;))|Tee(?:;|Arrow;)|arrow;))|s(?:cr;|trok;))|E(?:NG;|TH;?|acute;?|c(?:aron;|irc;?|y;)|dot;|fr;|grave;?|lement;|m(?:acr;|pty(?:SmallSquare;|VerySmallSquare;))|o(?:gon;|pf;)|psilon;|qu(?:al(?:;|Tilde;)|ilibrium;)|s(?:cr;|im;)|ta;|uml;?|x(?:ists;|ponentialE;))|F(?:cy;|fr;|illed(?:SmallSquare;|VerySmallSquare;)|o(?:pf;|rAll;|uriertrf;)|scr;)|G(?:Jcy;|T;?|amma(?:;|d;)|breve;|c(?:edil;|irc;|y;)|dot;|fr;|g;|opf;|reater(?:Equal(?:;|Less;)|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|scr;|t;)|H(?:ARDcy;|a(?:cek;|t;)|circ;|fr;|ilbertSpace;|o(?:pf;|rizontalLine;)|s(?:cr;|trok;)|ump(?:DownHump;|Equal;))|I(?:Ecy;|Jlig;|Ocy;|acute;?|c(?:irc;?|y;)|dot;|fr;|grave;?|m(?:;|a(?:cr;|ginaryI;)|plies;)|n(?:t(?:;|e(?:gral;|rsection;))|visible(?:Comma;|Times;))|o(?:gon;|pf;|ta;)|scr;|tilde;|u(?:kcy;|ml;?))|J(?:c(?:irc;|y;)|fr;|opf;|s(?:cr;|ercy;)|ukcy;)|K(?:Hcy;|Jcy;|appa;|c(?:edil;|y;)|fr;|opf;|scr;)|L(?:Jcy;|T;?|a(?:cute;|mbda;|ng;|placetrf;|rr;)|c(?:aron;|edil;|y;)|e(?:ft(?:A(?:ngleBracket;|rrow(?:;|Bar;|RightArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|Right(?:Arrow;|Vector;)|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;|rightarrow;)|ss(?:EqualGreater;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;))|fr;|l(?:;|eftarrow;)|midot;|o(?:ng(?:Left(?:Arrow;|RightArrow;)|RightArrow;|left(?:arrow;|rightarrow;)|rightarrow;)|pf;|wer(?:LeftArrow;|RightArrow;))|s(?:cr;|h;|trok;)|t;)|M(?:ap;|cy;|e(?:diumSpace;|llintrf;)|fr;|inusPlus;|opf;|scr;|u;)|N(?:Jcy;|acute;|c(?:aron;|edil;|y;)|e(?:gative(?:MediumSpace;|Thi(?:ckSpace;|nSpace;)|VeryThinSpace;)|sted(?:GreaterGreater;|LessLess;)|wLine;)|fr;|o(?:Break;|nBreakingSpace;|pf;|t(?:;|C(?:ongruent;|upCap;)|DoubleVerticalBar;|E(?:lement;|qual(?:;|Tilde;)|xists;)|Greater(?:;|Equal;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|Hump(?:DownHump;|Equal;)|Le(?:ftTriangle(?:;|Bar;|Equal;)|ss(?:;|Equal;|Greater;|Less;|SlantEqual;|Tilde;))|Nested(?:GreaterGreater;|LessLess;)|Precedes(?:;|Equal;|SlantEqual;)|R(?:everseElement;|ightTriangle(?:;|Bar;|Equal;))|S(?:quareSu(?:bset(?:;|Equal;)|perset(?:;|Equal;))|u(?:bset(?:;|Equal;)|cceeds(?:;|Equal;|SlantEqual;|Tilde;)|perset(?:;|Equal;)))|Tilde(?:;|Equal;|FullEqual;|Tilde;)|VerticalBar;))|scr;|tilde;?|u;)|O(?:Elig;|acute;?|c(?:irc;?|y;)|dblac;|fr;|grave;?|m(?:acr;|ega;|icron;)|opf;|penCurly(?:DoubleQuote;|Quote;)|r;|s(?:cr;|lash;?)|ti(?:lde;?|mes;)|uml;?|ver(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;))|P(?:artialD;|cy;|fr;|hi;|i;|lusMinus;|o(?:incareplane;|pf;)|r(?:;|ecedes(?:;|Equal;|SlantEqual;|Tilde;)|ime;|o(?:duct;|portion(?:;|al;)))|s(?:cr;|i;))|Q(?:UOT;?|fr;|opf;|scr;)|R(?:Barr;|EG;?|a(?:cute;|ng;|rr(?:;|tl;))|c(?:aron;|edil;|y;)|e(?:;|verse(?:E(?:lement;|quilibrium;)|UpEquilibrium;))|fr;|ho;|ight(?:A(?:ngleBracket;|rrow(?:;|Bar;|LeftArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;)|o(?:pf;|undImplies;)|rightarrow;|s(?:cr;|h;)|uleDelayed;)|S(?:H(?:CHcy;|cy;)|OFTcy;|acute;|c(?:;|aron;|edil;|irc;|y;)|fr;|hort(?:DownArrow;|LeftArrow;|RightArrow;|UpArrow;)|igma;|mallCircle;|opf;|q(?:rt;|uare(?:;|Intersection;|Su(?:bset(?:;|Equal;)|perset(?:;|Equal;))|Union;))|scr;|tar;|u(?:b(?:;|set(?:;|Equal;))|c(?:ceeds(?:;|Equal;|SlantEqual;|Tilde;)|hThat;)|m;|p(?:;|erset(?:;|Equal;)|set;)))|T(?:HORN;?|RADE;|S(?:Hcy;|cy;)|a(?:b;|u;)|c(?:aron;|edil;|y;)|fr;|h(?:e(?:refore;|ta;)|i(?:ckSpace;|nSpace;))|ilde(?:;|Equal;|FullEqual;|Tilde;)|opf;|ripleDot;|s(?:cr;|trok;))|U(?:a(?:cute;?|rr(?:;|ocir;))|br(?:cy;|eve;)|c(?:irc;?|y;)|dblac;|fr;|grave;?|macr;|n(?:der(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;)|ion(?:;|Plus;))|o(?:gon;|pf;)|p(?:Arrow(?:;|Bar;|DownArrow;)|DownArrow;|Equilibrium;|Tee(?:;|Arrow;)|arrow;|downarrow;|per(?:LeftArrow;|RightArrow;)|si(?:;|lon;))|ring;|scr;|tilde;|uml;?)|V(?:Dash;|bar;|cy;|dash(?:;|l;)|e(?:e;|r(?:bar;|t(?:;|ical(?:Bar;|Line;|Separator;|Tilde;))|yThinSpace;))|fr;|opf;|scr;|vdash;)|W(?:circ;|edge;|fr;|opf;|scr;)|X(?:fr;|i;|opf;|scr;)|Y(?:Acy;|Icy;|Ucy;|acute;?|c(?:irc;|y;)|fr;|opf;|scr;|uml;)|Z(?:Hcy;|acute;|c(?:aron;|y;)|dot;|e(?:roWidthSpace;|ta;)|fr;|opf;|scr;)|a(?:acute;?|breve;|c(?:;|E;|d;|irc;?|ute;?|y;)|elig;?|f(?:;|r;)|grave;?|l(?:e(?:fsym;|ph;)|pha;)|m(?:a(?:cr;|lg;)|p;?)|n(?:d(?:;|and;|d;|slope;|v;)|g(?:;|e;|le;|msd(?:;|a(?:a;|b;|c;|d;|e;|f;|g;|h;))|rt(?:;|vb(?:;|d;))|s(?:ph;|t;)|zarr;))|o(?:gon;|pf;)|p(?:;|E;|acir;|e;|id;|os;|prox(?:;|eq;))|ring;?|s(?:cr;|t;|ymp(?:;|eq;))|tilde;?|uml;?|w(?:conint;|int;))|b(?:Not;|a(?:ck(?:cong;|epsilon;|prime;|sim(?:;|eq;))|r(?:vee;|wed(?:;|ge;)))|brk(?:;|tbrk;)|c(?:ong;|y;)|dquo;|e(?:caus(?:;|e;)|mptyv;|psi;|rnou;|t(?:a;|h;|ween;))|fr;|ig(?:c(?:ap;|irc;|up;)|o(?:dot;|plus;|times;)|s(?:qcup;|tar;)|triangle(?:down;|up;)|uplus;|vee;|wedge;)|karow;|l(?:a(?:ck(?:lozenge;|square;|triangle(?:;|down;|left;|right;))|nk;)|k(?:1(?:2;|4;)|34;)|ock;)|n(?:e(?:;|quiv;)|ot;)|o(?:pf;|t(?:;|tom;)|wtie;|x(?:D(?:L;|R;|l;|r;)|H(?:;|D;|U;|d;|u;)|U(?:L;|R;|l;|r;)|V(?:;|H;|L;|R;|h;|l;|r;)|box;|d(?:L;|R;|l;|r;)|h(?:;|D;|U;|d;|u;)|minus;|plus;|times;|u(?:L;|R;|l;|r;)|v(?:;|H;|L;|R;|h;|l;|r;)))|prime;|r(?:eve;|vbar;?)|s(?:cr;|emi;|im(?:;|e;)|ol(?:;|b;|hsub;))|u(?:ll(?:;|et;)|mp(?:;|E;|e(?:;|q;))))|c(?:a(?:cute;|p(?:;|and;|brcup;|c(?:ap;|up;)|dot;|s;)|r(?:et;|on;))|c(?:a(?:ps;|ron;)|edil;?|irc;|ups(?:;|sm;))|dot;|e(?:dil;?|mptyv;|nt(?:;|erdot;|))|fr;|h(?:cy;|eck(?:;|mark;)|i;)|ir(?:;|E;|c(?:;|eq;|le(?:arrow(?:left;|right;)|d(?:R;|S;|ast;|circ;|dash;)))|e;|fnint;|mid;|scir;)|lubs(?:;|uit;)|o(?:lon(?:;|e(?:;|q;))|m(?:ma(?:;|t;)|p(?:;|fn;|le(?:ment;|xes;)))|n(?:g(?:;|dot;)|int;)|p(?:f;|rod;|y(?:;|sr;|)))|r(?:arr;|oss;)|s(?:cr;|u(?:b(?:;|e;)|p(?:;|e;)))|tdot;|u(?:darr(?:l;|r;)|e(?:pr;|sc;)|larr(?:;|p;)|p(?:;|brcap;|c(?:ap;|up;)|dot;|or;|s;)|r(?:arr(?:;|m;)|ly(?:eq(?:prec;|succ;)|vee;|wedge;)|ren;?|vearrow(?:left;|right;))|vee;|wed;)|w(?:conint;|int;)|ylcty;)|d(?:Arr;|Har;|a(?:gger;|leth;|rr;|sh(?:;|v;))|b(?:karow;|lac;)|c(?:aron;|y;)|d(?:;|a(?:gger;|rr;)|otseq;)|e(?:g;?|lta;|mptyv;)|f(?:isht;|r;)|har(?:l;|r;)|i(?:am(?:;|ond(?:;|suit;)|s;)|e;|gamma;|sin;|v(?:;|ide(?:;|ontimes;|)|onx;))|jcy;|lc(?:orn;|rop;)|o(?:llar;|pf;|t(?:;|eq(?:;|dot;)|minus;|plus;|square;)|ublebarwedge;|wn(?:arrow;|downarrows;|harpoon(?:left;|right;)))|r(?:bkarow;|c(?:orn;|rop;))|s(?:c(?:r;|y;)|ol;|trok;)|t(?:dot;|ri(?:;|f;))|u(?:arr;|har;)|wangle;|z(?:cy;|igrarr;))|e(?:D(?:Dot;|ot;)|a(?:cute;?|ster;)|c(?:aron;|ir(?:;|c;?)|olon;|y;)|dot;|e;|f(?:Dot;|r;)|g(?:;|rave;?|s(?:;|dot;))|l(?:;|inters;|l;|s(?:;|dot;))|m(?:acr;|pty(?:;|set;|v;)|sp(?:1(?:3;|4;)|;))|n(?:g;|sp;)|o(?:gon;|pf;)|p(?:ar(?:;|sl;)|lus;|si(?:;|lon;|v;))|q(?:c(?:irc;|olon;)|s(?:im;|lant(?:gtr;|less;))|u(?:als;|est;|iv(?:;|DD;))|vparsl;)|r(?:Dot;|arr;)|s(?:cr;|dot;|im;)|t(?:a;|h;?)|u(?:ml;?|ro;)|x(?:cl;|ist;|p(?:ectation;|onentiale;)))|f(?:allingdotseq;|cy;|emale;|f(?:ilig;|l(?:ig;|lig;)|r;)|ilig;|jlig;|l(?:at;|lig;|tns;)|nof;|o(?:pf;|r(?:all;|k(?:;|v;)))|partint;|r(?:a(?:c(?:1(?:2;?|3;|4;?|5;|6;|8;)|2(?:3;|5;)|3(?:4;?|5;|8;)|45;|5(?:6;|8;)|78;)|sl;)|own;)|scr;)|g(?:E(?:;|l;)|a(?:cute;|mma(?:;|d;)|p;)|breve;|c(?:irc;|y;)|dot;|e(?:;|l;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|l;))|l(?:;|es;)))|fr;|g(?:;|g;)|imel;|jcy;|l(?:;|E;|a;|j;)|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|opf;|rave;|s(?:cr;|im(?:;|e;|l;))|t(?:;|c(?:c;|ir;)|dot;|lPar;|quest;|r(?:a(?:pprox;|rr;)|dot;|eq(?:less;|qless;)|less;|sim;)|)|v(?:ertneqq;|nE;))|h(?:Arr;|a(?:irsp;|lf;|milt;|r(?:dcy;|r(?:;|cir;|w;)))|bar;|circ;|e(?:arts(?:;|uit;)|llip;|rcon;)|fr;|ks(?:earow;|warow;)|o(?:arr;|mtht;|ok(?:leftarrow;|rightarrow;)|pf;|rbar;)|s(?:cr;|lash;|trok;)|y(?:bull;|phen;))|i(?:acute;?|c(?:;|irc;?|y;)|e(?:cy;|xcl;?)|f(?:f;|r;)|grave;?|i(?:;|i(?:int;|nt;)|nfin;|ota;)|jlig;|m(?:a(?:cr;|g(?:e;|line;|part;)|th;)|of;|ped;)|n(?:;|care;|fin(?:;|tie;)|odot;|t(?:;|cal;|e(?:gers;|rcal;)|larhk;|prod;))|o(?:cy;|gon;|pf;|ta;)|prod;|quest;?|s(?:cr;|in(?:;|E;|dot;|s(?:;|v;)|v;))|t(?:;|ilde;)|u(?:kcy;|ml;?))|j(?:c(?:irc;|y;)|fr;|math;|opf;|s(?:cr;|ercy;)|ukcy;)|k(?:appa(?:;|v;)|c(?:edil;|y;)|fr;|green;|hcy;|jcy;|opf;|scr;)|l(?:A(?:arr;|rr;|tail;)|Barr;|E(?:;|g;)|Har;|a(?:cute;|emptyv;|gran;|mbda;|ng(?:;|d;|le;)|p;|quo;?|rr(?:;|b(?:;|fs;)|fs;|hk;|lp;|pl;|sim;|tl;)|t(?:;|ail;|e(?:;|s;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|quo(?:;|r;)|r(?:dhar;|ushar;)|sh;)|e(?:;|ft(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|leftarrows;|right(?:arrow(?:;|s;)|harpoons;|squigarrow;)|threetimes;)|g;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|r;))|g(?:;|es;)|s(?:approx;|dot;|eq(?:gtr;|qgtr;)|gtr;|sim;)))|f(?:isht;|loor;|r;)|g(?:;|E;)|h(?:ar(?:d;|u(?:;|l;))|blk;)|jcy;|l(?:;|arr;|corner;|hard;|tri;)|m(?:idot;|oust(?:;|ache;))|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|o(?:a(?:ng;|rr;)|brk;|ng(?:left(?:arrow;|rightarrow;)|mapsto;|rightarrow;)|oparrow(?:left;|right;)|p(?:ar;|f;|lus;)|times;|w(?:ast;|bar;)|z(?:;|enge;|f;))|par(?:;|lt;)|r(?:arr;|corner;|har(?:;|d;)|m;|tri;)|s(?:aquo;|cr;|h;|im(?:;|e;|g;)|q(?:b;|uo(?:;|r;))|trok;)|t(?:;|c(?:c;|ir;)|dot;|hree;|imes;|larr;|quest;|r(?:Par;|i(?:;|e;|f;))|)|ur(?:dshar;|uhar;)|v(?:ertneqq;|nE;))|m(?:DDot;|a(?:cr;?|l(?:e;|t(?:;|ese;))|p(?:;|sto(?:;|down;|left;|up;))|rker;)|c(?:omma;|y;)|dash;|easuredangle;|fr;|ho;|i(?:cro;?|d(?:;|ast;|cir;|dot;?)|nus(?:;|b;|d(?:;|u;)))|l(?:cp;|dr;)|nplus;|o(?:dels;|pf;)|p;|s(?:cr;|tpos;)|u(?:;|ltimap;|map;))|n(?:G(?:g;|t(?:;|v;))|L(?:eft(?:arrow;|rightarrow;)|l;|t(?:;|v;))|Rightarrow;|V(?:Dash;|dash;)|a(?:bla;|cute;|ng;|p(?:;|E;|id;|os;|prox;)|tur(?:;|al(?:;|s;)))|b(?:sp;?|ump(?:;|e;))|c(?:a(?:p;|ron;)|edil;|ong(?:;|dot;)|up;|y;)|dash;|e(?:;|Arr;|ar(?:hk;|r(?:;|ow;))|dot;|quiv;|s(?:ear;|im;)|xist(?:;|s;))|fr;|g(?:E;|e(?:;|q(?:;|q;|slant;)|s;)|sim;|t(?:;|r;))|h(?:Arr;|arr;|par;)|i(?:;|s(?:;|d;)|v;)|jcy;|l(?:Arr;|E;|arr;|dr;|e(?:;|ft(?:arrow;|rightarrow;)|q(?:;|q;|slant;)|s(?:;|s;))|sim;|t(?:;|ri(?:;|e;)))|mid;|o(?:pf;|t(?:;|in(?:;|E;|dot;|v(?:a;|b;|c;))|ni(?:;|v(?:a;|b;|c;))|))|p(?:ar(?:;|allel;|sl;|t;)|olint;|r(?:;|cue;|e(?:;|c(?:;|eq;))))|r(?:Arr;|arr(?:;|c;|w;)|ightarrow;|tri(?:;|e;))|s(?:c(?:;|cue;|e;|r;)|hort(?:mid;|parallel;)|im(?:;|e(?:;|q;))|mid;|par;|qsu(?:be;|pe;)|u(?:b(?:;|E;|e;|set(?:;|eq(?:;|q;)))|cc(?:;|eq;)|p(?:;|E;|e;|set(?:;|eq(?:;|q;)))))|t(?:gl;|ilde;?|lg;|riangle(?:left(?:;|eq;)|right(?:;|eq;)))|u(?:;|m(?:;|ero;|sp;))|v(?:Dash;|Harr;|ap;|dash;|g(?:e;|t;)|infin;|l(?:Arr;|e;|t(?:;|rie;))|r(?:Arr;|trie;)|sim;)|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|near;))|o(?:S;|a(?:cute;?|st;)|c(?:ir(?:;|c;?)|y;)|d(?:ash;|blac;|iv;|ot;|sold;)|elig;|f(?:cir;|r;)|g(?:on;|rave;?|t;)|h(?:bar;|m;)|int;|l(?:arr;|c(?:ir;|ross;)|ine;|t;)|m(?:acr;|ega;|i(?:cron;|d;|nus;))|opf;|p(?:ar;|erp;|lus;)|r(?:;|arr;|d(?:;|er(?:;|of;)|f;?|m;?)|igof;|or;|slope;|v;)|s(?:cr;|lash;?|ol;)|ti(?:lde;?|mes(?:;|as;))|uml;?|vbar;)|p(?:ar(?:;|a(?:;|llel;|)|s(?:im;|l;)|t;)|cy;|er(?:cnt;|iod;|mil;|p;|tenk;)|fr;|h(?:i(?:;|v;)|mmat;|one;)|i(?:;|tchfork;|v;)|l(?:an(?:ck(?:;|h;)|kv;)|us(?:;|acir;|b;|cir;|d(?:o;|u;)|e;|mn;?|sim;|two;))|m;|o(?:intint;|pf;|und;?)|r(?:;|E;|ap;|cue;|e(?:;|c(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;))|ime(?:;|s;)|n(?:E;|ap;|sim;)|o(?:d;|f(?:alar;|line;|surf;)|p(?:;|to;))|sim;|urel;)|s(?:cr;|i;)|uncsp;)|q(?:fr;|int;|opf;|prime;|scr;|u(?:at(?:ernions;|int;)|est(?:;|eq;)|ot;?))|r(?:A(?:arr;|rr;|tail;)|Barr;|Har;|a(?:c(?:e;|ute;)|dic;|emptyv;|ng(?:;|d;|e;|le;)|quo;?|rr(?:;|ap;|b(?:;|fs;)|c;|fs;|hk;|lp;|pl;|sim;|tl;|w;)|t(?:ail;|io(?:;|nals;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|ldhar;|quo(?:;|r;)|sh;)|e(?:al(?:;|ine;|part;|s;)|ct;|g;?)|f(?:isht;|loor;|r;)|h(?:ar(?:d;|u(?:;|l;))|o(?:;|v;))|i(?:ght(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|left(?:arrows;|harpoons;)|rightarrows;|squigarrow;|threetimes;)|ng;|singdotseq;)|l(?:arr;|har;|m;)|moust(?:;|ache;)|nmid;|o(?:a(?:ng;|rr;)|brk;|p(?:ar;|f;|lus;)|times;)|p(?:ar(?:;|gt;)|polint;)|rarr;|s(?:aquo;|cr;|h;|q(?:b;|uo(?:;|r;)))|t(?:hree;|imes;|ri(?:;|e;|f;|ltri;))|uluhar;|x;)|s(?:acute;|bquo;|c(?:;|E;|a(?:p;|ron;)|cue;|e(?:;|dil;)|irc;|n(?:E;|ap;|sim;)|polint;|sim;|y;)|dot(?:;|b;|e;)|e(?:Arr;|ar(?:hk;|r(?:;|ow;))|ct;?|mi;|swar;|tm(?:inus;|n;)|xt;)|fr(?:;|own;)|h(?:arp;|c(?:hcy;|y;)|ort(?:mid;|parallel;)|y;?)|i(?:gma(?:;|f;|v;)|m(?:;|dot;|e(?:;|q;)|g(?:;|E;)|l(?:;|E;)|ne;|plus;|rarr;))|larr;|m(?:a(?:llsetminus;|shp;)|eparsl;|i(?:d;|le;)|t(?:;|e(?:;|s;)))|o(?:ftcy;|l(?:;|b(?:;|ar;))|pf;)|pa(?:des(?:;|uit;)|r;)|q(?:c(?:ap(?:;|s;)|up(?:;|s;))|su(?:b(?:;|e;|set(?:;|eq;))|p(?:;|e;|set(?:;|eq;)))|u(?:;|ar(?:e;|f;)|f;))|rarr;|s(?:cr;|etmn;|mile;|tarf;)|t(?:ar(?:;|f;)|r(?:aight(?:epsilon;|phi;)|ns;))|u(?:b(?:;|E;|dot;|e(?:;|dot;)|mult;|n(?:E;|e;)|plus;|rarr;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;)))|cc(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;)|m;|ng;|p(?:1;?|2;?|3;?|;|E;|d(?:ot;|sub;)|e(?:;|dot;)|hs(?:ol;|ub;)|larr;|mult;|n(?:E;|e;)|plus;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;))))|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|nwar;)|zlig;?)|t(?:a(?:rget;|u;)|brk;|c(?:aron;|edil;|y;)|dot;|elrec;|fr;|h(?:e(?:re(?:4;|fore;)|ta(?:;|sym;|v;))|i(?:ck(?:approx;|sim;)|nsp;)|k(?:ap;|sim;)|orn;?)|i(?:lde;|mes(?:;|b(?:;|ar;)|d;|)|nt;)|o(?:ea;|p(?:;|bot;|cir;|f(?:;|ork;))|sa;)|prime;|r(?:ade;|i(?:angle(?:;|down;|left(?:;|eq;)|q;|right(?:;|eq;))|dot;|e;|minus;|plus;|sb;|time;)|pezium;)|s(?:c(?:r;|y;)|hcy;|trok;)|w(?:ixt;|ohead(?:leftarrow;|rightarrow;)))|u(?:Arr;|Har;|a(?:cute;?|rr;)|br(?:cy;|eve;)|c(?:irc;?|y;)|d(?:arr;|blac;|har;)|f(?:isht;|r;)|grave;?|h(?:ar(?:l;|r;)|blk;)|l(?:c(?:orn(?:;|er;)|rop;)|tri;)|m(?:acr;|l;?)|o(?:gon;|pf;)|p(?:arrow;|downarrow;|harpoon(?:left;|right;)|lus;|si(?:;|h;|lon;)|uparrows;)|r(?:c(?:orn(?:;|er;)|rop;)|ing;|tri;)|scr;|t(?:dot;|ilde;|ri(?:;|f;))|u(?:arr;|ml;?)|wangle;)|v(?:Arr;|Bar(?:;|v;)|Dash;|a(?:ngrt;|r(?:epsilon;|kappa;|nothing;|p(?:hi;|i;|ropto;)|r(?:;|ho;)|s(?:igma;|u(?:bsetneq(?:;|q;)|psetneq(?:;|q;)))|t(?:heta;|riangle(?:left;|right;))))|cy;|dash;|e(?:e(?:;|bar;|eq;)|llip;|r(?:bar;|t;))|fr;|ltri;|nsu(?:b;|p;)|opf;|prop;|rtri;|s(?:cr;|u(?:bn(?:E;|e;)|pn(?:E;|e;)))|zigzag;)|w(?:circ;|e(?:d(?:bar;|ge(?:;|q;))|ierp;)|fr;|opf;|p;|r(?:;|eath;)|scr;)|x(?:c(?:ap;|irc;|up;)|dtri;|fr;|h(?:Arr;|arr;)|i;|l(?:Arr;|arr;)|map;|nis;|o(?:dot;|p(?:f;|lus;)|time;)|r(?:Arr;|arr;)|s(?:cr;|qcup;)|u(?:plus;|tri;)|vee;|wedge;)|y(?:ac(?:ute;?|y;)|c(?:irc;|y;)|en;?|fr;|icy;|opf;|scr;|u(?:cy;|ml;?))|z(?:acute;|c(?:aron;|y;)|dot;|e(?:etrf;|ta;)|fr;|hcy;|igrarr;|opf;|scr;|w(?:j;|nj;)))|[\s\S]/g;
    var NAMEDCHARREF_MAXLEN = 32;
    var DBLQUOTEATTRVAL = /[^\r"&\u0000]+/g;
    var SINGLEQUOTEATTRVAL = /[^\r'&\u0000]+/g;
    var UNQUOTEDATTRVAL = /[^\r\t\n\f &>\u0000]+/g;
    var TAGNAME = /[^\r\t\n\f \/>A-Z\u0000]+/g;
    var ATTRNAME = /[^\r\t\n\f \/=>A-Z\u0000]+/g;
    var CDATATEXT = /[^\]\r\u0000\uffff]*/g;
    var DATATEXT = /[^&<\r\u0000\uffff]*/g;
    var RAWTEXT = /[^<\r\u0000\uffff]*/g;
    var PLAINTEXT = /[^\r\u0000\uffff]*/g;
    var SIMPLETAG = /(?:(\/)?([a-z]+)>)|[\s\S]/g;
    var SIMPLEATTR =
      /(?:([-a-z]+)[ \t\n\f]*=[ \t\n\f]*('[^'&\r\u0000]*'|"[^"&\r\u0000]*"|[^\t\n\r\f "&'\u0000>][^&> \t\n\r\f\u0000]*[ \t\n\f]))|[\s\S]/g;
    var NONWS = /[^\x09\x0A\x0C\x0D\x20]/;
    var ALLNONWS = /[^\x09\x0A\x0C\x0D\x20]/g;
    var NONWSNONNUL = /[^\x00\x09\x0A\x0C\x0D\x20]/;
    var LEADINGWS = /^[\x09\x0A\x0C\x0D\x20]+/;
    var NULCHARS = /\x00/g;
    function buf2str(buf) {
      var CHUNKSIZE = 16384;
      if (buf.length < CHUNKSIZE) {
        return String.fromCharCode.apply(String, buf);
      }
      var result = '';
      for (var i = 0; i < buf.length; i += CHUNKSIZE) {
        result += String.fromCharCode.apply(String, buf.slice(i, i + CHUNKSIZE));
      }
      return result;
    }
    function str2buf(s) {
      var result = [];
      for (var i = 0; i < s.length; i++) {
        result[i] = s.charCodeAt(i);
      }
      return result;
    }
    function isA(elt, set) {
      if (typeof set === 'string') {
        return elt.namespaceURI === NAMESPACE.HTML && elt.localName === set;
      }
      var tagnames = set[elt.namespaceURI];
      return tagnames && tagnames[elt.localName];
    }
    function isMathmlTextIntegrationPoint(n) {
      return isA(n, mathmlTextIntegrationPointSet);
    }
    function isHTMLIntegrationPoint(n) {
      if (isA(n, htmlIntegrationPointSet)) return true;
      if (n.namespaceURI === NAMESPACE.MATHML && n.localName === 'annotation-xml') {
        var encoding = n.getAttribute('encoding');
        if (encoding) encoding = encoding.toLowerCase();
        if (encoding === 'text/html' || encoding === 'application/xhtml+xml') return true;
      }
      return false;
    }
    function adjustSVGTagName(name) {
      if (name in svgTagNameAdjustments) return svgTagNameAdjustments[name];
      else return name;
    }
    function adjustSVGAttributes(attrs) {
      for (var i = 0, n = attrs.length; i < n; i++) {
        if (attrs[i][0] in svgAttrAdjustments) {
          attrs[i][0] = svgAttrAdjustments[attrs[i][0]];
        }
      }
    }
    function adjustMathMLAttributes(attrs) {
      for (var i = 0, n = attrs.length; i < n; i++) {
        if (attrs[i][0] === 'definitionurl') {
          attrs[i][0] = 'definitionURL';
          break;
        }
      }
    }
    function adjustForeignAttributes(attrs) {
      for (var i = 0, n = attrs.length; i < n; i++) {
        if (attrs[i][0] in foreignAttributes) {
          attrs[i].push(foreignAttributes[attrs[i][0]]);
        }
      }
    }
    function transferAttributes(attrs, elt) {
      for (var i = 0, n = attrs.length; i < n; i++) {
        var name = attrs[i][0],
          value = attrs[i][1];
        if (elt.hasAttribute(name)) continue;
        elt._setAttribute(name, value);
      }
    }
    HTMLParser.ElementStack = function ElementStack() {
      this.elements = [];
      this.top = null;
    };
    HTMLParser.ElementStack.prototype.push = function (e) {
      this.elements.push(e);
      this.top = e;
    };
    HTMLParser.ElementStack.prototype.pop = function (e) {
      this.elements.pop();
      this.top = this.elements[this.elements.length - 1];
    };
    HTMLParser.ElementStack.prototype.popTag = function (tag) {
      for (var i = this.elements.length - 1; i > 0; i--) {
        var e = this.elements[i];
        if (isA(e, tag)) break;
      }
      this.elements.length = i;
      this.top = this.elements[i - 1];
    };
    HTMLParser.ElementStack.prototype.popElementType = function (type) {
      for (var i = this.elements.length - 1; i > 0; i--) {
        if (this.elements[i] instanceof type) break;
      }
      this.elements.length = i;
      this.top = this.elements[i - 1];
    };
    HTMLParser.ElementStack.prototype.popElement = function (e) {
      for (var i = this.elements.length - 1; i > 0; i--) {
        if (this.elements[i] === e) break;
      }
      this.elements.length = i;
      this.top = this.elements[i - 1];
    };
    HTMLParser.ElementStack.prototype.removeElement = function (e) {
      if (this.top === e) this.pop();
      else {
        var idx = this.elements.lastIndexOf(e);
        if (idx !== -1) this.elements.splice(idx, 1);
      }
    };
    HTMLParser.ElementStack.prototype.clearToContext = function (set) {
      for (var i = this.elements.length - 1; i > 0; i--) {
        if (isA(this.elements[i], set)) break;
      }
      this.elements.length = i + 1;
      this.top = this.elements[i];
    };
    HTMLParser.ElementStack.prototype.contains = function (tag) {
      return this.inSpecificScope(tag, /* @__PURE__ */ Object.create(null));
    };
    HTMLParser.ElementStack.prototype.inSpecificScope = function (tag, set) {
      for (var i = this.elements.length - 1; i >= 0; i--) {
        var elt = this.elements[i];
        if (isA(elt, tag)) return true;
        if (isA(elt, set)) return false;
      }
      return false;
    };
    HTMLParser.ElementStack.prototype.elementInSpecificScope = function (target, set) {
      for (var i = this.elements.length - 1; i >= 0; i--) {
        var elt = this.elements[i];
        if (elt === target) return true;
        if (isA(elt, set)) return false;
      }
      return false;
    };
    HTMLParser.ElementStack.prototype.elementTypeInSpecificScope = function (target, set) {
      for (var i = this.elements.length - 1; i >= 0; i--) {
        var elt = this.elements[i];
        if (elt instanceof target) return true;
        if (isA(elt, set)) return false;
      }
      return false;
    };
    HTMLParser.ElementStack.prototype.inScope = function (tag) {
      return this.inSpecificScope(tag, inScopeSet);
    };
    HTMLParser.ElementStack.prototype.elementInScope = function (e) {
      return this.elementInSpecificScope(e, inScopeSet);
    };
    HTMLParser.ElementStack.prototype.elementTypeInScope = function (type) {
      return this.elementTypeInSpecificScope(type, inScopeSet);
    };
    HTMLParser.ElementStack.prototype.inButtonScope = function (tag) {
      return this.inSpecificScope(tag, inButtonScopeSet);
    };
    HTMLParser.ElementStack.prototype.inListItemScope = function (tag) {
      return this.inSpecificScope(tag, inListItemScopeSet);
    };
    HTMLParser.ElementStack.prototype.inTableScope = function (tag) {
      return this.inSpecificScope(tag, inTableScopeSet);
    };
    HTMLParser.ElementStack.prototype.inSelectScope = function (tag) {
      for (var i = this.elements.length - 1; i >= 0; i--) {
        var elt = this.elements[i];
        if (elt.namespaceURI !== NAMESPACE.HTML) return false;
        var localname = elt.localName;
        if (localname === tag) return true;
        if (localname !== 'optgroup' && localname !== 'option') return false;
      }
      return false;
    };
    HTMLParser.ElementStack.prototype.generateImpliedEndTags = function (butnot, thorough) {
      var endTagSet = thorough ? thoroughImpliedEndTagsSet : impliedEndTagsSet;
      for (var i = this.elements.length - 1; i >= 0; i--) {
        var e = this.elements[i];
        if (butnot && isA(e, butnot)) break;
        if (!isA(this.elements[i], endTagSet)) break;
      }
      this.elements.length = i + 1;
      this.top = this.elements[i];
    };
    HTMLParser.ActiveFormattingElements = function AFE() {
      this.list = [];
      this.attrs = [];
    };
    HTMLParser.ActiveFormattingElements.prototype.MARKER = { localName: '|' };
    HTMLParser.ActiveFormattingElements.prototype.insertMarker = function () {
      this.list.push(this.MARKER);
      this.attrs.push(this.MARKER);
    };
    HTMLParser.ActiveFormattingElements.prototype.push = function (elt, attrs) {
      var count = 0;
      for (var i = this.list.length - 1; i >= 0; i--) {
        if (this.list[i] === this.MARKER) break;
        if (equal(elt, this.list[i], this.attrs[i])) {
          count++;
          if (count === 3) {
            this.list.splice(i, 1);
            this.attrs.splice(i, 1);
            break;
          }
        }
      }
      this.list.push(elt);
      var attrcopy = [];
      for (var ii = 0; ii < attrs.length; ii++) {
        attrcopy[ii] = attrs[ii];
      }
      this.attrs.push(attrcopy);
      function equal(newelt, oldelt, oldattrs) {
        if (newelt.localName !== oldelt.localName) return false;
        if (newelt._numattrs !== oldattrs.length) return false;
        for (var i2 = 0, n = oldattrs.length; i2 < n; i2++) {
          var oldname = oldattrs[i2][0];
          var oldval = oldattrs[i2][1];
          if (!newelt.hasAttribute(oldname)) return false;
          if (newelt.getAttribute(oldname) !== oldval) return false;
        }
        return true;
      }
    };
    HTMLParser.ActiveFormattingElements.prototype.clearToMarker = function () {
      for (var i = this.list.length - 1; i >= 0; i--) {
        if (this.list[i] === this.MARKER) break;
      }
      if (i < 0) i = 0;
      this.list.length = i;
      this.attrs.length = i;
    };
    HTMLParser.ActiveFormattingElements.prototype.findElementByTag = function (tag) {
      for (var i = this.list.length - 1; i >= 0; i--) {
        var elt = this.list[i];
        if (elt === this.MARKER) break;
        if (elt.localName === tag) return elt;
      }
      return null;
    };
    HTMLParser.ActiveFormattingElements.prototype.indexOf = function (e) {
      return this.list.lastIndexOf(e);
    };
    HTMLParser.ActiveFormattingElements.prototype.remove = function (e) {
      var idx = this.list.lastIndexOf(e);
      if (idx !== -1) {
        this.list.splice(idx, 1);
        this.attrs.splice(idx, 1);
      }
    };
    HTMLParser.ActiveFormattingElements.prototype.replace = function (a, b, attrs) {
      var idx = this.list.lastIndexOf(a);
      if (idx !== -1) {
        this.list[idx] = b;
        this.attrs[idx] = attrs;
      }
    };
    HTMLParser.ActiveFormattingElements.prototype.insertAfter = function (a, b) {
      var idx = this.list.lastIndexOf(a);
      if (idx !== -1) {
        this.list.splice(idx, 0, b);
        this.attrs.splice(idx, 0, b);
      }
    };
    function HTMLParser(address, fragmentContext, options2) {
      var chars = null;
      var numchars = 0;
      var nextchar = 0;
      var input_complete = false;
      var scanner_skip_newline = false;
      var reentrant_invocations = 0;
      var saved_scanner_state = [];
      var leftovers = '';
      var first_batch = true;
      var paused = 0;
      var tokenizer = data_state;
      var return_state;
      var character_reference_code;
      var tagnamebuf = '';
      var lasttagname = '';
      var tempbuf = [];
      var attrnamebuf = '';
      var attrvaluebuf = '';
      var commentbuf = [];
      var doctypenamebuf = [];
      var doctypepublicbuf = [];
      var doctypesystembuf = [];
      var attributes = [];
      var is_end_tag = false;
      var parser = initial_mode;
      var originalInsertionMode = null;
      var templateInsertionModes = [];
      var stack = new HTMLParser.ElementStack();
      var afe = new HTMLParser.ActiveFormattingElements();
      var fragment = fragmentContext !== void 0;
      var head_element_pointer = null;
      var form_element_pointer = null;
      var scripting_enabled = true;
      if (fragmentContext) {
        scripting_enabled = fragmentContext.ownerDocument._scripting_enabled;
      }
      if (options2 && options2.scripting_enabled === false) scripting_enabled = false;
      var frameset_ok = true;
      var force_quirks = false;
      var pending_table_text;
      var text_integration_mode;
      var textrun = [];
      var textIncludesNUL = false;
      var ignore_linefeed = false;
      var htmlparser = {
        document: function () {
          return doc;
        },
        // Convenience function for internal use. Can only be called once,
        // as it removes the nodes from `doc` to add them to fragment.
        _asDocumentFragment: function () {
          var frag = doc.createDocumentFragment();
          var root2 = doc.firstChild;
          while (root2.hasChildNodes()) {
            frag.appendChild(root2.firstChild);
          }
          return frag;
        },
        // Internal function used from HTMLScriptElement to pause the
        // parser while a script is being loaded from the network
        pause: function () {
          paused++;
        },
        // Called when a script finishes loading
        resume: function () {
          paused--;
          this.parse('');
        },
        // Parse the HTML text s.
        // The second argument should be true if there is no more
        // text to be parsed, and should be false or omitted otherwise.
        // The second argument must not be set for recursive invocations
        // from document.write()
        parse: function (s, end, shouldPauseFunc) {
          var moreToDo;
          if (paused > 0) {
            leftovers += s;
            return true;
          }
          if (reentrant_invocations === 0) {
            if (leftovers) {
              s = leftovers + s;
              leftovers = '';
            }
            if (end) {
              s += '\uFFFF';
              input_complete = true;
            }
            chars = s;
            numchars = s.length;
            nextchar = 0;
            if (first_batch) {
              first_batch = false;
              if (chars.charCodeAt(0) === 65279) nextchar = 1;
            }
            reentrant_invocations++;
            moreToDo = scanChars(shouldPauseFunc);
            leftovers = chars.substring(nextchar, numchars);
            reentrant_invocations--;
          } else {
            reentrant_invocations++;
            saved_scanner_state.push(chars, numchars, nextchar);
            chars = s;
            numchars = s.length;
            nextchar = 0;
            scanChars();
            moreToDo = false;
            leftovers = chars.substring(nextchar, numchars);
            nextchar = saved_scanner_state.pop();
            numchars = saved_scanner_state.pop();
            chars = saved_scanner_state.pop();
            if (leftovers) {
              chars = leftovers + chars.substring(nextchar);
              numchars = chars.length;
              nextchar = 0;
              leftovers = '';
            }
            reentrant_invocations--;
          }
          return moreToDo;
        },
      };
      var doc = new Document(true, address);
      doc._parser = htmlparser;
      doc._scripting_enabled = scripting_enabled;
      if (fragmentContext) {
        if (fragmentContext.ownerDocument._quirks) doc._quirks = true;
        if (fragmentContext.ownerDocument._limitedQuirks) doc._limitedQuirks = true;
        if (fragmentContext.namespaceURI === NAMESPACE.HTML) {
          switch (fragmentContext.localName) {
            case 'title':
            case 'textarea':
              tokenizer = rcdata_state;
              break;
            case 'style':
            case 'xmp':
            case 'iframe':
            case 'noembed':
            case 'noframes':
            case 'script':
            case 'plaintext':
              tokenizer = plaintext_state;
              break;
          }
        }
        var root = doc.createElement('html');
        doc._appendChild(root);
        stack.push(root);
        if (fragmentContext instanceof impl.HTMLTemplateElement) {
          templateInsertionModes.push(in_template_mode);
        }
        resetInsertionMode();
        for (var e = fragmentContext; e !== null; e = e.parentElement) {
          if (e instanceof impl.HTMLFormElement) {
            form_element_pointer = e;
            break;
          }
        }
      }
      function scanChars(shouldPauseFunc) {
        var codepoint, s, pattern, eof;
        while (nextchar < numchars) {
          if (paused > 0 || (shouldPauseFunc && shouldPauseFunc())) {
            return true;
          }
          switch (typeof tokenizer.lookahead) {
            case 'undefined':
              codepoint = chars.charCodeAt(nextchar++);
              if (scanner_skip_newline) {
                scanner_skip_newline = false;
                if (codepoint === 10) {
                  nextchar++;
                  continue;
                }
              }
              switch (codepoint) {
                case 13:
                  if (nextchar < numchars) {
                    if (chars.charCodeAt(nextchar) === 10) nextchar++;
                  } else {
                    scanner_skip_newline = true;
                  }
                  tokenizer(10);
                  break;
                case 65535:
                  if (input_complete && nextchar === numchars) {
                    tokenizer(EOF);
                    break;
                  }
                /* falls through */
                default:
                  tokenizer(codepoint);
                  break;
              }
              break;
            case 'number':
              codepoint = chars.charCodeAt(nextchar);
              var n = tokenizer.lookahead;
              var needsString = true;
              if (n < 0) {
                needsString = false;
                n = -n;
              }
              if (n < numchars - nextchar) {
                s = needsString ? chars.substring(nextchar, nextchar + n) : null;
                eof = false;
              } else {
                if (input_complete) {
                  s = needsString ? chars.substring(nextchar, numchars) : null;
                  eof = true;
                  if (codepoint === 65535 && nextchar === numchars - 1) codepoint = EOF;
                } else {
                  return true;
                }
              }
              tokenizer(codepoint, s, eof);
              break;
            case 'string':
              codepoint = chars.charCodeAt(nextchar);
              pattern = tokenizer.lookahead;
              var pos = chars.indexOf(pattern, nextchar);
              if (pos !== -1) {
                s = chars.substring(nextchar, pos + pattern.length);
                eof = false;
              } else {
                if (!input_complete) return true;
                s = chars.substring(nextchar, numchars);
                if (codepoint === 65535 && nextchar === numchars - 1) codepoint = EOF;
                eof = true;
              }
              tokenizer(codepoint, s, eof);
              break;
          }
        }
        return false;
      }
      function addAttribute(name, value) {
        for (var i = 0; i < attributes.length; i++) {
          if (attributes[i][0] === name) return;
        }
        if (value !== void 0) {
          attributes.push([name, value]);
        } else {
          attributes.push([name]);
        }
      }
      function handleSimpleAttribute() {
        SIMPLEATTR.lastIndex = nextchar - 1;
        var matched = SIMPLEATTR.exec(chars);
        if (!matched) throw new Error('should never happen');
        var name = matched[1];
        if (!name) return false;
        var value = matched[2];
        var len = value.length;
        switch (value[0]) {
          case '"':
          case "'":
            value = value.substring(1, len - 1);
            nextchar += matched[0].length - 1;
            tokenizer = after_attribute_value_quoted_state;
            break;
          default:
            tokenizer = before_attribute_name_state;
            nextchar += matched[0].length - 1;
            value = value.substring(0, len - 1);
            break;
        }
        for (var i = 0; i < attributes.length; i++) {
          if (attributes[i][0] === name) return true;
        }
        attributes.push([name, value]);
        return true;
      }
      function beginTagName() {
        is_end_tag = false;
        tagnamebuf = '';
        attributes.length = 0;
      }
      function beginEndTagName() {
        is_end_tag = true;
        tagnamebuf = '';
        attributes.length = 0;
      }
      function beginTempBuf() {
        tempbuf.length = 0;
      }
      function beginAttrName() {
        attrnamebuf = '';
      }
      function beginAttrValue() {
        attrvaluebuf = '';
      }
      function beginComment() {
        commentbuf.length = 0;
      }
      function beginDoctype() {
        doctypenamebuf.length = 0;
        doctypepublicbuf = null;
        doctypesystembuf = null;
      }
      function beginDoctypePublicId() {
        doctypepublicbuf = [];
      }
      function beginDoctypeSystemId() {
        doctypesystembuf = [];
      }
      function forcequirks() {
        force_quirks = true;
      }
      function cdataAllowed() {
        return stack.top && stack.top.namespaceURI !== 'http://www.w3.org/1999/xhtml';
      }
      function appropriateEndTag(buf) {
        return lasttagname === buf;
      }
      function flushText() {
        if (textrun.length > 0) {
          var s = buf2str(textrun);
          textrun.length = 0;
          if (ignore_linefeed) {
            ignore_linefeed = false;
            if (s[0] === '\n') s = s.substring(1);
            if (s.length === 0) return;
          }
          insertToken(TEXT, s);
          textIncludesNUL = false;
        }
        ignore_linefeed = false;
      }
      function getMatchingChars(pattern) {
        pattern.lastIndex = nextchar - 1;
        var match = pattern.exec(chars);
        if (match && match.index === nextchar - 1) {
          match = match[0];
          nextchar += match.length - 1;
          if (input_complete && nextchar === numchars) {
            match = match.slice(0, -1);
            nextchar--;
          }
          return match;
        } else {
          throw new Error('should never happen');
        }
      }
      function emitCharsWhile(pattern) {
        pattern.lastIndex = nextchar - 1;
        var match = pattern.exec(chars)[0];
        if (!match) return false;
        emitCharString(match);
        nextchar += match.length - 1;
        return true;
      }
      function emitCharString(s) {
        if (textrun.length > 0) flushText();
        if (ignore_linefeed) {
          ignore_linefeed = false;
          if (s[0] === '\n') s = s.substring(1);
          if (s.length === 0) return;
        }
        insertToken(TEXT, s);
      }
      function emitTag() {
        if (is_end_tag) insertToken(ENDTAG, tagnamebuf);
        else {
          var tagname = tagnamebuf;
          tagnamebuf = '';
          lasttagname = tagname;
          insertToken(TAG, tagname, attributes);
        }
      }
      function emitSimpleTag() {
        if (nextchar === numchars) {
          return false;
        }
        SIMPLETAG.lastIndex = nextchar;
        var matched = SIMPLETAG.exec(chars);
        if (!matched) throw new Error('should never happen');
        var tagname = matched[2];
        if (!tagname) return false;
        var endtag = matched[1];
        if (endtag) {
          nextchar += tagname.length + 2;
          insertToken(ENDTAG, tagname);
        } else {
          nextchar += tagname.length + 1;
          lasttagname = tagname;
          insertToken(TAG, tagname, NOATTRS);
        }
        return true;
      }
      function emitSelfClosingTag() {
        if (is_end_tag) insertToken(ENDTAG, tagnamebuf, null, true);
        else {
          insertToken(TAG, tagnamebuf, attributes, true);
        }
      }
      function emitDoctype() {
        insertToken(
          DOCTYPE,
          buf2str(doctypenamebuf),
          doctypepublicbuf ? buf2str(doctypepublicbuf) : void 0,
          doctypesystembuf ? buf2str(doctypesystembuf) : void 0,
        );
      }
      function emitEOF() {
        flushText();
        parser(EOF);
        doc.modclock = 1;
      }
      var insertToken = (htmlparser.insertToken = function insertToken2(t, value, arg3, arg4) {
        flushText();
        var current = stack.top;
        if (!current || current.namespaceURI === NAMESPACE.HTML) {
          parser(t, value, arg3, arg4);
        } else {
          if (t !== TAG && t !== TEXT) {
            insertForeignToken(t, value, arg3, arg4);
          } else {
            if (
              (isMathmlTextIntegrationPoint(current) &&
                (t === TEXT || (t === TAG && value !== 'mglyph' && value !== 'malignmark'))) ||
              (t === TAG &&
                value === 'svg' &&
                current.namespaceURI === NAMESPACE.MATHML &&
                current.localName === 'annotation-xml') ||
              isHTMLIntegrationPoint(current)
            ) {
              text_integration_mode = true;
              parser(t, value, arg3, arg4);
              text_integration_mode = false;
            } else {
              insertForeignToken(t, value, arg3, arg4);
            }
          }
        }
      });
      function insertComment(data) {
        var parent = stack.top;
        if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
          fosterParent(function (doc2) {
            return doc2.createComment(data);
          });
        } else {
          if (parent instanceof impl.HTMLTemplateElement) {
            parent = parent.content;
          }
          parent._appendChild(parent.ownerDocument.createComment(data));
        }
      }
      function insertText(s) {
        var parent = stack.top;
        if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
          fosterParent(function (doc2) {
            return doc2.createTextNode(s);
          });
        } else {
          if (parent instanceof impl.HTMLTemplateElement) {
            parent = parent.content;
          }
          var lastChild = parent.lastChild;
          if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
            lastChild.appendData(s);
          } else {
            parent._appendChild(parent.ownerDocument.createTextNode(s));
          }
        }
      }
      function createHTMLElt(doc2, name, attrs) {
        var elt = html.createElement(doc2, name, null);
        if (attrs) {
          for (var i = 0, n = attrs.length; i < n; i++) {
            elt._setAttribute(attrs[i][0], attrs[i][1]);
          }
        }
        return elt;
      }
      var foster_parent_mode = false;
      function insertHTMLElement(name, attrs) {
        var elt = insertElement(function (doc2) {
          return createHTMLElt(doc2, name, attrs);
        });
        if (isA(elt, formassociatedSet)) {
          elt._form = form_element_pointer;
        }
        return elt;
      }
      function insertElement(eltFunc) {
        var elt;
        if (foster_parent_mode && isA(stack.top, tablesectionrowSet)) {
          elt = fosterParent(eltFunc);
        } else if (stack.top instanceof impl.HTMLTemplateElement) {
          elt = eltFunc(stack.top.content.ownerDocument);
          stack.top.content._appendChild(elt);
        } else {
          elt = eltFunc(stack.top.ownerDocument);
          stack.top._appendChild(elt);
        }
        stack.push(elt);
        return elt;
      }
      function insertForeignElement(name, attrs, ns) {
        return insertElement(function (doc2) {
          var elt = doc2._createElementNS(name, ns, null);
          if (attrs) {
            for (var i = 0, n = attrs.length; i < n; i++) {
              var attr = attrs[i];
              if (attr.length === 2) elt._setAttribute(attr[0], attr[1]);
              else {
                elt._setAttributeNS(attr[2], attr[0], attr[1]);
              }
            }
          }
          return elt;
        });
      }
      function lastElementOfType(type) {
        for (var i = stack.elements.length - 1; i >= 0; i--) {
          if (stack.elements[i] instanceof type) {
            return i;
          }
        }
        return -1;
      }
      function fosterParent(eltFunc) {
        var parent,
          before,
          lastTable = -1,
          lastTemplate = -1,
          elt;
        lastTable = lastElementOfType(impl.HTMLTableElement);
        lastTemplate = lastElementOfType(impl.HTMLTemplateElement);
        if (lastTemplate >= 0 && (lastTable < 0 || lastTemplate > lastTable)) {
          parent = stack.elements[lastTemplate];
        } else if (lastTable >= 0) {
          parent = stack.elements[lastTable].parentNode;
          if (parent) {
            before = stack.elements[lastTable];
          } else {
            parent = stack.elements[lastTable - 1];
          }
        }
        if (!parent) parent = stack.elements[0];
        if (parent instanceof impl.HTMLTemplateElement) {
          parent = parent.content;
        }
        elt = eltFunc(parent.ownerDocument);
        if (elt.nodeType === Node.TEXT_NODE) {
          var prev;
          if (before) prev = before.previousSibling;
          else prev = parent.lastChild;
          if (prev && prev.nodeType === Node.TEXT_NODE) {
            prev.appendData(elt.data);
            return elt;
          }
        }
        if (before) parent.insertBefore(elt, before);
        else parent._appendChild(elt);
        return elt;
      }
      function resetInsertionMode() {
        var last = false;
        for (var i = stack.elements.length - 1; i >= 0; i--) {
          var node = stack.elements[i];
          if (i === 0) {
            last = true;
            if (fragment) {
              node = fragmentContext;
            }
          }
          if (node.namespaceURI === NAMESPACE.HTML) {
            var tag = node.localName;
            switch (tag) {
              case 'select':
                for (var j = i; j > 0; ) {
                  var ancestor = stack.elements[--j];
                  if (ancestor instanceof impl.HTMLTemplateElement) {
                    break;
                  } else if (ancestor instanceof impl.HTMLTableElement) {
                    parser = in_select_in_table_mode;
                    return;
                  }
                }
                parser = in_select_mode;
                return;
              case 'tr':
                parser = in_row_mode;
                return;
              case 'tbody':
              case 'tfoot':
              case 'thead':
                parser = in_table_body_mode;
                return;
              case 'caption':
                parser = in_caption_mode;
                return;
              case 'colgroup':
                parser = in_column_group_mode;
                return;
              case 'table':
                parser = in_table_mode;
                return;
              case 'template':
                parser = templateInsertionModes[templateInsertionModes.length - 1];
                return;
              case 'body':
                parser = in_body_mode;
                return;
              case 'frameset':
                parser = in_frameset_mode;
                return;
              case 'html':
                if (head_element_pointer === null) {
                  parser = before_head_mode;
                } else {
                  parser = after_head_mode;
                }
                return;
              default:
                if (!last) {
                  if (tag === 'head') {
                    parser = in_head_mode;
                    return;
                  }
                  if (tag === 'td' || tag === 'th') {
                    parser = in_cell_mode;
                    return;
                  }
                }
            }
          }
          if (last) {
            parser = in_body_mode;
            return;
          }
        }
      }
      function parseRawText(name, attrs) {
        insertHTMLElement(name, attrs);
        tokenizer = rawtext_state;
        originalInsertionMode = parser;
        parser = text_mode;
      }
      function parseRCDATA(name, attrs) {
        insertHTMLElement(name, attrs);
        tokenizer = rcdata_state;
        originalInsertionMode = parser;
        parser = text_mode;
      }
      function afeclone(doc2, i) {
        return {
          elt: createHTMLElt(doc2, afe.list[i].localName, afe.attrs[i]),
          attrs: afe.attrs[i],
        };
      }
      function afereconstruct() {
        if (afe.list.length === 0) return;
        var entry = afe.list[afe.list.length - 1];
        if (entry === afe.MARKER) return;
        if (stack.elements.lastIndexOf(entry) !== -1) return;
        for (var i = afe.list.length - 2; i >= 0; i--) {
          entry = afe.list[i];
          if (entry === afe.MARKER) break;
          if (stack.elements.lastIndexOf(entry) !== -1) break;
        }
        for (i = i + 1; i < afe.list.length; i++) {
          var newelt = insertElement(function (doc2) {
            return afeclone(doc2, i).elt;
          });
          afe.list[i] = newelt;
        }
      }
      var BOOKMARK = { localName: 'BM' };
      function adoptionAgency(tag) {
        if (isA(stack.top, tag) && afe.indexOf(stack.top) === -1) {
          stack.pop();
          return true;
        }
        var outer = 0;
        while (outer < 8) {
          outer++;
          var fmtelt = afe.findElementByTag(tag);
          if (!fmtelt) {
            return false;
          }
          var index = stack.elements.lastIndexOf(fmtelt);
          if (index === -1) {
            afe.remove(fmtelt);
            return true;
          }
          if (!stack.elementInScope(fmtelt)) {
            return true;
          }
          var furthestblock = null,
            furthestblockindex;
          for (var i = index + 1; i < stack.elements.length; i++) {
            if (isA(stack.elements[i], specialSet)) {
              furthestblock = stack.elements[i];
              furthestblockindex = i;
              break;
            }
          }
          if (!furthestblock) {
            stack.popElement(fmtelt);
            afe.remove(fmtelt);
            return true;
          } else {
            var ancestor = stack.elements[index - 1];
            afe.insertAfter(fmtelt, BOOKMARK);
            var node = furthestblock;
            var lastnode = furthestblock;
            var nodeindex = furthestblockindex;
            var nodeafeindex;
            var inner = 0;
            while (true) {
              inner++;
              node = stack.elements[--nodeindex];
              if (node === fmtelt) break;
              nodeafeindex = afe.indexOf(node);
              if (inner > 3 && nodeafeindex !== -1) {
                afe.remove(node);
                nodeafeindex = -1;
              }
              if (nodeafeindex === -1) {
                stack.removeElement(node);
                continue;
              }
              var newelt = afeclone(ancestor.ownerDocument, nodeafeindex);
              afe.replace(node, newelt.elt, newelt.attrs);
              stack.elements[nodeindex] = newelt.elt;
              node = newelt.elt;
              if (lastnode === furthestblock) {
                afe.remove(BOOKMARK);
                afe.insertAfter(newelt.elt, BOOKMARK);
              }
              node._appendChild(lastnode);
              lastnode = node;
            }
            if (foster_parent_mode && isA(ancestor, tablesectionrowSet)) {
              fosterParent(function () {
                return lastnode;
              });
            } else if (ancestor instanceof impl.HTMLTemplateElement) {
              ancestor.content._appendChild(lastnode);
            } else {
              ancestor._appendChild(lastnode);
            }
            var newelt2 = afeclone(furthestblock.ownerDocument, afe.indexOf(fmtelt));
            while (furthestblock.hasChildNodes()) {
              newelt2.elt._appendChild(furthestblock.firstChild);
            }
            furthestblock._appendChild(newelt2.elt);
            afe.remove(fmtelt);
            afe.replace(BOOKMARK, newelt2.elt, newelt2.attrs);
            stack.removeElement(fmtelt);
            var pos = stack.elements.lastIndexOf(furthestblock);
            stack.elements.splice(pos + 1, 0, newelt2.elt);
          }
        }
        return true;
      }
      function handleScriptEnd() {
        stack.pop();
        parser = originalInsertionMode;
        return;
      }
      function stopParsing() {
        delete doc._parser;
        stack.elements.length = 0;
        if (doc.defaultView) {
          doc.defaultView.dispatchEvent(new impl.Event('load', {}));
        }
      }
      function reconsume(c, new_state) {
        tokenizer = new_state;
        nextchar--;
      }
      function data_state(c) {
        switch (c) {
          case 38:
            return_state = data_state;
            tokenizer = character_reference_state;
            break;
          case 60:
            if (emitSimpleTag()) break;
            tokenizer = tag_open_state;
            break;
          case 0:
            textrun.push(c);
            textIncludesNUL = true;
            break;
          case -1:
            emitEOF();
            break;
          default:
            emitCharsWhile(DATATEXT) || textrun.push(c);
            break;
        }
      }
      function rcdata_state(c) {
        switch (c) {
          case 38:
            return_state = rcdata_state;
            tokenizer = character_reference_state;
            break;
          case 60:
            tokenizer = rcdata_less_than_sign_state;
            break;
          case 0:
            textrun.push(65533);
            textIncludesNUL = true;
            break;
          case -1:
            emitEOF();
            break;
          default:
            textrun.push(c);
            break;
        }
      }
      function rawtext_state(c) {
        switch (c) {
          case 60:
            tokenizer = rawtext_less_than_sign_state;
            break;
          case 0:
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            emitCharsWhile(RAWTEXT) || textrun.push(c);
            break;
        }
      }
      function script_data_state(c) {
        switch (c) {
          case 60:
            tokenizer = script_data_less_than_sign_state;
            break;
          case 0:
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            emitCharsWhile(RAWTEXT) || textrun.push(c);
            break;
        }
      }
      function plaintext_state(c) {
        switch (c) {
          case 0:
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            emitCharsWhile(PLAINTEXT) || textrun.push(c);
            break;
        }
      }
      function tag_open_state(c) {
        switch (c) {
          case 33:
            tokenizer = markup_declaration_open_state;
            break;
          case 47:
            tokenizer = end_tag_open_state;
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginTagName();
            reconsume(c, tag_name_state);
            break;
          case 63:
            reconsume(c, bogus_comment_state);
            break;
          default:
            textrun.push(60);
            reconsume(c, data_state);
            break;
        }
      }
      function end_tag_open_state(c) {
        switch (c) {
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginEndTagName();
            reconsume(c, tag_name_state);
            break;
          case 62:
            tokenizer = data_state;
            break;
          case -1:
            textrun.push(60);
            textrun.push(47);
            emitEOF();
            break;
          default:
            reconsume(c, bogus_comment_state);
            break;
        }
      }
      function tag_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = before_attribute_name_state;
            break;
          case 47:
            tokenizer = self_closing_start_tag_state;
            break;
          case 62:
            tokenizer = data_state;
            emitTag();
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tagnamebuf += String.fromCharCode(c + 32);
            break;
          case 0:
            tagnamebuf += String.fromCharCode(
              65533,
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            emitEOF();
            break;
          default:
            tagnamebuf += getMatchingChars(TAGNAME);
            break;
        }
      }
      function rcdata_less_than_sign_state(c) {
        if (c === 47) {
          beginTempBuf();
          tokenizer = rcdata_end_tag_open_state;
        } else {
          textrun.push(60);
          reconsume(c, rcdata_state);
        }
      }
      function rcdata_end_tag_open_state(c) {
        switch (c) {
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginEndTagName();
            reconsume(c, rcdata_end_tag_name_state);
            break;
          default:
            textrun.push(60);
            textrun.push(47);
            reconsume(c, rcdata_state);
            break;
        }
      }
      function rcdata_end_tag_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = before_attribute_name_state;
              return;
            }
            break;
          case 47:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = self_closing_start_tag_state;
              return;
            }
            break;
          case 62:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = data_state;
              emitTag();
              return;
            }
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tagnamebuf += String.fromCharCode(c + 32);
            tempbuf.push(c);
            return;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tagnamebuf += String.fromCharCode(c);
            tempbuf.push(c);
            return;
          default:
            break;
        }
        textrun.push(60);
        textrun.push(47);
        pushAll(textrun, tempbuf);
        reconsume(c, rcdata_state);
      }
      function rawtext_less_than_sign_state(c) {
        if (c === 47) {
          beginTempBuf();
          tokenizer = rawtext_end_tag_open_state;
        } else {
          textrun.push(60);
          reconsume(c, rawtext_state);
        }
      }
      function rawtext_end_tag_open_state(c) {
        switch (c) {
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginEndTagName();
            reconsume(c, rawtext_end_tag_name_state);
            break;
          default:
            textrun.push(60);
            textrun.push(47);
            reconsume(c, rawtext_state);
            break;
        }
      }
      function rawtext_end_tag_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = before_attribute_name_state;
              return;
            }
            break;
          case 47:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = self_closing_start_tag_state;
              return;
            }
            break;
          case 62:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = data_state;
              emitTag();
              return;
            }
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tagnamebuf += String.fromCharCode(c + 32);
            tempbuf.push(c);
            return;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tagnamebuf += String.fromCharCode(c);
            tempbuf.push(c);
            return;
          default:
            break;
        }
        textrun.push(60);
        textrun.push(47);
        pushAll(textrun, tempbuf);
        reconsume(c, rawtext_state);
      }
      function script_data_less_than_sign_state(c) {
        switch (c) {
          case 47:
            beginTempBuf();
            tokenizer = script_data_end_tag_open_state;
            break;
          case 33:
            tokenizer = script_data_escape_start_state;
            textrun.push(60);
            textrun.push(33);
            break;
          default:
            textrun.push(60);
            reconsume(c, script_data_state);
            break;
        }
      }
      function script_data_end_tag_open_state(c) {
        switch (c) {
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginEndTagName();
            reconsume(c, script_data_end_tag_name_state);
            break;
          default:
            textrun.push(60);
            textrun.push(47);
            reconsume(c, script_data_state);
            break;
        }
      }
      function script_data_end_tag_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = before_attribute_name_state;
              return;
            }
            break;
          case 47:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = self_closing_start_tag_state;
              return;
            }
            break;
          case 62:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = data_state;
              emitTag();
              return;
            }
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tagnamebuf += String.fromCharCode(c + 32);
            tempbuf.push(c);
            return;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tagnamebuf += String.fromCharCode(c);
            tempbuf.push(c);
            return;
          default:
            break;
        }
        textrun.push(60);
        textrun.push(47);
        pushAll(textrun, tempbuf);
        reconsume(c, script_data_state);
      }
      function script_data_escape_start_state(c) {
        if (c === 45) {
          tokenizer = script_data_escape_start_dash_state;
          textrun.push(45);
        } else {
          reconsume(c, script_data_state);
        }
      }
      function script_data_escape_start_dash_state(c) {
        if (c === 45) {
          tokenizer = script_data_escaped_dash_dash_state;
          textrun.push(45);
        } else {
          reconsume(c, script_data_state);
        }
      }
      function script_data_escaped_state(c) {
        switch (c) {
          case 45:
            tokenizer = script_data_escaped_dash_state;
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_escaped_less_than_sign_state;
            break;
          case 0:
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            textrun.push(c);
            break;
        }
      }
      function script_data_escaped_dash_state(c) {
        switch (c) {
          case 45:
            tokenizer = script_data_escaped_dash_dash_state;
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_escaped_less_than_sign_state;
            break;
          case 0:
            tokenizer = script_data_escaped_state;
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            tokenizer = script_data_escaped_state;
            textrun.push(c);
            break;
        }
      }
      function script_data_escaped_dash_dash_state(c) {
        switch (c) {
          case 45:
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_escaped_less_than_sign_state;
            break;
          case 62:
            tokenizer = script_data_state;
            textrun.push(62);
            break;
          case 0:
            tokenizer = script_data_escaped_state;
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            tokenizer = script_data_escaped_state;
            textrun.push(c);
            break;
        }
      }
      function script_data_escaped_less_than_sign_state(c) {
        switch (c) {
          case 47:
            beginTempBuf();
            tokenizer = script_data_escaped_end_tag_open_state;
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginTempBuf();
            textrun.push(60);
            reconsume(c, script_data_double_escape_start_state);
            break;
          default:
            textrun.push(60);
            reconsume(c, script_data_escaped_state);
            break;
        }
      }
      function script_data_escaped_end_tag_open_state(c) {
        switch (c) {
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginEndTagName();
            reconsume(c, script_data_escaped_end_tag_name_state);
            break;
          default:
            textrun.push(60);
            textrun.push(47);
            reconsume(c, script_data_escaped_state);
            break;
        }
      }
      function script_data_escaped_end_tag_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = before_attribute_name_state;
              return;
            }
            break;
          case 47:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = self_closing_start_tag_state;
              return;
            }
            break;
          case 62:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = data_state;
              emitTag();
              return;
            }
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tagnamebuf += String.fromCharCode(c + 32);
            tempbuf.push(c);
            return;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tagnamebuf += String.fromCharCode(c);
            tempbuf.push(c);
            return;
          default:
            break;
        }
        textrun.push(60);
        textrun.push(47);
        pushAll(textrun, tempbuf);
        reconsume(c, script_data_escaped_state);
      }
      function script_data_double_escape_start_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
          // SPACE
          case 47:
          // SOLIDUS
          case 62:
            if (buf2str(tempbuf) === 'script') {
              tokenizer = script_data_double_escaped_state;
            } else {
              tokenizer = script_data_escaped_state;
            }
            textrun.push(c);
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tempbuf.push(c + 32);
            textrun.push(c);
            break;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tempbuf.push(c);
            textrun.push(c);
            break;
          default:
            reconsume(c, script_data_escaped_state);
            break;
        }
      }
      function script_data_double_escaped_state(c) {
        switch (c) {
          case 45:
            tokenizer = script_data_double_escaped_dash_state;
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_double_escaped_less_than_sign_state;
            textrun.push(60);
            break;
          case 0:
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            textrun.push(c);
            break;
        }
      }
      function script_data_double_escaped_dash_state(c) {
        switch (c) {
          case 45:
            tokenizer = script_data_double_escaped_dash_dash_state;
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_double_escaped_less_than_sign_state;
            textrun.push(60);
            break;
          case 0:
            tokenizer = script_data_double_escaped_state;
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            tokenizer = script_data_double_escaped_state;
            textrun.push(c);
            break;
        }
      }
      function script_data_double_escaped_dash_dash_state(c) {
        switch (c) {
          case 45:
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_double_escaped_less_than_sign_state;
            textrun.push(60);
            break;
          case 62:
            tokenizer = script_data_state;
            textrun.push(62);
            break;
          case 0:
            tokenizer = script_data_double_escaped_state;
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            tokenizer = script_data_double_escaped_state;
            textrun.push(c);
            break;
        }
      }
      function script_data_double_escaped_less_than_sign_state(c) {
        if (c === 47) {
          beginTempBuf();
          tokenizer = script_data_double_escape_end_state;
          textrun.push(47);
        } else {
          reconsume(c, script_data_double_escaped_state);
        }
      }
      function script_data_double_escape_end_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
          // SPACE
          case 47:
          // SOLIDUS
          case 62:
            if (buf2str(tempbuf) === 'script') {
              tokenizer = script_data_escaped_state;
            } else {
              tokenizer = script_data_double_escaped_state;
            }
            textrun.push(c);
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tempbuf.push(c + 32);
            textrun.push(c);
            break;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tempbuf.push(c);
            textrun.push(c);
            break;
          default:
            reconsume(c, script_data_double_escaped_state);
            break;
        }
      }
      function before_attribute_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          // For SOLIDUS, GREATER-THAN SIGN, and EOF, spec says "reconsume in
          // the after attribute name state", but in our implementation that
          // state always has an active attribute in attrnamebuf.  Just clone
          // the rules here, without the addAttribute business.
          case 47:
            tokenizer = self_closing_start_tag_state;
            break;
          case 62:
            tokenizer = data_state;
            emitTag();
            break;
          case -1:
            emitEOF();
            break;
          case 61:
            beginAttrName();
            attrnamebuf += String.fromCharCode(c);
            tokenizer = attribute_name_state;
            break;
          default:
            if (handleSimpleAttribute()) break;
            beginAttrName();
            reconsume(c, attribute_name_state);
            break;
        }
      }
      function attribute_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
          // SPACE
          case 47:
          // SOLIDUS
          case 62:
          // GREATER-THAN SIGN
          case -1:
            reconsume(c, after_attribute_name_state);
            break;
          case 61:
            tokenizer = before_attribute_value_state;
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            attrnamebuf += String.fromCharCode(c + 32);
            break;
          case 0:
            attrnamebuf += String.fromCharCode(
              65533,
              /* REPLACEMENT CHARACTER */
            );
            break;
          case 34:
          // QUOTATION MARK
          case 39:
          // APOSTROPHE
          case 60:
          // LESS-THAN SIGN
          /* falls through */
          default:
            attrnamebuf += getMatchingChars(ATTRNAME);
            break;
        }
      }
      function after_attribute_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 47:
            addAttribute(attrnamebuf);
            tokenizer = self_closing_start_tag_state;
            break;
          case 61:
            tokenizer = before_attribute_value_state;
            break;
          case 62:
            tokenizer = data_state;
            addAttribute(attrnamebuf);
            emitTag();
            break;
          case -1:
            addAttribute(attrnamebuf);
            emitEOF();
            break;
          default:
            addAttribute(attrnamebuf);
            beginAttrName();
            reconsume(c, attribute_name_state);
            break;
        }
      }
      function before_attribute_value_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 34:
            beginAttrValue();
            tokenizer = attribute_value_double_quoted_state;
            break;
          case 39:
            beginAttrValue();
            tokenizer = attribute_value_single_quoted_state;
            break;
          case 62:
          // GREATER-THAN SIGN
          /* falls through */
          default:
            beginAttrValue();
            reconsume(c, attribute_value_unquoted_state);
            break;
        }
      }
      function attribute_value_double_quoted_state(c) {
        switch (c) {
          case 34:
            addAttribute(attrnamebuf, attrvaluebuf);
            tokenizer = after_attribute_value_quoted_state;
            break;
          case 38:
            return_state = attribute_value_double_quoted_state;
            tokenizer = character_reference_state;
            break;
          case 0:
            attrvaluebuf += String.fromCharCode(
              65533,
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            emitEOF();
            break;
          case 10:
            attrvaluebuf += String.fromCharCode(c);
            break;
          default:
            attrvaluebuf += getMatchingChars(DBLQUOTEATTRVAL);
            break;
        }
      }
      function attribute_value_single_quoted_state(c) {
        switch (c) {
          case 39:
            addAttribute(attrnamebuf, attrvaluebuf);
            tokenizer = after_attribute_value_quoted_state;
            break;
          case 38:
            return_state = attribute_value_single_quoted_state;
            tokenizer = character_reference_state;
            break;
          case 0:
            attrvaluebuf += String.fromCharCode(
              65533,
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            emitEOF();
            break;
          case 10:
            attrvaluebuf += String.fromCharCode(c);
            break;
          default:
            attrvaluebuf += getMatchingChars(SINGLEQUOTEATTRVAL);
            break;
        }
      }
      function attribute_value_unquoted_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            addAttribute(attrnamebuf, attrvaluebuf);
            tokenizer = before_attribute_name_state;
            break;
          case 38:
            return_state = attribute_value_unquoted_state;
            tokenizer = character_reference_state;
            break;
          case 62:
            addAttribute(attrnamebuf, attrvaluebuf);
            tokenizer = data_state;
            emitTag();
            break;
          case 0:
            attrvaluebuf += String.fromCharCode(
              65533,
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            nextchar--;
            tokenizer = data_state;
            break;
          case 34:
          // QUOTATION MARK
          case 39:
          // APOSTROPHE
          case 60:
          // LESS-THAN SIGN
          case 61:
          // EQUALS SIGN
          case 96:
          // GRAVE ACCENT
          /* falls through */
          default:
            attrvaluebuf += getMatchingChars(UNQUOTEDATTRVAL);
            break;
        }
      }
      function after_attribute_value_quoted_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = before_attribute_name_state;
            break;
          case 47:
            tokenizer = self_closing_start_tag_state;
            break;
          case 62:
            tokenizer = data_state;
            emitTag();
            break;
          case -1:
            emitEOF();
            break;
          default:
            reconsume(c, before_attribute_name_state);
            break;
        }
      }
      function self_closing_start_tag_state(c) {
        switch (c) {
          case 62:
            tokenizer = data_state;
            emitSelfClosingTag(true);
            break;
          case -1:
            emitEOF();
            break;
          default:
            reconsume(c, before_attribute_name_state);
            break;
        }
      }
      function bogus_comment_state(c, lookahead, eof) {
        var len = lookahead.length;
        if (eof) {
          nextchar += len - 1;
        } else {
          nextchar += len;
        }
        var comment = lookahead.substring(0, len - 1);
        comment = comment.replace(/\u0000/g, '\uFFFD');
        comment = comment.replace(/\u000D\u000A/g, '\n');
        comment = comment.replace(/\u000D/g, '\n');
        insertToken(COMMENT, comment);
        tokenizer = data_state;
      }
      bogus_comment_state.lookahead = '>';
      function markup_declaration_open_state(c, lookahead, eof) {
        if (lookahead[0] === '-' && lookahead[1] === '-') {
          nextchar += 2;
          beginComment();
          tokenizer = comment_start_state;
          return;
        }
        if (lookahead.toUpperCase() === 'DOCTYPE') {
          nextchar += 7;
          tokenizer = doctype_state;
        } else if (lookahead === '[CDATA[' && cdataAllowed()) {
          nextchar += 7;
          tokenizer = cdata_section_state;
        } else {
          tokenizer = bogus_comment_state;
        }
      }
      markup_declaration_open_state.lookahead = 7;
      function comment_start_state(c) {
        beginComment();
        switch (c) {
          case 45:
            tokenizer = comment_start_dash_state;
            break;
          case 62:
            tokenizer = data_state;
            insertToken(COMMENT, buf2str(commentbuf));
            break;
          /* see comment in comment end state */
          default:
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_start_dash_state(c) {
        switch (c) {
          case 45:
            tokenizer = comment_end_state;
            break;
          case 62:
            tokenizer = data_state;
            insertToken(COMMENT, buf2str(commentbuf));
            break;
          case -1:
            insertToken(COMMENT, buf2str(commentbuf));
            emitEOF();
            break;
          /* see comment in comment end state */
          default:
            commentbuf.push(
              45,
              /* HYPHEN-MINUS */
            );
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_state(c) {
        switch (c) {
          case 60:
            commentbuf.push(c);
            tokenizer = comment_less_than_sign_state;
            break;
          case 45:
            tokenizer = comment_end_dash_state;
            break;
          case 0:
            commentbuf.push(
              65533,
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            insertToken(COMMENT, buf2str(commentbuf));
            emitEOF();
            break;
          /* see comment in comment end state */
          default:
            commentbuf.push(c);
            break;
        }
      }
      function comment_less_than_sign_state(c) {
        switch (c) {
          case 33:
            commentbuf.push(c);
            tokenizer = comment_less_than_sign_bang_state;
            break;
          case 60:
            commentbuf.push(c);
            break;
          default:
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_less_than_sign_bang_state(c) {
        switch (c) {
          case 45:
            tokenizer = comment_less_than_sign_bang_dash_state;
            break;
          default:
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_less_than_sign_bang_dash_state(c) {
        switch (c) {
          case 45:
            tokenizer = comment_less_than_sign_bang_dash_dash_state;
            break;
          default:
            reconsume(c, comment_end_dash_state);
            break;
        }
      }
      function comment_less_than_sign_bang_dash_dash_state(c) {
        switch (c) {
          case 62:
          // GREATER-THAN SIGN
          case -1:
            reconsume(c, comment_end_state);
            break;
          default:
            reconsume(c, comment_end_state);
            break;
        }
      }
      function comment_end_dash_state(c) {
        switch (c) {
          case 45:
            tokenizer = comment_end_state;
            break;
          case -1:
            insertToken(COMMENT, buf2str(commentbuf));
            emitEOF();
            break;
          /* see comment in comment end state */
          default:
            commentbuf.push(
              45,
              /* HYPHEN-MINUS */
            );
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_end_state(c) {
        switch (c) {
          case 62:
            tokenizer = data_state;
            insertToken(COMMENT, buf2str(commentbuf));
            break;
          case 33:
            tokenizer = comment_end_bang_state;
            break;
          case 45:
            commentbuf.push(45);
            break;
          case -1:
            insertToken(COMMENT, buf2str(commentbuf));
            emitEOF();
            break;
          /* For security reasons: otherwise, hostile user could put a script in a comment e.g. in a blog comment and then DOS the server so that the end tag isn't read, and then the commented script tag would be treated as live code */
          default:
            commentbuf.push(45);
            commentbuf.push(45);
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_end_bang_state(c) {
        switch (c) {
          case 45:
            commentbuf.push(45);
            commentbuf.push(45);
            commentbuf.push(33);
            tokenizer = comment_end_dash_state;
            break;
          case 62:
            tokenizer = data_state;
            insertToken(COMMENT, buf2str(commentbuf));
            break;
          case -1:
            insertToken(COMMENT, buf2str(commentbuf));
            emitEOF();
            break;
          /* see comment in comment end state */
          default:
            commentbuf.push(45);
            commentbuf.push(45);
            commentbuf.push(33);
            reconsume(c, comment_state);
            break;
        }
      }
      function doctype_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = before_doctype_name_state;
            break;
          case -1:
            beginDoctype();
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            reconsume(c, before_doctype_name_state);
            break;
        }
      }
      function before_doctype_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            beginDoctype();
            doctypenamebuf.push(c + 32);
            tokenizer = doctype_name_state;
            break;
          case 0:
            beginDoctype();
            doctypenamebuf.push(65533);
            tokenizer = doctype_name_state;
            break;
          case 62:
            beginDoctype();
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            beginDoctype();
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            beginDoctype();
            doctypenamebuf.push(c);
            tokenizer = doctype_name_state;
            break;
        }
      }
      function doctype_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = after_doctype_name_state;
            break;
          case 62:
            tokenizer = data_state;
            emitDoctype();
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            doctypenamebuf.push(c + 32);
            break;
          case 0:
            doctypenamebuf.push(
              65533,
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            doctypenamebuf.push(c);
            break;
        }
      }
      function after_doctype_name_state(c, lookahead, eof) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            nextchar += 1;
            break;
          case 62:
            tokenizer = data_state;
            nextchar += 1;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            lookahead = lookahead.toUpperCase();
            if (lookahead === 'PUBLIC') {
              nextchar += 6;
              tokenizer = after_doctype_public_keyword_state;
            } else if (lookahead === 'SYSTEM') {
              nextchar += 6;
              tokenizer = after_doctype_system_keyword_state;
            } else {
              forcequirks();
              tokenizer = bogus_doctype_state;
            }
            break;
        }
      }
      after_doctype_name_state.lookahead = 6;
      function after_doctype_public_keyword_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = before_doctype_public_identifier_state;
            break;
          case 34:
            beginDoctypePublicId();
            tokenizer = doctype_public_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypePublicId();
            tokenizer = doctype_public_identifier_single_quoted_state;
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function before_doctype_public_identifier_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 34:
            beginDoctypePublicId();
            tokenizer = doctype_public_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypePublicId();
            tokenizer = doctype_public_identifier_single_quoted_state;
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function doctype_public_identifier_double_quoted_state(c) {
        switch (c) {
          case 34:
            tokenizer = after_doctype_public_identifier_state;
            break;
          case 0:
            doctypepublicbuf.push(
              65533,
              /* REPLACEMENT CHARACTER */
            );
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            doctypepublicbuf.push(c);
            break;
        }
      }
      function doctype_public_identifier_single_quoted_state(c) {
        switch (c) {
          case 39:
            tokenizer = after_doctype_public_identifier_state;
            break;
          case 0:
            doctypepublicbuf.push(
              65533,
              /* REPLACEMENT CHARACTER */
            );
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            doctypepublicbuf.push(c);
            break;
        }
      }
      function after_doctype_public_identifier_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = between_doctype_public_and_system_identifiers_state;
            break;
          case 62:
            tokenizer = data_state;
            emitDoctype();
            break;
          case 34:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_single_quoted_state;
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function between_doctype_public_and_system_identifiers_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 62:
            tokenizer = data_state;
            emitDoctype();
            break;
          case 34:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_single_quoted_state;
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function after_doctype_system_keyword_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = before_doctype_system_identifier_state;
            break;
          case 34:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_single_quoted_state;
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function before_doctype_system_identifier_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 34:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_single_quoted_state;
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function doctype_system_identifier_double_quoted_state(c) {
        switch (c) {
          case 34:
            tokenizer = after_doctype_system_identifier_state;
            break;
          case 0:
            doctypesystembuf.push(
              65533,
              /* REPLACEMENT CHARACTER */
            );
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            doctypesystembuf.push(c);
            break;
        }
      }
      function doctype_system_identifier_single_quoted_state(c) {
        switch (c) {
          case 39:
            tokenizer = after_doctype_system_identifier_state;
            break;
          case 0:
            doctypesystembuf.push(
              65533,
              /* REPLACEMENT CHARACTER */
            );
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            doctypesystembuf.push(c);
            break;
        }
      }
      function after_doctype_system_identifier_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 62:
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function bogus_doctype_state(c) {
        switch (c) {
          case 62:
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            emitDoctype();
            emitEOF();
            break;
          default:
            break;
        }
      }
      function cdata_section_state(c) {
        switch (c) {
          case 93:
            tokenizer = cdata_section_bracket_state;
            break;
          case -1:
            emitEOF();
            break;
          case 0:
            textIncludesNUL = true;
          /* fall through */
          default:
            emitCharsWhile(CDATATEXT) || textrun.push(c);
            break;
        }
      }
      function cdata_section_bracket_state(c) {
        switch (c) {
          case 93:
            tokenizer = cdata_section_end_state;
            break;
          default:
            textrun.push(93);
            reconsume(c, cdata_section_state);
            break;
        }
      }
      function cdata_section_end_state(c) {
        switch (c) {
          case 93:
            textrun.push(93);
            break;
          case 62:
            flushText();
            tokenizer = data_state;
            break;
          default:
            textrun.push(93);
            textrun.push(93);
            reconsume(c, cdata_section_state);
            break;
        }
      }
      function character_reference_state(c) {
        beginTempBuf();
        tempbuf.push(38);
        switch (c) {
          case 9:
          // TAB
          case 10:
          // LINE FEED
          case 12:
          // FORM FEED
          case 32:
          // SPACE
          case 60:
          // LESS-THAN SIGN
          case 38:
          // AMPERSAND
          case -1:
            reconsume(c, character_reference_end_state);
            break;
          case 35:
            tempbuf.push(c);
            tokenizer = numeric_character_reference_state;
            break;
          default:
            reconsume(c, named_character_reference_state);
            break;
        }
      }
      function named_character_reference_state(c) {
        NAMEDCHARREF.lastIndex = nextchar;
        var matched = NAMEDCHARREF.exec(chars);
        if (!matched) throw new Error('should never happen');
        var name = matched[1];
        if (!name) {
          tokenizer = character_reference_end_state;
          return;
        }
        nextchar += name.length;
        pushAll(tempbuf, str2buf(name));
        switch (return_state) {
          case attribute_value_double_quoted_state:
          case attribute_value_single_quoted_state:
          case attribute_value_unquoted_state:
            if (name[name.length - 1] !== ';') {
              if (/[=A-Za-z0-9]/.test(chars[nextchar])) {
                tokenizer = character_reference_end_state;
                return;
              }
            }
            break;
          default:
            break;
        }
        beginTempBuf();
        var rv = namedCharRefs[name];
        if (typeof rv === 'number') {
          tempbuf.push(rv);
        } else {
          pushAll(tempbuf, rv);
        }
        tokenizer = character_reference_end_state;
      }
      named_character_reference_state.lookahead = -NAMEDCHARREF_MAXLEN;
      function numeric_character_reference_state(c) {
        character_reference_code = 0;
        switch (c) {
          case 120:
          // x
          case 88:
            tempbuf.push(c);
            tokenizer = hexadecimal_character_reference_start_state;
            break;
          default:
            reconsume(c, decimal_character_reference_start_state);
            break;
        }
      }
      function hexadecimal_character_reference_start_state(c) {
        switch (c) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          // [0-9]
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          // [A-F]
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
            reconsume(c, hexadecimal_character_reference_state);
            break;
          default:
            reconsume(c, character_reference_end_state);
            break;
        }
      }
      function decimal_character_reference_start_state(c) {
        switch (c) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            reconsume(c, decimal_character_reference_state);
            break;
          default:
            reconsume(c, character_reference_end_state);
            break;
        }
      }
      function hexadecimal_character_reference_state(c) {
        switch (c) {
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
            character_reference_code *= 16;
            character_reference_code += c - 55;
            break;
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
            character_reference_code *= 16;
            character_reference_code += c - 87;
            break;
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            character_reference_code *= 16;
            character_reference_code += c - 48;
            break;
          case 59:
            tokenizer = numeric_character_reference_end_state;
            break;
          default:
            reconsume(c, numeric_character_reference_end_state);
            break;
        }
      }
      function decimal_character_reference_state(c) {
        switch (c) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            character_reference_code *= 10;
            character_reference_code += c - 48;
            break;
          case 59:
            tokenizer = numeric_character_reference_end_state;
            break;
          default:
            reconsume(c, numeric_character_reference_end_state);
            break;
        }
      }
      function numeric_character_reference_end_state(c) {
        if (character_reference_code in numericCharRefReplacements) {
          character_reference_code = numericCharRefReplacements[character_reference_code];
        } else if (
          character_reference_code > 1114111 ||
          (character_reference_code >= 55296 && character_reference_code < 57344)
        ) {
          character_reference_code = 65533;
        }
        beginTempBuf();
        if (character_reference_code <= 65535) {
          tempbuf.push(character_reference_code);
        } else {
          character_reference_code = character_reference_code - 65536;
          tempbuf.push(55296 + (character_reference_code >> 10));
          tempbuf.push(56320 + (character_reference_code & 1023));
        }
        reconsume(c, character_reference_end_state);
      }
      function character_reference_end_state(c) {
        switch (return_state) {
          case attribute_value_double_quoted_state:
          case attribute_value_single_quoted_state:
          case attribute_value_unquoted_state:
            attrvaluebuf += buf2str(tempbuf);
            break;
          default:
            pushAll(textrun, tempbuf);
            break;
        }
        reconsume(c, return_state);
      }
      function initial_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            value = value.replace(LEADINGWS, '');
            if (value.length === 0) return;
            break;
          // Handle anything non-space text below
          case 4:
            doc._appendChild(doc.createComment(value));
            return;
          case 5:
            var name = value;
            var publicid = arg3;
            var systemid = arg4;
            doc.appendChild(new DocumentType(doc, name, publicid, systemid));
            if (
              force_quirks ||
              name.toLowerCase() !== 'html' ||
              quirkyPublicIds.test(publicid) ||
              (systemid && systemid.toLowerCase() === quirkySystemId) ||
              (systemid === void 0 && conditionallyQuirkyPublicIds.test(publicid))
            )
              doc._quirks = true;
            else if (
              limitedQuirkyPublicIds.test(publicid) ||
              (systemid !== void 0 && conditionallyQuirkyPublicIds.test(publicid))
            )
              doc._limitedQuirks = true;
            parser = before_html_mode;
            return;
        }
        doc._quirks = true;
        parser = before_html_mode;
        parser(t, value, arg3, arg4);
      }
      function before_html_mode(t, value, arg3, arg4) {
        var elt;
        switch (t) {
          case 1:
            value = value.replace(LEADINGWS, '');
            if (value.length === 0) return;
            break;
          // Handle anything non-space text below
          case 5:
            return;
          case 4:
            doc._appendChild(doc.createComment(value));
            return;
          case 2:
            if (value === 'html') {
              elt = createHTMLElt(doc, value, arg3);
              stack.push(elt);
              doc.appendChild(elt);
              parser = before_head_mode;
              return;
            }
            break;
          case 3:
            switch (value) {
              case 'html':
              case 'head':
              case 'body':
              case 'br':
                break;
              // fall through on these
              default:
                return;
            }
        }
        elt = createHTMLElt(doc, 'html', null);
        stack.push(elt);
        doc.appendChild(elt);
        parser = before_head_mode;
        parser(t, value, arg3, arg4);
      }
      function before_head_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            value = value.replace(LEADINGWS, '');
            if (value.length === 0) return;
            break;
          // Handle anything non-space text below
          case 5:
            return;
          case 4:
            insertComment(value);
            return;
          case 2:
            switch (value) {
              case 'html':
                in_body_mode(t, value, arg3, arg4);
                return;
              case 'head':
                var elt = insertHTMLElement(value, arg3);
                head_element_pointer = elt;
                parser = in_head_mode;
                return;
            }
            break;
          case 3:
            switch (value) {
              case 'html':
              case 'head':
              case 'body':
              case 'br':
                break;
              default:
                return;
            }
        }
        before_head_mode(TAG, 'head', null);
        parser(t, value, arg3, arg4);
      }
      function in_head_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            var ws = value.match(LEADINGWS);
            if (ws) {
              insertText(ws[0]);
              value = value.substring(ws[0].length);
            }
            if (value.length === 0) return;
            break;
          // Handle non-whitespace below
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case 2:
            switch (value) {
              case 'html':
                in_body_mode(t, value, arg3, arg4);
                return;
              case 'meta':
              // XXX:
              // May need to change the encoding based on this tag
              /* falls through */
              case 'base':
              case 'basefont':
              case 'bgsound':
              case 'link':
                insertHTMLElement(value, arg3);
                stack.pop();
                return;
              case 'title':
                parseRCDATA(value, arg3);
                return;
              case 'noscript':
                if (!scripting_enabled) {
                  insertHTMLElement(value, arg3);
                  parser = in_head_noscript_mode;
                  return;
                }
              // Otherwise, if scripting is enabled...
              /* falls through */
              case 'noframes':
              case 'style':
                parseRawText(value, arg3);
                return;
              case 'script':
                insertElement(function (doc2) {
                  var elt = createHTMLElt(doc2, value, arg3);
                  elt._parser_inserted = true;
                  elt._force_async = false;
                  if (fragment) elt._already_started = true;
                  flushText();
                  return elt;
                });
                tokenizer = script_data_state;
                originalInsertionMode = parser;
                parser = text_mode;
                return;
              case 'template':
                insertHTMLElement(value, arg3);
                afe.insertMarker();
                frameset_ok = false;
                parser = in_template_mode;
                templateInsertionModes.push(parser);
                return;
              case 'head':
                return;
            }
            break;
          case 3:
            switch (value) {
              case 'head':
                stack.pop();
                parser = after_head_mode;
                return;
              case 'body':
              case 'html':
              case 'br':
                break;
              // handle these at the bottom of the function
              case 'template':
                if (!stack.contains('template')) {
                  return;
                }
                stack.generateImpliedEndTags(null, 'thorough');
                stack.popTag('template');
                afe.clearToMarker();
                templateInsertionModes.pop();
                resetInsertionMode();
                return;
              default:
                return;
            }
            break;
        }
        in_head_mode(ENDTAG, 'head', null);
        parser(t, value, arg3, arg4);
      }
      function in_head_noscript_mode(t, value, arg3, arg4) {
        switch (t) {
          case 5:
            return;
          case 4:
            in_head_mode(t, value);
            return;
          case 1:
            var ws = value.match(LEADINGWS);
            if (ws) {
              in_head_mode(t, ws[0]);
              value = value.substring(ws[0].length);
            }
            if (value.length === 0) return;
            break;
          // Handle non-whitespace below
          case 2:
            switch (value) {
              case 'html':
                in_body_mode(t, value, arg3, arg4);
                return;
              case 'basefont':
              case 'bgsound':
              case 'link':
              case 'meta':
              case 'noframes':
              case 'style':
                in_head_mode(t, value, arg3);
                return;
              case 'head':
              case 'noscript':
                return;
            }
            break;
          case 3:
            switch (value) {
              case 'noscript':
                stack.pop();
                parser = in_head_mode;
                return;
              case 'br':
                break;
              // goes to the outer default
              default:
                return;
            }
            break;
        }
        in_head_noscript_mode(ENDTAG, 'noscript', null);
        parser(t, value, arg3, arg4);
      }
      function after_head_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            var ws = value.match(LEADINGWS);
            if (ws) {
              insertText(ws[0]);
              value = value.substring(ws[0].length);
            }
            if (value.length === 0) return;
            break;
          // Handle non-whitespace below
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case 2:
            switch (value) {
              case 'html':
                in_body_mode(t, value, arg3, arg4);
                return;
              case 'body':
                insertHTMLElement(value, arg3);
                frameset_ok = false;
                parser = in_body_mode;
                return;
              case 'frameset':
                insertHTMLElement(value, arg3);
                parser = in_frameset_mode;
                return;
              case 'base':
              case 'basefont':
              case 'bgsound':
              case 'link':
              case 'meta':
              case 'noframes':
              case 'script':
              case 'style':
              case 'template':
              case 'title':
                stack.push(head_element_pointer);
                in_head_mode(TAG, value, arg3);
                stack.removeElement(head_element_pointer);
                return;
              case 'head':
                return;
            }
            break;
          case 3:
            switch (value) {
              case 'template':
                return in_head_mode(t, value, arg3, arg4);
              case 'body':
              case 'html':
              case 'br':
                break;
              default:
                return;
            }
            break;
        }
        after_head_mode(TAG, 'body', null);
        frameset_ok = true;
        parser(t, value, arg3, arg4);
      }
      function in_body_mode(t, value, arg3, arg4) {
        var body, i, node, elt;
        switch (t) {
          case 1:
            if (textIncludesNUL) {
              value = value.replace(NULCHARS, '');
              if (value.length === 0) return;
            }
            if (frameset_ok && NONWS.test(value)) frameset_ok = false;
            afereconstruct();
            insertText(value);
            return;
          case 5:
            return;
          case 4:
            insertComment(value);
            return;
          case -1:
            if (templateInsertionModes.length) {
              return in_template_mode(t);
            }
            stopParsing();
            return;
          case 2:
            switch (value) {
              case 'html':
                if (stack.contains('template')) {
                  return;
                }
                transferAttributes(arg3, stack.elements[0]);
                return;
              case 'base':
              case 'basefont':
              case 'bgsound':
              case 'link':
              case 'meta':
              case 'noframes':
              case 'script':
              case 'style':
              case 'template':
              case 'title':
                in_head_mode(TAG, value, arg3);
                return;
              case 'body':
                body = stack.elements[1];
                if (!body || !(body instanceof impl.HTMLBodyElement) || stack.contains('template')) return;
                frameset_ok = false;
                transferAttributes(arg3, body);
                return;
              case 'frameset':
                if (!frameset_ok) return;
                body = stack.elements[1];
                if (!body || !(body instanceof impl.HTMLBodyElement)) return;
                if (body.parentNode) body.parentNode.removeChild(body);
                while (!(stack.top instanceof impl.HTMLHtmlElement)) stack.pop();
                insertHTMLElement(value, arg3);
                parser = in_frameset_mode;
                return;
              case 'address':
              case 'article':
              case 'aside':
              case 'blockquote':
              case 'center':
              case 'details':
              case 'dialog':
              case 'dir':
              case 'div':
              case 'dl':
              case 'fieldset':
              case 'figcaption':
              case 'figure':
              case 'footer':
              case 'header':
              case 'hgroup':
              case 'main':
              case 'nav':
              case 'ol':
              case 'p':
              case 'section':
              case 'summary':
              case 'ul':
                if (stack.inButtonScope('p')) in_body_mode(ENDTAG, 'p');
                insertHTMLElement(value, arg3);
                return;
              case 'menu':
                if (stack.inButtonScope('p')) in_body_mode(ENDTAG, 'p');
                if (isA(stack.top, 'menuitem')) {
                  stack.pop();
                }
                insertHTMLElement(value, arg3);
                return;
              case 'h1':
              case 'h2':
              case 'h3':
              case 'h4':
              case 'h5':
              case 'h6':
                if (stack.inButtonScope('p')) in_body_mode(ENDTAG, 'p');
                if (stack.top instanceof impl.HTMLHeadingElement) stack.pop();
                insertHTMLElement(value, arg3);
                return;
              case 'pre':
              case 'listing':
                if (stack.inButtonScope('p')) in_body_mode(ENDTAG, 'p');
                insertHTMLElement(value, arg3);
                ignore_linefeed = true;
                frameset_ok = false;
                return;
              case 'form':
                if (form_element_pointer && !stack.contains('template')) return;
                if (stack.inButtonScope('p')) in_body_mode(ENDTAG, 'p');
                elt = insertHTMLElement(value, arg3);
                if (!stack.contains('template')) form_element_pointer = elt;
                return;
              case 'li':
                frameset_ok = false;
                for (i = stack.elements.length - 1; i >= 0; i--) {
                  node = stack.elements[i];
                  if (node instanceof impl.HTMLLIElement) {
                    in_body_mode(ENDTAG, 'li');
                    break;
                  }
                  if (isA(node, specialSet) && !isA(node, addressdivpSet)) break;
                }
                if (stack.inButtonScope('p')) in_body_mode(ENDTAG, 'p');
                insertHTMLElement(value, arg3);
                return;
              case 'dd':
              case 'dt':
                frameset_ok = false;
                for (i = stack.elements.length - 1; i >= 0; i--) {
                  node = stack.elements[i];
                  if (isA(node, dddtSet)) {
                    in_body_mode(ENDTAG, node.localName);
                    break;
                  }
                  if (isA(node, specialSet) && !isA(node, addressdivpSet)) break;
                }
                if (stack.inButtonScope('p')) in_body_mode(ENDTAG, 'p');
                insertHTMLElement(value, arg3);
                return;
              case 'plaintext':
                if (stack.inButtonScope('p')) in_body_mode(ENDTAG, 'p');
                insertHTMLElement(value, arg3);
                tokenizer = plaintext_state;
                return;
              case 'button':
                if (stack.inScope('button')) {
                  in_body_mode(ENDTAG, 'button');
                  parser(t, value, arg3, arg4);
                } else {
                  afereconstruct();
                  insertHTMLElement(value, arg3);
                  frameset_ok = false;
                }
                return;
              case 'a':
                var activeElement = afe.findElementByTag('a');
                if (activeElement) {
                  in_body_mode(ENDTAG, value);
                  afe.remove(activeElement);
                  stack.removeElement(activeElement);
                }
              /* falls through */
              case 'b':
              case 'big':
              case 'code':
              case 'em':
              case 'font':
              case 'i':
              case 's':
              case 'small':
              case 'strike':
              case 'strong':
              case 'tt':
              case 'u':
                afereconstruct();
                afe.push(insertHTMLElement(value, arg3), arg3);
                return;
              case 'nobr':
                afereconstruct();
                if (stack.inScope(value)) {
                  in_body_mode(ENDTAG, value);
                  afereconstruct();
                }
                afe.push(insertHTMLElement(value, arg3), arg3);
                return;
              case 'applet':
              case 'marquee':
              case 'object':
                afereconstruct();
                insertHTMLElement(value, arg3);
                afe.insertMarker();
                frameset_ok = false;
                return;
              case 'table':
                if (!doc._quirks && stack.inButtonScope('p')) {
                  in_body_mode(ENDTAG, 'p');
                }
                insertHTMLElement(value, arg3);
                frameset_ok = false;
                parser = in_table_mode;
                return;
              case 'area':
              case 'br':
              case 'embed':
              case 'img':
              case 'keygen':
              case 'wbr':
                afereconstruct();
                insertHTMLElement(value, arg3);
                stack.pop();
                frameset_ok = false;
                return;
              case 'input':
                afereconstruct();
                elt = insertHTMLElement(value, arg3);
                stack.pop();
                var type = elt.getAttribute('type');
                if (!type || type.toLowerCase() !== 'hidden') frameset_ok = false;
                return;
              case 'param':
              case 'source':
              case 'track':
                insertHTMLElement(value, arg3);
                stack.pop();
                return;
              case 'hr':
                if (stack.inButtonScope('p')) in_body_mode(ENDTAG, 'p');
                if (isA(stack.top, 'menuitem')) {
                  stack.pop();
                }
                insertHTMLElement(value, arg3);
                stack.pop();
                frameset_ok = false;
                return;
              case 'image':
                in_body_mode(TAG, 'img', arg3, arg4);
                return;
              case 'textarea':
                insertHTMLElement(value, arg3);
                ignore_linefeed = true;
                frameset_ok = false;
                tokenizer = rcdata_state;
                originalInsertionMode = parser;
                parser = text_mode;
                return;
              case 'xmp':
                if (stack.inButtonScope('p')) in_body_mode(ENDTAG, 'p');
                afereconstruct();
                frameset_ok = false;
                parseRawText(value, arg3);
                return;
              case 'iframe':
                frameset_ok = false;
                parseRawText(value, arg3);
                return;
              case 'noembed':
                parseRawText(value, arg3);
                return;
              case 'select':
                afereconstruct();
                insertHTMLElement(value, arg3);
                frameset_ok = false;
                if (
                  parser === in_table_mode ||
                  parser === in_caption_mode ||
                  parser === in_table_body_mode ||
                  parser === in_row_mode ||
                  parser === in_cell_mode
                )
                  parser = in_select_in_table_mode;
                else parser = in_select_mode;
                return;
              case 'optgroup':
              case 'option':
                if (stack.top instanceof impl.HTMLOptionElement) {
                  in_body_mode(ENDTAG, 'option');
                }
                afereconstruct();
                insertHTMLElement(value, arg3);
                return;
              case 'menuitem':
                if (isA(stack.top, 'menuitem')) {
                  stack.pop();
                }
                afereconstruct();
                insertHTMLElement(value, arg3);
                return;
              case 'rb':
              case 'rtc':
                if (stack.inScope('ruby')) {
                  stack.generateImpliedEndTags();
                }
                insertHTMLElement(value, arg3);
                return;
              case 'rp':
              case 'rt':
                if (stack.inScope('ruby')) {
                  stack.generateImpliedEndTags('rtc');
                }
                insertHTMLElement(value, arg3);
                return;
              case 'math':
                afereconstruct();
                adjustMathMLAttributes(arg3);
                adjustForeignAttributes(arg3);
                insertForeignElement(value, arg3, NAMESPACE.MATHML);
                if (arg4) stack.pop();
                return;
              case 'svg':
                afereconstruct();
                adjustSVGAttributes(arg3);
                adjustForeignAttributes(arg3);
                insertForeignElement(value, arg3, NAMESPACE.SVG);
                if (arg4) stack.pop();
                return;
              case 'caption':
              case 'col':
              case 'colgroup':
              case 'frame':
              case 'head':
              case 'tbody':
              case 'td':
              case 'tfoot':
              case 'th':
              case 'thead':
              case 'tr':
                return;
            }
            afereconstruct();
            insertHTMLElement(value, arg3);
            return;
          case 3:
            switch (value) {
              case 'template':
                in_head_mode(ENDTAG, value, arg3);
                return;
              case 'body':
                if (!stack.inScope('body')) return;
                parser = after_body_mode;
                return;
              case 'html':
                if (!stack.inScope('body')) return;
                parser = after_body_mode;
                parser(t, value, arg3);
                return;
              case 'address':
              case 'article':
              case 'aside':
              case 'blockquote':
              case 'button':
              case 'center':
              case 'details':
              case 'dialog':
              case 'dir':
              case 'div':
              case 'dl':
              case 'fieldset':
              case 'figcaption':
              case 'figure':
              case 'footer':
              case 'header':
              case 'hgroup':
              case 'listing':
              case 'main':
              case 'menu':
              case 'nav':
              case 'ol':
              case 'pre':
              case 'section':
              case 'summary':
              case 'ul':
                if (!stack.inScope(value)) return;
                stack.generateImpliedEndTags();
                stack.popTag(value);
                return;
              case 'form':
                if (!stack.contains('template')) {
                  var openform = form_element_pointer;
                  form_element_pointer = null;
                  if (!openform || !stack.elementInScope(openform)) return;
                  stack.generateImpliedEndTags();
                  stack.removeElement(openform);
                } else {
                  if (!stack.inScope('form')) return;
                  stack.generateImpliedEndTags();
                  stack.popTag('form');
                }
                return;
              case 'p':
                if (!stack.inButtonScope(value)) {
                  in_body_mode(TAG, value, null);
                  parser(t, value, arg3, arg4);
                } else {
                  stack.generateImpliedEndTags(value);
                  stack.popTag(value);
                }
                return;
              case 'li':
                if (!stack.inListItemScope(value)) return;
                stack.generateImpliedEndTags(value);
                stack.popTag(value);
                return;
              case 'dd':
              case 'dt':
                if (!stack.inScope(value)) return;
                stack.generateImpliedEndTags(value);
                stack.popTag(value);
                return;
              case 'h1':
              case 'h2':
              case 'h3':
              case 'h4':
              case 'h5':
              case 'h6':
                if (!stack.elementTypeInScope(impl.HTMLHeadingElement)) return;
                stack.generateImpliedEndTags();
                stack.popElementType(impl.HTMLHeadingElement);
                return;
              case 'sarcasm':
                break;
              case 'a':
              case 'b':
              case 'big':
              case 'code':
              case 'em':
              case 'font':
              case 'i':
              case 'nobr':
              case 's':
              case 'small':
              case 'strike':
              case 'strong':
              case 'tt':
              case 'u':
                var result = adoptionAgency(value);
                if (result) return;
                break;
              // Go to the "any other end tag" case
              case 'applet':
              case 'marquee':
              case 'object':
                if (!stack.inScope(value)) return;
                stack.generateImpliedEndTags();
                stack.popTag(value);
                afe.clearToMarker();
                return;
              case 'br':
                in_body_mode(TAG, value, null);
                return;
            }
            for (i = stack.elements.length - 1; i >= 0; i--) {
              node = stack.elements[i];
              if (isA(node, value)) {
                stack.generateImpliedEndTags(value);
                stack.popElement(node);
                break;
              } else if (isA(node, specialSet)) {
                return;
              }
            }
            return;
        }
      }
      function text_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            insertText(value);
            return;
          case -1:
            if (stack.top instanceof impl.HTMLScriptElement) stack.top._already_started = true;
            stack.pop();
            parser = originalInsertionMode;
            parser(t);
            return;
          case 3:
            if (value === 'script') {
              handleScriptEnd();
            } else {
              stack.pop();
              parser = originalInsertionMode;
            }
            return;
          default:
            return;
        }
      }
      function in_table_mode(t, value, arg3, arg4) {
        function getTypeAttr(attrs) {
          for (var i = 0, n = attrs.length; i < n; i++) {
            if (attrs[i][0] === 'type') return attrs[i][1].toLowerCase();
          }
          return null;
        }
        switch (t) {
          case 1:
            if (text_integration_mode) {
              in_body_mode(t, value, arg3, arg4);
              return;
            } else if (isA(stack.top, tablesectionrowSet)) {
              pending_table_text = [];
              originalInsertionMode = parser;
              parser = in_table_text_mode;
              parser(t, value, arg3, arg4);
              return;
            }
            break;
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case 2:
            switch (value) {
              case 'caption':
                stack.clearToContext(tableContextSet);
                afe.insertMarker();
                insertHTMLElement(value, arg3);
                parser = in_caption_mode;
                return;
              case 'colgroup':
                stack.clearToContext(tableContextSet);
                insertHTMLElement(value, arg3);
                parser = in_column_group_mode;
                return;
              case 'col':
                in_table_mode(TAG, 'colgroup', null);
                parser(t, value, arg3, arg4);
                return;
              case 'tbody':
              case 'tfoot':
              case 'thead':
                stack.clearToContext(tableContextSet);
                insertHTMLElement(value, arg3);
                parser = in_table_body_mode;
                return;
              case 'td':
              case 'th':
              case 'tr':
                in_table_mode(TAG, 'tbody', null);
                parser(t, value, arg3, arg4);
                return;
              case 'table':
                if (!stack.inTableScope(value)) {
                  return;
                }
                in_table_mode(ENDTAG, value);
                parser(t, value, arg3, arg4);
                return;
              case 'style':
              case 'script':
              case 'template':
                in_head_mode(t, value, arg3, arg4);
                return;
              case 'input':
                var type = getTypeAttr(arg3);
                if (type !== 'hidden') break;
                insertHTMLElement(value, arg3);
                stack.pop();
                return;
              case 'form':
                if (form_element_pointer || stack.contains('template')) return;
                form_element_pointer = insertHTMLElement(value, arg3);
                stack.popElement(form_element_pointer);
                return;
            }
            break;
          case 3:
            switch (value) {
              case 'table':
                if (!stack.inTableScope(value)) return;
                stack.popTag(value);
                resetInsertionMode();
                return;
              case 'body':
              case 'caption':
              case 'col':
              case 'colgroup':
              case 'html':
              case 'tbody':
              case 'td':
              case 'tfoot':
              case 'th':
              case 'thead':
              case 'tr':
                return;
              case 'template':
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case -1:
            in_body_mode(t, value, arg3, arg4);
            return;
        }
        foster_parent_mode = true;
        in_body_mode(t, value, arg3, arg4);
        foster_parent_mode = false;
      }
      function in_table_text_mode(t, value, arg3, arg4) {
        if (t === TEXT) {
          if (textIncludesNUL) {
            value = value.replace(NULCHARS, '');
            if (value.length === 0) return;
          }
          pending_table_text.push(value);
        } else {
          var s = pending_table_text.join('');
          pending_table_text.length = 0;
          if (NONWS.test(s)) {
            foster_parent_mode = true;
            in_body_mode(TEXT, s);
            foster_parent_mode = false;
          } else {
            insertText(s);
          }
          parser = originalInsertionMode;
          parser(t, value, arg3, arg4);
        }
      }
      function in_caption_mode(t, value, arg3, arg4) {
        function end_caption() {
          if (!stack.inTableScope('caption')) return false;
          stack.generateImpliedEndTags();
          stack.popTag('caption');
          afe.clearToMarker();
          parser = in_table_mode;
          return true;
        }
        switch (t) {
          case 2:
            switch (value) {
              case 'caption':
              case 'col':
              case 'colgroup':
              case 'tbody':
              case 'td':
              case 'tfoot':
              case 'th':
              case 'thead':
              case 'tr':
                if (end_caption()) parser(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            switch (value) {
              case 'caption':
                end_caption();
                return;
              case 'table':
                if (end_caption()) parser(t, value, arg3, arg4);
                return;
              case 'body':
              case 'col':
              case 'colgroup':
              case 'html':
              case 'tbody':
              case 'td':
              case 'tfoot':
              case 'th':
              case 'thead':
              case 'tr':
                return;
            }
            break;
        }
        in_body_mode(t, value, arg3, arg4);
      }
      function in_column_group_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            var ws = value.match(LEADINGWS);
            if (ws) {
              insertText(ws[0]);
              value = value.substring(ws[0].length);
            }
            if (value.length === 0) return;
            break;
          // Handle non-whitespace below
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case 2:
            switch (value) {
              case 'html':
                in_body_mode(t, value, arg3, arg4);
                return;
              case 'col':
                insertHTMLElement(value, arg3);
                stack.pop();
                return;
              case 'template':
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            switch (value) {
              case 'colgroup':
                if (!isA(stack.top, 'colgroup')) {
                  return;
                }
                stack.pop();
                parser = in_table_mode;
                return;
              case 'col':
                return;
              case 'template':
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case -1:
            in_body_mode(t, value, arg3, arg4);
            return;
        }
        if (!isA(stack.top, 'colgroup')) {
          return;
        }
        in_column_group_mode(ENDTAG, 'colgroup');
        parser(t, value, arg3, arg4);
      }
      function in_table_body_mode(t, value, arg3, arg4) {
        function endsect() {
          if (!stack.inTableScope('tbody') && !stack.inTableScope('thead') && !stack.inTableScope('tfoot')) return;
          stack.clearToContext(tableBodyContextSet);
          in_table_body_mode(ENDTAG, stack.top.localName, null);
          parser(t, value, arg3, arg4);
        }
        switch (t) {
          case 2:
            switch (value) {
              case 'tr':
                stack.clearToContext(tableBodyContextSet);
                insertHTMLElement(value, arg3);
                parser = in_row_mode;
                return;
              case 'th':
              case 'td':
                in_table_body_mode(TAG, 'tr', null);
                parser(t, value, arg3, arg4);
                return;
              case 'caption':
              case 'col':
              case 'colgroup':
              case 'tbody':
              case 'tfoot':
              case 'thead':
                endsect();
                return;
            }
            break;
          case 3:
            switch (value) {
              case 'table':
                endsect();
                return;
              case 'tbody':
              case 'tfoot':
              case 'thead':
                if (stack.inTableScope(value)) {
                  stack.clearToContext(tableBodyContextSet);
                  stack.pop();
                  parser = in_table_mode;
                }
                return;
              case 'body':
              case 'caption':
              case 'col':
              case 'colgroup':
              case 'html':
              case 'td':
              case 'th':
              case 'tr':
                return;
            }
            break;
        }
        in_table_mode(t, value, arg3, arg4);
      }
      function in_row_mode(t, value, arg3, arg4) {
        function endrow() {
          if (!stack.inTableScope('tr')) return false;
          stack.clearToContext(tableRowContextSet);
          stack.pop();
          parser = in_table_body_mode;
          return true;
        }
        switch (t) {
          case 2:
            switch (value) {
              case 'th':
              case 'td':
                stack.clearToContext(tableRowContextSet);
                insertHTMLElement(value, arg3);
                parser = in_cell_mode;
                afe.insertMarker();
                return;
              case 'caption':
              case 'col':
              case 'colgroup':
              case 'tbody':
              case 'tfoot':
              case 'thead':
              case 'tr':
                if (endrow()) parser(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            switch (value) {
              case 'tr':
                endrow();
                return;
              case 'table':
                if (endrow()) parser(t, value, arg3, arg4);
                return;
              case 'tbody':
              case 'tfoot':
              case 'thead':
                if (stack.inTableScope(value)) {
                  if (endrow()) parser(t, value, arg3, arg4);
                }
                return;
              case 'body':
              case 'caption':
              case 'col':
              case 'colgroup':
              case 'html':
              case 'td':
              case 'th':
                return;
            }
            break;
        }
        in_table_mode(t, value, arg3, arg4);
      }
      function in_cell_mode(t, value, arg3, arg4) {
        switch (t) {
          case 2:
            switch (value) {
              case 'caption':
              case 'col':
              case 'colgroup':
              case 'tbody':
              case 'td':
              case 'tfoot':
              case 'th':
              case 'thead':
              case 'tr':
                if (stack.inTableScope('td')) {
                  in_cell_mode(ENDTAG, 'td');
                  parser(t, value, arg3, arg4);
                } else if (stack.inTableScope('th')) {
                  in_cell_mode(ENDTAG, 'th');
                  parser(t, value, arg3, arg4);
                }
                return;
            }
            break;
          case 3:
            switch (value) {
              case 'td':
              case 'th':
                if (!stack.inTableScope(value)) return;
                stack.generateImpliedEndTags();
                stack.popTag(value);
                afe.clearToMarker();
                parser = in_row_mode;
                return;
              case 'body':
              case 'caption':
              case 'col':
              case 'colgroup':
              case 'html':
                return;
              case 'table':
              case 'tbody':
              case 'tfoot':
              case 'thead':
              case 'tr':
                if (!stack.inTableScope(value)) return;
                in_cell_mode(ENDTAG, stack.inTableScope('td') ? 'td' : 'th');
                parser(t, value, arg3, arg4);
                return;
            }
            break;
        }
        in_body_mode(t, value, arg3, arg4);
      }
      function in_select_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            if (textIncludesNUL) {
              value = value.replace(NULCHARS, '');
              if (value.length === 0) return;
            }
            insertText(value);
            return;
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case -1:
            in_body_mode(t, value, arg3, arg4);
            return;
          case 2:
            switch (value) {
              case 'html':
                in_body_mode(t, value, arg3, arg4);
                return;
              case 'option':
                if (stack.top instanceof impl.HTMLOptionElement) in_select_mode(ENDTAG, value);
                insertHTMLElement(value, arg3);
                return;
              case 'optgroup':
                if (stack.top instanceof impl.HTMLOptionElement) in_select_mode(ENDTAG, 'option');
                if (stack.top instanceof impl.HTMLOptGroupElement) in_select_mode(ENDTAG, value);
                insertHTMLElement(value, arg3);
                return;
              case 'select':
                in_select_mode(ENDTAG, value);
                return;
              case 'input':
              case 'keygen':
              case 'textarea':
                if (!stack.inSelectScope('select')) return;
                in_select_mode(ENDTAG, 'select');
                parser(t, value, arg3, arg4);
                return;
              case 'script':
              case 'template':
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            switch (value) {
              case 'optgroup':
                if (
                  stack.top instanceof impl.HTMLOptionElement &&
                  stack.elements[stack.elements.length - 2] instanceof impl.HTMLOptGroupElement
                ) {
                  in_select_mode(ENDTAG, 'option');
                }
                if (stack.top instanceof impl.HTMLOptGroupElement) stack.pop();
                return;
              case 'option':
                if (stack.top instanceof impl.HTMLOptionElement) stack.pop();
                return;
              case 'select':
                if (!stack.inSelectScope(value)) return;
                stack.popTag(value);
                resetInsertionMode();
                return;
              case 'template':
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
        }
      }
      function in_select_in_table_mode(t, value, arg3, arg4) {
        switch (value) {
          case 'caption':
          case 'table':
          case 'tbody':
          case 'tfoot':
          case 'thead':
          case 'tr':
          case 'td':
          case 'th':
            switch (t) {
              case 2:
                in_select_in_table_mode(ENDTAG, 'select');
                parser(t, value, arg3, arg4);
                return;
              case 3:
                if (stack.inTableScope(value)) {
                  in_select_in_table_mode(ENDTAG, 'select');
                  parser(t, value, arg3, arg4);
                }
                return;
            }
        }
        in_select_mode(t, value, arg3, arg4);
      }
      function in_template_mode(t, value, arg3, arg4) {
        function switchModeAndReprocess(mode) {
          parser = mode;
          templateInsertionModes[templateInsertionModes.length - 1] = parser;
          parser(t, value, arg3, arg4);
        }
        switch (t) {
          case 1:
          // TEXT
          case 4:
          // COMMENT
          case 5:
            in_body_mode(t, value, arg3, arg4);
            return;
          case -1:
            if (!stack.contains('template')) {
              stopParsing();
            } else {
              stack.popTag('template');
              afe.clearToMarker();
              templateInsertionModes.pop();
              resetInsertionMode();
              parser(t, value, arg3, arg4);
            }
            return;
          case 2:
            switch (value) {
              case 'base':
              case 'basefont':
              case 'bgsound':
              case 'link':
              case 'meta':
              case 'noframes':
              case 'script':
              case 'style':
              case 'template':
              case 'title':
                in_head_mode(t, value, arg3, arg4);
                return;
              case 'caption':
              case 'colgroup':
              case 'tbody':
              case 'tfoot':
              case 'thead':
                switchModeAndReprocess(in_table_mode);
                return;
              case 'col':
                switchModeAndReprocess(in_column_group_mode);
                return;
              case 'tr':
                switchModeAndReprocess(in_table_body_mode);
                return;
              case 'td':
              case 'th':
                switchModeAndReprocess(in_row_mode);
                return;
            }
            switchModeAndReprocess(in_body_mode);
            return;
          case 3:
            switch (value) {
              case 'template':
                in_head_mode(t, value, arg3, arg4);
                return;
              default:
                return;
            }
        }
      }
      function after_body_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            if (NONWS.test(value)) break;
            in_body_mode(t, value);
            return;
          case 4:
            stack.elements[0]._appendChild(doc.createComment(value));
            return;
          case 5:
            return;
          case -1:
            stopParsing();
            return;
          case 2:
            if (value === 'html') {
              in_body_mode(t, value, arg3, arg4);
              return;
            }
            break;
          // for any other tags
          case 3:
            if (value === 'html') {
              if (fragment) return;
              parser = after_after_body_mode;
              return;
            }
            break;
        }
        parser = in_body_mode;
        parser(t, value, arg3, arg4);
      }
      function in_frameset_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            value = value.replace(ALLNONWS, '');
            if (value.length > 0) insertText(value);
            return;
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case -1:
            stopParsing();
            return;
          case 2:
            switch (value) {
              case 'html':
                in_body_mode(t, value, arg3, arg4);
                return;
              case 'frameset':
                insertHTMLElement(value, arg3);
                return;
              case 'frame':
                insertHTMLElement(value, arg3);
                stack.pop();
                return;
              case 'noframes':
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            if (value === 'frameset') {
              if (fragment && stack.top instanceof impl.HTMLHtmlElement) return;
              stack.pop();
              if (!fragment && !(stack.top instanceof impl.HTMLFrameSetElement)) parser = after_frameset_mode;
              return;
            }
            break;
        }
      }
      function after_frameset_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            value = value.replace(ALLNONWS, '');
            if (value.length > 0) insertText(value);
            return;
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case -1:
            stopParsing();
            return;
          case 2:
            switch (value) {
              case 'html':
                in_body_mode(t, value, arg3, arg4);
                return;
              case 'noframes':
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            if (value === 'html') {
              parser = after_after_frameset_mode;
              return;
            }
            break;
        }
      }
      function after_after_body_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            if (NONWS.test(value)) break;
            in_body_mode(t, value, arg3, arg4);
            return;
          case 4:
            doc._appendChild(doc.createComment(value));
            return;
          case 5:
            in_body_mode(t, value, arg3, arg4);
            return;
          case -1:
            stopParsing();
            return;
          case 2:
            if (value === 'html') {
              in_body_mode(t, value, arg3, arg4);
              return;
            }
            break;
        }
        parser = in_body_mode;
        parser(t, value, arg3, arg4);
      }
      function after_after_frameset_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            value = value.replace(ALLNONWS, '');
            if (value.length > 0) in_body_mode(t, value, arg3, arg4);
            return;
          case 4:
            doc._appendChild(doc.createComment(value));
            return;
          case 5:
            in_body_mode(t, value, arg3, arg4);
            return;
          case -1:
            stopParsing();
            return;
          case 2:
            switch (value) {
              case 'html':
                in_body_mode(t, value, arg3, arg4);
                return;
              case 'noframes':
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
        }
      }
      function insertForeignToken(t, value, arg3, arg4) {
        function isHTMLFont(attrs) {
          for (var i2 = 0, n = attrs.length; i2 < n; i2++) {
            switch (attrs[i2][0]) {
              case 'color':
              case 'face':
              case 'size':
                return true;
            }
          }
          return false;
        }
        var current;
        switch (t) {
          case 1:
            if (frameset_ok && NONWSNONNUL.test(value)) frameset_ok = false;
            if (textIncludesNUL) {
              value = value.replace(NULCHARS, '\uFFFD');
            }
            insertText(value);
            return;
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case 2:
            switch (value) {
              case 'font':
                if (!isHTMLFont(arg3)) break;
              /* falls through */
              case 'b':
              case 'big':
              case 'blockquote':
              case 'body':
              case 'br':
              case 'center':
              case 'code':
              case 'dd':
              case 'div':
              case 'dl':
              case 'dt':
              case 'em':
              case 'embed':
              case 'h1':
              case 'h2':
              case 'h3':
              case 'h4':
              case 'h5':
              case 'h6':
              case 'head':
              case 'hr':
              case 'i':
              case 'img':
              case 'li':
              case 'listing':
              case 'menu':
              case 'meta':
              case 'nobr':
              case 'ol':
              case 'p':
              case 'pre':
              case 'ruby':
              case 's':
              case 'small':
              case 'span':
              case 'strong':
              case 'strike':
              case 'sub':
              case 'sup':
              case 'table':
              case 'tt':
              case 'u':
              case 'ul':
              case 'var':
                if (fragment) {
                  break;
                }
                do {
                  stack.pop();
                  current = stack.top;
                } while (
                  current.namespaceURI !== NAMESPACE.HTML &&
                  !isMathmlTextIntegrationPoint(current) &&
                  !isHTMLIntegrationPoint(current)
                );
                insertToken(t, value, arg3, arg4);
                return;
            }
            current = stack.elements.length === 1 && fragment ? fragmentContext : stack.top;
            if (current.namespaceURI === NAMESPACE.MATHML) {
              adjustMathMLAttributes(arg3);
            } else if (current.namespaceURI === NAMESPACE.SVG) {
              value = adjustSVGTagName(value);
              adjustSVGAttributes(arg3);
            }
            adjustForeignAttributes(arg3);
            insertForeignElement(value, arg3, current.namespaceURI);
            if (arg4) {
              if (value === 'script' && current.namespaceURI === NAMESPACE.SVG) {
              }
              stack.pop();
            }
            return;
          case 3:
            current = stack.top;
            if (value === 'script' && current.namespaceURI === NAMESPACE.SVG && current.localName === 'script') {
              stack.pop();
            } else {
              var i = stack.elements.length - 1;
              var node = stack.elements[i];
              for (;;) {
                if (node.localName.toLowerCase() === value) {
                  stack.popElement(node);
                  break;
                }
                node = stack.elements[--i];
                if (node.namespaceURI !== NAMESPACE.HTML) continue;
                parser(t, value, arg3, arg4);
                break;
              }
            }
            return;
        }
      }
      htmlparser.testTokenizer = function (input, initialState, lastStartTag, charbychar) {
        var tokens = [];
        switch (initialState) {
          case 'PCDATA state':
            tokenizer = data_state;
            break;
          case 'RCDATA state':
            tokenizer = rcdata_state;
            break;
          case 'RAWTEXT state':
            tokenizer = rawtext_state;
            break;
          case 'PLAINTEXT state':
            tokenizer = plaintext_state;
            break;
        }
        if (lastStartTag) {
          lasttagname = lastStartTag;
        }
        insertToken = function (t, value, arg3, arg4) {
          flushText();
          switch (t) {
            case 1:
              if (tokens.length > 0 && tokens[tokens.length - 1][0] === 'Character') {
                tokens[tokens.length - 1][1] += value;
              } else tokens.push(['Character', value]);
              break;
            case 4:
              tokens.push(['Comment', value]);
              break;
            case 5:
              tokens.push([
                'DOCTYPE',
                value,
                arg3 === void 0 ? null : arg3,
                arg4 === void 0 ? null : arg4,
                !force_quirks,
              ]);
              break;
            case 2:
              var attrs = /* @__PURE__ */ Object.create(null);
              for (var i2 = 0; i2 < arg3.length; i2++) {
                var a = arg3[i2];
                if (a.length === 1) {
                  attrs[a[0]] = '';
                } else {
                  attrs[a[0]] = a[1];
                }
              }
              var token = ['StartTag', value, attrs];
              if (arg4) token.push(true);
              tokens.push(token);
              break;
            case 3:
              tokens.push(['EndTag', value]);
              break;
            case -1:
              break;
          }
        };
        if (!charbychar) {
          this.parse(input, true);
        } else {
          for (var i = 0; i < input.length; i++) {
            this.parse(input[i]);
          }
          this.parse('', true);
        }
        return tokens;
      };
      return htmlparser;
    }
  },
});

// node_modules/@mixmark-io/domino/lib/DOMImplementation.js
var require_DOMImplementation = __commonJS({
  'node_modules/@mixmark-io/domino/lib/DOMImplementation.js'(exports2, module2) {
    'use strict';
    module2.exports = DOMImplementation;
    var Document = require_Document();
    var DocumentType = require_DocumentType();
    var HTMLParser = require_HTMLParser();
    var utils = require_utils2();
    var xml = require_xmlnames();
    function DOMImplementation(contextObject) {
      this.contextObject = contextObject;
    }
    var supportedFeatures = {
      xml: { '': true, '1.0': true, '2.0': true },
      // DOM Core
      core: { '': true, '2.0': true },
      // DOM Core
      html: { '': true, '1.0': true, '2.0': true },
      // HTML
      xhtml: { '': true, '1.0': true, '2.0': true },
      // HTML
    };
    DOMImplementation.prototype = {
      hasFeature: function hasFeature(feature, version) {
        var f = supportedFeatures[(feature || '').toLowerCase()];
        return (f && f[version || '']) || false;
      },
      createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {
        if (!xml.isValidQName(qualifiedName)) utils.InvalidCharacterError();
        return new DocumentType(this.contextObject, qualifiedName, publicId, systemId);
      },
      createDocument: function createDocument(namespace, qualifiedName, doctype) {
        var d = new Document(false, null);
        var e;
        if (qualifiedName) e = d.createElementNS(namespace, qualifiedName);
        else e = null;
        if (doctype) {
          d.appendChild(doctype);
        }
        if (e) d.appendChild(e);
        if (namespace === utils.NAMESPACE.HTML) {
          d._contentType = 'application/xhtml+xml';
        } else if (namespace === utils.NAMESPACE.SVG) {
          d._contentType = 'image/svg+xml';
        } else {
          d._contentType = 'application/xml';
        }
        return d;
      },
      createHTMLDocument: function createHTMLDocument(titleText) {
        var d = new Document(true, null);
        d.appendChild(new DocumentType(d, 'html'));
        var html = d.createElement('html');
        d.appendChild(html);
        var head = d.createElement('head');
        html.appendChild(head);
        if (titleText !== void 0) {
          var title = d.createElement('title');
          head.appendChild(title);
          title.appendChild(d.createTextNode(titleText));
        }
        html.appendChild(d.createElement('body'));
        d.modclock = 1;
        return d;
      },
      mozSetOutputMutationHandler: function (doc, handler2) {
        doc.mutationHandler = handler2;
      },
      mozGetInputMutationHandler: function (doc) {
        utils.nyi();
      },
      mozHTMLParser: HTMLParser,
    };
  },
});

// node_modules/@mixmark-io/domino/lib/Location.js
var require_Location = __commonJS({
  'node_modules/@mixmark-io/domino/lib/Location.js'(exports2, module2) {
    'use strict';
    var URL3 = require_URL();
    var URLUtils = require_URLUtils();
    module2.exports = Location;
    function Location(window2, href) {
      this._window = window2;
      this._href = href;
    }
    Location.prototype = Object.create(URLUtils.prototype, {
      constructor: { value: Location },
      // Special behavior when href is set
      href: {
        get: function () {
          return this._href;
        },
        set: function (v) {
          this.assign(v);
        },
      },
      assign: {
        value: function (url) {
          var current = new URL3(this._href);
          var newurl = current.resolve(url);
          this._href = newurl;
        },
      },
      replace: {
        value: function (url) {
          this.assign(url);
        },
      },
      reload: {
        value: function () {
          this.assign(this.href);
        },
      },
      toString: {
        value: function () {
          return this.href;
        },
      },
    });
  },
});

// node_modules/@mixmark-io/domino/lib/NavigatorID.js
var require_NavigatorID = __commonJS({
  'node_modules/@mixmark-io/domino/lib/NavigatorID.js'(exports2, module2) {
    'use strict';
    var NavigatorID = Object.create(null, {
      appCodeName: { value: 'Mozilla' },
      appName: { value: 'Netscape' },
      appVersion: { value: '4.0' },
      platform: { value: '' },
      product: { value: 'Gecko' },
      productSub: { value: '20100101' },
      userAgent: { value: '' },
      vendor: { value: '' },
      vendorSub: { value: '' },
      taintEnabled: {
        value: function () {
          return false;
        },
      },
    });
    module2.exports = NavigatorID;
  },
});

// node_modules/@mixmark-io/domino/lib/WindowTimers.js
var require_WindowTimers = __commonJS({
  'node_modules/@mixmark-io/domino/lib/WindowTimers.js'(exports2, module2) {
    'use strict';
    var WindowTimers = {
      setTimeout,
      clearTimeout,
      setInterval,
      clearInterval,
    };
    module2.exports = WindowTimers;
  },
});

// node_modules/@mixmark-io/domino/lib/impl.js
var require_impl = __commonJS({
  'node_modules/@mixmark-io/domino/lib/impl.js'(exports2, module2) {
    'use strict';
    var utils = require_utils2();
    exports2 = module2.exports = {
      CSSStyleDeclaration: require_CSSStyleDeclaration(),
      CharacterData: require_CharacterData(),
      Comment: require_Comment(),
      DOMException: require_DOMException(),
      DOMImplementation: require_DOMImplementation(),
      DOMTokenList: require_DOMTokenList(),
      Document: require_Document(),
      DocumentFragment: require_DocumentFragment(),
      DocumentType: require_DocumentType(),
      Element: require_Element(),
      HTMLParser: require_HTMLParser(),
      NamedNodeMap: require_NamedNodeMap(),
      Node: require_Node(),
      NodeList: require_NodeList(),
      NodeFilter: require_NodeFilter(),
      ProcessingInstruction: require_ProcessingInstruction(),
      Text: require_Text(),
      Window: require_Window(),
    };
    utils.merge(exports2, require_events());
    utils.merge(exports2, require_htmlelts().elements);
    utils.merge(exports2, require_svg().elements);
  },
});

// node_modules/@mixmark-io/domino/lib/Window.js
var require_Window = __commonJS({
  'node_modules/@mixmark-io/domino/lib/Window.js'(exports2, module2) {
    'use strict';
    var DOMImplementation = require_DOMImplementation();
    var EventTarget = require_EventTarget();
    var Location = require_Location();
    var utils = require_utils2();
    module2.exports = Window;
    function Window(document) {
      this.document = document || new DOMImplementation(null).createHTMLDocument('');
      this.document._scripting_enabled = true;
      this.document.defaultView = this;
      this.location = new Location(this, this.document._address || 'about:blank');
    }
    Window.prototype = Object.create(EventTarget.prototype, {
      console: { value: console },
      history: {
        value: {
          back: utils.nyi,
          forward: utils.nyi,
          go: utils.nyi,
        },
      },
      navigator: { value: require_NavigatorID() },
      // Self-referential properties
      window: {
        get: function () {
          return this;
        },
      },
      self: {
        get: function () {
          return this;
        },
      },
      frames: {
        get: function () {
          return this;
        },
      },
      // Self-referential properties for a top-level window
      parent: {
        get: function () {
          return this;
        },
      },
      top: {
        get: function () {
          return this;
        },
      },
      // We don't support any other windows for now
      length: { value: 0 },
      // no frames
      frameElement: { value: null },
      // not part of a frame
      opener: { value: null },
      // not opened by another window
      // The onload event handler.
      // XXX: need to support a bunch of other event types, too,
      // and have them interoperate with document.body.
      onload: {
        get: function () {
          return this._getEventHandler('load');
        },
        set: function (v) {
          this._setEventHandler('load', v);
        },
      },
      // XXX This is a completely broken implementation
      getComputedStyle: {
        value: function getComputedStyle(elt) {
          return elt.style;
        },
      },
    });
    utils.expose(require_WindowTimers(), Window);
    utils.expose(require_impl(), Window);
  },
});

// node_modules/@mixmark-io/domino/lib/index.js
var require_lib = __commonJS({
  'node_modules/@mixmark-io/domino/lib/index.js'(exports2) {
    'use strict';
    var DOMImplementation = require_DOMImplementation();
    var HTMLParser = require_HTMLParser();
    var Window = require_Window();
    var impl = require_impl();
    exports2.createDOMImplementation = function () {
      return new DOMImplementation(null);
    };
    exports2.createDocument = function (html, force) {
      if (html || force) {
        var parser = new HTMLParser();
        parser.parse(html || '', true);
        return parser.document();
      }
      return new DOMImplementation(null).createHTMLDocument('');
    };
    exports2.createIncrementalHTMLParser = function () {
      var parser = new HTMLParser();
      return {
        /** Provide an additional chunk of text to be parsed. */
        write: function (s) {
          if (s.length > 0) {
            parser.parse(s, false, function () {
              return true;
            });
          }
        },
        /**
         * Signal that we are done providing input text, optionally
         * providing one last chunk as a parameter.
         */
        end: function (s) {
          parser.parse(s || '', true, function () {
            return true;
          });
        },
        /**
         * Performs a chunk of parsing work, returning at the end of
         * the next token as soon as shouldPauseFunc() returns true.
         * Returns true iff there is more work to do.
         *
         * For example:
         * ```
         *  var incrParser = domino.createIncrementalHTMLParser();
         *  incrParser.end('...long html document...');
         *  while (true) {
         *    // Pause every 10ms
         *    var start = Date.now();
         *    var pauseIn10 = function() { return (Date.now() - start) >= 10; };
         *    if (!incrParser.process(pauseIn10)) {
         *      break;
         *    }
         *    ...yield to other tasks, do other housekeeping, etc...
         *  }
         * ```
         */
        process: function (shouldPauseFunc) {
          return parser.parse('', false, shouldPauseFunc);
        },
        /**
         * Returns the result of the incremental parse.  Valid after
         * `this.end()` has been called and `this.process()` has returned
         * false.
         */
        document: function () {
          return parser.document();
        },
      };
    };
    exports2.createWindow = function (html, address) {
      var document = exports2.createDocument(html);
      if (address !== void 0) {
        document._address = address;
      }
      return new impl.Window(document);
    };
    exports2.impl = impl;
  },
});

// node_modules/turndown/lib/turndown.cjs.js
var require_turndown_cjs = __commonJS({
  'node_modules/turndown/lib/turndown.cjs.js'(exports2, module2) {
    'use strict';
    function extend(destination) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) destination[key] = source[key];
        }
      }
      return destination;
    }
    function repeat(character, count) {
      return Array(count + 1).join(character);
    }
    function trimLeadingNewlines(string) {
      return string.replace(/^\n*/, '');
    }
    function trimTrailingNewlines(string) {
      var indexEnd = string.length;
      while (indexEnd > 0 && string[indexEnd - 1] === '\n') indexEnd--;
      return string.substring(0, indexEnd);
    }
    var blockElements = [
      'ADDRESS',
      'ARTICLE',
      'ASIDE',
      'AUDIO',
      'BLOCKQUOTE',
      'BODY',
      'CANVAS',
      'CENTER',
      'DD',
      'DIR',
      'DIV',
      'DL',
      'DT',
      'FIELDSET',
      'FIGCAPTION',
      'FIGURE',
      'FOOTER',
      'FORM',
      'FRAMESET',
      'H1',
      'H2',
      'H3',
      'H4',
      'H5',
      'H6',
      'HEADER',
      'HGROUP',
      'HR',
      'HTML',
      'ISINDEX',
      'LI',
      'MAIN',
      'MENU',
      'NAV',
      'NOFRAMES',
      'NOSCRIPT',
      'OL',
      'OUTPUT',
      'P',
      'PRE',
      'SECTION',
      'TABLE',
      'TBODY',
      'TD',
      'TFOOT',
      'TH',
      'THEAD',
      'TR',
      'UL',
    ];
    function isBlock(node) {
      return is(node, blockElements);
    }
    var voidElements = [
      'AREA',
      'BASE',
      'BR',
      'COL',
      'COMMAND',
      'EMBED',
      'HR',
      'IMG',
      'INPUT',
      'KEYGEN',
      'LINK',
      'META',
      'PARAM',
      'SOURCE',
      'TRACK',
      'WBR',
    ];
    function isVoid(node) {
      return is(node, voidElements);
    }
    function hasVoid(node) {
      return has(node, voidElements);
    }
    var meaningfulWhenBlankElements = [
      'A',
      'TABLE',
      'THEAD',
      'TBODY',
      'TFOOT',
      'TH',
      'TD',
      'IFRAME',
      'SCRIPT',
      'AUDIO',
      'VIDEO',
    ];
    function isMeaningfulWhenBlank(node) {
      return is(node, meaningfulWhenBlankElements);
    }
    function hasMeaningfulWhenBlank(node) {
      return has(node, meaningfulWhenBlankElements);
    }
    function is(node, tagNames) {
      return tagNames.indexOf(node.nodeName) >= 0;
    }
    function has(node, tagNames) {
      return (
        node.getElementsByTagName &&
        tagNames.some(function (tagName) {
          return node.getElementsByTagName(tagName).length;
        })
      );
    }
    var rules = {};
    rules.paragraph = {
      filter: 'p',
      replacement: function (content) {
        return '\n\n' + content + '\n\n';
      },
    };
    rules.lineBreak = {
      filter: 'br',
      replacement: function (content, node, options2) {
        return options2.br + '\n';
      },
    };
    rules.heading = {
      filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
      replacement: function (content, node, options2) {
        var hLevel = Number(node.nodeName.charAt(1));
        if (options2.headingStyle === 'setext' && hLevel < 3) {
          var underline = repeat(hLevel === 1 ? '=' : '-', content.length);
          return '\n\n' + content + '\n' + underline + '\n\n';
        } else {
          return '\n\n' + repeat('#', hLevel) + ' ' + content + '\n\n';
        }
      },
    };
    rules.blockquote = {
      filter: 'blockquote',
      replacement: function (content) {
        content = content.replace(/^\n+|\n+$/g, '');
        content = content.replace(/^/gm, '> ');
        return '\n\n' + content + '\n\n';
      },
    };
    rules.list = {
      filter: ['ul', 'ol'],
      replacement: function (content, node) {
        var parent = node.parentNode;
        if (parent.nodeName === 'LI' && parent.lastElementChild === node) {
          return '\n' + content;
        } else {
          return '\n\n' + content + '\n\n';
        }
      },
    };
    rules.listItem = {
      filter: 'li',
      replacement: function (content, node, options2) {
        content = content.replace(/^\n+/, '').replace(/\n+$/, '\n').replace(/\n/gm, '\n    ');
        var prefix = options2.bulletListMarker + '   ';
        var parent = node.parentNode;
        if (parent.nodeName === 'OL') {
          var start = parent.getAttribute('start');
          var index = Array.prototype.indexOf.call(parent.children, node);
          prefix = (start ? Number(start) + index : index + 1) + '.  ';
        }
        return prefix + content + (node.nextSibling && !/\n$/.test(content) ? '\n' : '');
      },
    };
    rules.indentedCodeBlock = {
      filter: function (node, options2) {
        return (
          options2.codeBlockStyle === 'indented' &&
          node.nodeName === 'PRE' &&
          node.firstChild &&
          node.firstChild.nodeName === 'CODE'
        );
      },
      replacement: function (content, node, options2) {
        return '\n\n    ' + node.firstChild.textContent.replace(/\n/g, '\n    ') + '\n\n';
      },
    };
    rules.fencedCodeBlock = {
      filter: function (node, options2) {
        return (
          options2.codeBlockStyle === 'fenced' &&
          node.nodeName === 'PRE' &&
          node.firstChild &&
          node.firstChild.nodeName === 'CODE'
        );
      },
      replacement: function (content, node, options2) {
        var className = node.firstChild.getAttribute('class') || '';
        var language = (className.match(/language-(\S+)/) || [null, ''])[1];
        var code = node.firstChild.textContent;
        var fenceChar = options2.fence.charAt(0);
        var fenceSize = 3;
        var fenceInCodeRegex = new RegExp('^' + fenceChar + '{3,}', 'gm');
        var match;
        while ((match = fenceInCodeRegex.exec(code))) {
          if (match[0].length >= fenceSize) {
            fenceSize = match[0].length + 1;
          }
        }
        var fence = repeat(fenceChar, fenceSize);
        return '\n\n' + fence + language + '\n' + code.replace(/\n$/, '') + '\n' + fence + '\n\n';
      },
    };
    rules.horizontalRule = {
      filter: 'hr',
      replacement: function (content, node, options2) {
        return '\n\n' + options2.hr + '\n\n';
      },
    };
    rules.inlineLink = {
      filter: function (node, options2) {
        return options2.linkStyle === 'inlined' && node.nodeName === 'A' && node.getAttribute('href');
      },
      replacement: function (content, node) {
        var href = node.getAttribute('href');
        if (href) href = href.replace(/([()])/g, '\\$1');
        var title = cleanAttribute(node.getAttribute('title'));
        if (title) title = ' "' + title.replace(/"/g, '\\"') + '"';
        return '[' + content + '](' + href + title + ')';
      },
    };
    rules.referenceLink = {
      filter: function (node, options2) {
        return options2.linkStyle === 'referenced' && node.nodeName === 'A' && node.getAttribute('href');
      },
      replacement: function (content, node, options2) {
        var href = node.getAttribute('href');
        var title = cleanAttribute(node.getAttribute('title'));
        if (title) title = ' "' + title + '"';
        var replacement;
        var reference;
        switch (options2.linkReferenceStyle) {
          case 'collapsed':
            replacement = '[' + content + '][]';
            reference = '[' + content + ']: ' + href + title;
            break;
          case 'shortcut':
            replacement = '[' + content + ']';
            reference = '[' + content + ']: ' + href + title;
            break;
          default:
            var id = this.references.length + 1;
            replacement = '[' + content + '][' + id + ']';
            reference = '[' + id + ']: ' + href + title;
        }
        this.references.push(reference);
        return replacement;
      },
      references: [],
      append: function (options2) {
        var references = '';
        if (this.references.length) {
          references = '\n\n' + this.references.join('\n') + '\n\n';
          this.references = [];
        }
        return references;
      },
    };
    rules.emphasis = {
      filter: ['em', 'i'],
      replacement: function (content, node, options2) {
        if (!content.trim()) return '';
        return options2.emDelimiter + content + options2.emDelimiter;
      },
    };
    rules.strong = {
      filter: ['strong', 'b'],
      replacement: function (content, node, options2) {
        if (!content.trim()) return '';
        return options2.strongDelimiter + content + options2.strongDelimiter;
      },
    };
    rules.code = {
      filter: function (node) {
        var hasSiblings = node.previousSibling || node.nextSibling;
        var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings;
        return node.nodeName === 'CODE' && !isCodeBlock;
      },
      replacement: function (content) {
        if (!content) return '';
        content = content.replace(/\r?\n|\r/g, ' ');
        var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? ' ' : '';
        var delimiter = '`';
        var matches = content.match(/`+/gm) || [];
        while (matches.indexOf(delimiter) !== -1) delimiter = delimiter + '`';
        return delimiter + extraSpace + content + extraSpace + delimiter;
      },
    };
    rules.image = {
      filter: 'img',
      replacement: function (content, node) {
        var alt = cleanAttribute(node.getAttribute('alt'));
        var src = node.getAttribute('src') || '';
        var title = cleanAttribute(node.getAttribute('title'));
        var titlePart = title ? ' "' + title + '"' : '';
        return src ? '![' + alt + '](' + src + titlePart + ')' : '';
      },
    };
    function cleanAttribute(attribute) {
      return attribute ? attribute.replace(/(\n+\s*)+/g, '\n') : '';
    }
    function Rules(options2) {
      this.options = options2;
      this._keep = [];
      this._remove = [];
      this.blankRule = {
        replacement: options2.blankReplacement,
      };
      this.keepReplacement = options2.keepReplacement;
      this.defaultRule = {
        replacement: options2.defaultReplacement,
      };
      this.array = [];
      for (var key in options2.rules) this.array.push(options2.rules[key]);
    }
    Rules.prototype = {
      add: function (key, rule) {
        this.array.unshift(rule);
      },
      keep: function (filter) {
        this._keep.unshift({
          filter,
          replacement: this.keepReplacement,
        });
      },
      remove: function (filter) {
        this._remove.unshift({
          filter,
          replacement: function () {
            return '';
          },
        });
      },
      forNode: function (node) {
        if (node.isBlank) return this.blankRule;
        var rule;
        if ((rule = findRule(this.array, node, this.options))) return rule;
        if ((rule = findRule(this._keep, node, this.options))) return rule;
        if ((rule = findRule(this._remove, node, this.options))) return rule;
        return this.defaultRule;
      },
      forEach: function (fn) {
        for (var i = 0; i < this.array.length; i++) fn(this.array[i], i);
      },
    };
    function findRule(rules2, node, options2) {
      for (var i = 0; i < rules2.length; i++) {
        var rule = rules2[i];
        if (filterValue(rule, node, options2)) return rule;
      }
      return void 0;
    }
    function filterValue(rule, node, options2) {
      var filter = rule.filter;
      if (typeof filter === 'string') {
        if (filter === node.nodeName.toLowerCase()) return true;
      } else if (Array.isArray(filter)) {
        if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true;
      } else if (typeof filter === 'function') {
        if (filter.call(rule, node, options2)) return true;
      } else {
        throw new TypeError('`filter` needs to be a string, array, or function');
      }
    }
    function collapseWhitespace(options2) {
      var element = options2.element;
      var isBlock2 = options2.isBlock;
      var isVoid2 = options2.isVoid;
      var isPre =
        options2.isPre ||
        function (node2) {
          return node2.nodeName === 'PRE';
        };
      if (!element.firstChild || isPre(element)) return;
      var prevText = null;
      var keepLeadingWs = false;
      var prev = null;
      var node = next(prev, element, isPre);
      while (node !== element) {
        if (node.nodeType === 3 || node.nodeType === 4) {
          var text = node.data.replace(/[ \r\n\t]+/g, ' ');
          if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === ' ') {
            text = text.substr(1);
          }
          if (!text) {
            node = remove(node);
            continue;
          }
          node.data = text;
          prevText = node;
        } else if (node.nodeType === 1) {
          if (isBlock2(node) || node.nodeName === 'BR') {
            if (prevText) {
              prevText.data = prevText.data.replace(/ $/, '');
            }
            prevText = null;
            keepLeadingWs = false;
          } else if (isVoid2(node) || isPre(node)) {
            prevText = null;
            keepLeadingWs = true;
          } else if (prevText) {
            keepLeadingWs = false;
          }
        } else {
          node = remove(node);
          continue;
        }
        var nextNode = next(prev, node, isPre);
        prev = node;
        node = nextNode;
      }
      if (prevText) {
        prevText.data = prevText.data.replace(/ $/, '');
        if (!prevText.data) {
          remove(prevText);
        }
      }
    }
    function remove(node) {
      var next2 = node.nextSibling || node.parentNode;
      node.parentNode.removeChild(node);
      return next2;
    }
    function next(prev, current, isPre) {
      if ((prev && prev.parentNode === current) || isPre(current)) {
        return current.nextSibling || current.parentNode;
      }
      return current.firstChild || current.nextSibling || current.parentNode;
    }
    var root = typeof window !== 'undefined' ? window : {};
    function canParseHTMLNatively() {
      var Parser = root.DOMParser;
      var canParse = false;
      try {
        if (new Parser().parseFromString('', 'text/html')) {
          canParse = true;
        }
      } catch (e) {}
      return canParse;
    }
    function createHTMLParser() {
      var Parser = function () {};
      {
        var domino = require_lib();
        Parser.prototype.parseFromString = function (string) {
          return domino.createDocument(string);
        };
      }
      return Parser;
    }
    var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
    function RootNode(input, options2) {
      var root2;
      if (typeof input === 'string') {
        var doc = htmlParser().parseFromString(
          // DOM parsers arrange elements in the <head> and <body>.
          // Wrapping in a custom element ensures elements are reliably arranged in
          // a single element.
          '<x-turndown id="turndown-root">' + input + '</x-turndown>',
          'text/html',
        );
        root2 = doc.getElementById('turndown-root');
      } else {
        root2 = input.cloneNode(true);
      }
      collapseWhitespace({
        element: root2,
        isBlock,
        isVoid,
        isPre: options2.preformattedCode ? isPreOrCode : null,
      });
      return root2;
    }
    var _htmlParser;
    function htmlParser() {
      _htmlParser = _htmlParser || new HTMLParser();
      return _htmlParser;
    }
    function isPreOrCode(node) {
      return node.nodeName === 'PRE' || node.nodeName === 'CODE';
    }
    function Node(node, options2) {
      node.isBlock = isBlock(node);
      node.isCode = node.nodeName === 'CODE' || node.parentNode.isCode;
      node.isBlank = isBlank(node);
      node.flankingWhitespace = flankingWhitespace(node, options2);
      return node;
    }
    function isBlank(node) {
      return (
        !isVoid(node) &&
        !isMeaningfulWhenBlank(node) &&
        /^\s*$/i.test(node.textContent) &&
        !hasVoid(node) &&
        !hasMeaningfulWhenBlank(node)
      );
    }
    function flankingWhitespace(node, options2) {
      if (node.isBlock || (options2.preformattedCode && node.isCode)) {
        return { leading: '', trailing: '' };
      }
      var edges = edgeWhitespace(node.textContent);
      if (edges.leadingAscii && isFlankedByWhitespace('left', node, options2)) {
        edges.leading = edges.leadingNonAscii;
      }
      if (edges.trailingAscii && isFlankedByWhitespace('right', node, options2)) {
        edges.trailing = edges.trailingNonAscii;
      }
      return { leading: edges.leading, trailing: edges.trailing };
    }
    function edgeWhitespace(string) {
      var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
      return {
        leading: m[1],
        // whole string for whitespace-only strings
        leadingAscii: m[2],
        leadingNonAscii: m[3],
        trailing: m[4],
        // empty for whitespace-only strings
        trailingNonAscii: m[5],
        trailingAscii: m[6],
      };
    }
    function isFlankedByWhitespace(side, node, options2) {
      var sibling;
      var regExp;
      var isFlanked;
      if (side === 'left') {
        sibling = node.previousSibling;
        regExp = / $/;
      } else {
        sibling = node.nextSibling;
        regExp = /^ /;
      }
      if (sibling) {
        if (sibling.nodeType === 3) {
          isFlanked = regExp.test(sibling.nodeValue);
        } else if (options2.preformattedCode && sibling.nodeName === 'CODE') {
          isFlanked = false;
        } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
          isFlanked = regExp.test(sibling.textContent);
        }
      }
      return isFlanked;
    }
    var reduce = Array.prototype.reduce;
    var escapes = [
      [/\\/g, '\\\\'],
      [/\*/g, '\\*'],
      [/^-/g, '\\-'],
      [/^\+ /g, '\\+ '],
      [/^(=+)/g, '\\$1'],
      [/^(#{1,6}) /g, '\\$1 '],
      [/`/g, '\\`'],
      [/^~~~/g, '\\~~~'],
      [/\[/g, '\\['],
      [/\]/g, '\\]'],
      [/^>/g, '\\>'],
      [/_/g, '\\_'],
      [/^(\d+)\. /g, '$1\\. '],
    ];
    function TurndownService2(options2) {
      if (!(this instanceof TurndownService2)) return new TurndownService2(options2);
      var defaults = {
        rules,
        headingStyle: 'setext',
        hr: '* * *',
        bulletListMarker: '*',
        codeBlockStyle: 'indented',
        fence: '```',
        emDelimiter: '_',
        strongDelimiter: '**',
        linkStyle: 'inlined',
        linkReferenceStyle: 'full',
        br: '  ',
        preformattedCode: false,
        blankReplacement: function (content, node) {
          return node.isBlock ? '\n\n' : '';
        },
        keepReplacement: function (content, node) {
          return node.isBlock ? '\n\n' + node.outerHTML + '\n\n' : node.outerHTML;
        },
        defaultReplacement: function (content, node) {
          return node.isBlock ? '\n\n' + content + '\n\n' : content;
        },
      };
      this.options = extend({}, defaults, options2);
      this.rules = new Rules(this.options);
    }
    TurndownService2.prototype = {
      /**
       * The entry point for converting a string or DOM node to Markdown
       * @public
       * @param {String|HTMLElement} input The string or DOM node to convert
       * @returns A Markdown representation of the input
       * @type String
       */
      turndown: function (input) {
        if (!canConvert(input)) {
          throw new TypeError(input + ' is not a string, or an element/document/fragment node.');
        }
        if (input === '') return '';
        var output = process10.call(this, new RootNode(input, this.options));
        return postProcess.call(this, output);
      },
      /**
       * Add one or more plugins
       * @public
       * @param {Function|Array} plugin The plugin or array of plugins to add
       * @returns The Turndown instance for chaining
       * @type Object
       */
      use: function (plugin) {
        if (Array.isArray(plugin)) {
          for (var i = 0; i < plugin.length; i++) this.use(plugin[i]);
        } else if (typeof plugin === 'function') {
          plugin(this);
        } else {
          throw new TypeError('plugin must be a Function or an Array of Functions');
        }
        return this;
      },
      /**
       * Adds a rule
       * @public
       * @param {String} key The unique key of the rule
       * @param {Object} rule The rule
       * @returns The Turndown instance for chaining
       * @type Object
       */
      addRule: function (key, rule) {
        this.rules.add(key, rule);
        return this;
      },
      /**
       * Keep a node (as HTML) that matches the filter
       * @public
       * @param {String|Array|Function} filter The unique key of the rule
       * @returns The Turndown instance for chaining
       * @type Object
       */
      keep: function (filter) {
        this.rules.keep(filter);
        return this;
      },
      /**
       * Remove a node that matches the filter
       * @public
       * @param {String|Array|Function} filter The unique key of the rule
       * @returns The Turndown instance for chaining
       * @type Object
       */
      remove: function (filter) {
        this.rules.remove(filter);
        return this;
      },
      /**
       * Escapes Markdown syntax
       * @public
       * @param {String} string The string to escape
       * @returns A string with Markdown syntax escaped
       * @type String
       */
      escape: function (string) {
        return escapes.reduce(function (accumulator, escape) {
          return accumulator.replace(escape[0], escape[1]);
        }, string);
      },
    };
    function process10(parentNode) {
      var self = this;
      return reduce.call(
        parentNode.childNodes,
        function (output, node) {
          node = new Node(node, self.options);
          var replacement = '';
          if (node.nodeType === 3) {
            replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
          } else if (node.nodeType === 1) {
            replacement = replacementForNode.call(self, node);
          }
          return join(output, replacement);
        },
        '',
      );
    }
    function postProcess(output) {
      var self = this;
      this.rules.forEach(function (rule) {
        if (typeof rule.append === 'function') {
          output = join(output, rule.append(self.options));
        }
      });
      return output.replace(/^[\t\r\n]+/, '').replace(/[\t\r\n\s]+$/, '');
    }
    function replacementForNode(node) {
      var rule = this.rules.forNode(node);
      var content = process10.call(this, node);
      var whitespace = node.flankingWhitespace;
      if (whitespace.leading || whitespace.trailing) content = content.trim();
      return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
    }
    function join(output, replacement) {
      var s1 = trimTrailingNewlines(output);
      var s2 = trimLeadingNewlines(replacement);
      var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
      var separator = '\n\n'.substring(0, nls);
      return s1 + separator + s2;
    }
    function canConvert(input) {
      return (
        input != null &&
        (typeof input === 'string' ||
          (input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11)))
      );
    }
    module2.exports = TurndownService2;
  },
});

// scripts/update-changelog/update-changelog.mjs
var update_changelog_exports = {};
__export(update_changelog_exports, {
  preCommit: () => preCommit,
});
module.exports = __toCommonJS(update_changelog_exports);
var import_fs = __toESM(require('fs'), 1);
var import_url = require('url');
var import_semver2 = __toESM(require_semver2(), 1);

// node_modules/ky/distribution/errors/HTTPError.js
var HTTPError = class extends Error {
  response;
  request;
  options;
  constructor(response, request2, options2) {
    const code = response.status || response.status === 0 ? response.status : '';
    const title = response.statusText || '';
    const status = `${code} ${title}`.trim();
    const reason = status ? `status code ${status}` : 'an unknown error';
    super(`Request failed with ${reason}: ${request2.method} ${request2.url}`);
    this.name = 'HTTPError';
    this.response = response;
    this.request = request2;
    this.options = options2;
  }
};

// node_modules/ky/distribution/errors/TimeoutError.js
var TimeoutError = class extends Error {
  request;
  constructor(request2) {
    super(`Request timed out: ${request2.method} ${request2.url}`);
    this.name = 'TimeoutError';
    this.request = request2;
  }
};

// node_modules/ky/distribution/core/constants.js
var supportsRequestStreams = (() => {
  let duplexAccessed = false;
  let hasContentType = false;
  const supportsReadableStream = typeof globalThis.ReadableStream === 'function';
  const supportsRequest = typeof globalThis.Request === 'function';
  if (supportsReadableStream && supportsRequest) {
    try {
      hasContentType = new globalThis.Request('https://empty.invalid', {
        body: new globalThis.ReadableStream(),
        method: 'POST',
        // @ts-expect-error - Types are outdated.
        get duplex() {
          duplexAccessed = true;
          return 'half';
        },
      }).headers.has('Content-Type');
    } catch (error) {
      if (error instanceof Error && error.message === 'unsupported BodyInit type') {
        return false;
      }
      throw error;
    }
  }
  return duplexAccessed && !hasContentType;
})();
var supportsAbortController = typeof globalThis.AbortController === 'function';
var supportsResponseStreams = typeof globalThis.ReadableStream === 'function';
var supportsFormData = typeof globalThis.FormData === 'function';
var requestMethods = ['get', 'post', 'put', 'patch', 'head', 'delete'];
var validate = () => void 0;
validate();
var responseTypes = {
  json: 'application/json',
  text: 'text/*',
  formData: 'multipart/form-data',
  arrayBuffer: '*/*',
  blob: '*/*',
};
var maxSafeTimeout = 2147483647;
var usualFormBoundarySize = new TextEncoder().encode('------WebKitFormBoundaryaxpyiPgbbPti10Rw').length;
var stop = Symbol('stop');
var kyOptionKeys = {
  json: true,
  parseJson: true,
  stringifyJson: true,
  searchParams: true,
  prefixUrl: true,
  retry: true,
  timeout: true,
  hooks: true,
  throwHttpErrors: true,
  onDownloadProgress: true,
  onUploadProgress: true,
  fetch: true,
};
var requestOptionsRegistry = {
  method: true,
  headers: true,
  body: true,
  mode: true,
  credentials: true,
  cache: true,
  redirect: true,
  referrer: true,
  referrerPolicy: true,
  integrity: true,
  keepalive: true,
  signal: true,
  window: true,
  dispatcher: true,
  duplex: true,
  priority: true,
};

// node_modules/ky/distribution/utils/body.js
var getBodySize = (body) => {
  if (!body) {
    return 0;
  }
  if (body instanceof FormData) {
    let size = 0;
    for (const [key, value] of body) {
      size += usualFormBoundarySize;
      size += new TextEncoder().encode(`Content-Disposition: form-data; name="${key}"`).length;
      size += typeof value === 'string' ? new TextEncoder().encode(value).length : value.size;
    }
    return size;
  }
  if (body instanceof Blob) {
    return body.size;
  }
  if (body instanceof ArrayBuffer) {
    return body.byteLength;
  }
  if (typeof body === 'string') {
    return new TextEncoder().encode(body).length;
  }
  if (body instanceof URLSearchParams) {
    return new TextEncoder().encode(body.toString()).length;
  }
  if ('byteLength' in body) {
    return body.byteLength;
  }
  if (typeof body === 'object' && body !== null) {
    try {
      const jsonString = JSON.stringify(body);
      return new TextEncoder().encode(jsonString).length;
    } catch {
      return 0;
    }
  }
  return 0;
};
var streamResponse = (response, onDownloadProgress) => {
  const totalBytes = Number(response.headers.get('content-length')) || 0;
  let transferredBytes = 0;
  if (response.status === 204) {
    if (onDownloadProgress) {
      onDownloadProgress({ percent: 1, totalBytes, transferredBytes }, new Uint8Array());
    }
    return new Response(null, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers,
    });
  }
  return new Response(
    new ReadableStream({
      async start(controller) {
        const reader = response.body.getReader();
        if (onDownloadProgress) {
          onDownloadProgress({ percent: 0, transferredBytes: 0, totalBytes }, new Uint8Array());
        }
        async function read() {
          const { done, value } = await reader.read();
          if (done) {
            controller.close();
            return;
          }
          if (onDownloadProgress) {
            transferredBytes += value.byteLength;
            const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
            onDownloadProgress({ percent, transferredBytes, totalBytes }, value);
          }
          controller.enqueue(value);
          await read();
        }
        await read();
      },
    }),
    {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers,
    },
  );
};
var streamRequest = (request2, onUploadProgress) => {
  const totalBytes = getBodySize(request2.body);
  let transferredBytes = 0;
  return new Request(request2, {
    // @ts-expect-error - Types are outdated.
    duplex: 'half',
    body: new ReadableStream({
      async start(controller) {
        const reader =
          request2.body instanceof ReadableStream ? request2.body.getReader() : new Response('').body.getReader();
        async function read() {
          const { done, value } = await reader.read();
          if (done) {
            if (onUploadProgress) {
              onUploadProgress(
                { percent: 1, transferredBytes, totalBytes: Math.max(totalBytes, transferredBytes) },
                new Uint8Array(),
              );
            }
            controller.close();
            return;
          }
          transferredBytes += value.byteLength;
          let percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
          if (totalBytes < transferredBytes || percent === 1) {
            percent = 0.99;
          }
          if (onUploadProgress) {
            onUploadProgress({ percent: Number(percent.toFixed(2)), transferredBytes, totalBytes }, value);
          }
          controller.enqueue(value);
          await read();
        }
        await read();
      },
    }),
  });
};

// node_modules/ky/distribution/utils/is.js
var isObject = (value) => value !== null && typeof value === 'object';

// node_modules/ky/distribution/utils/merge.js
var validateAndMerge = (...sources) => {
  for (const source of sources) {
    if ((!isObject(source) || Array.isArray(source)) && source !== void 0) {
      throw new TypeError('The `options` argument must be an object');
    }
  }
  return deepMerge({}, ...sources);
};
var mergeHeaders = (source1 = {}, source2 = {}) => {
  const result = new globalThis.Headers(source1);
  const isHeadersInstance = source2 instanceof globalThis.Headers;
  const source = new globalThis.Headers(source2);
  for (const [key, value] of source.entries()) {
    if ((isHeadersInstance && value === 'undefined') || value === void 0) {
      result.delete(key);
    } else {
      result.set(key, value);
    }
  }
  return result;
};
function newHookValue(original, incoming, property) {
  return Object.hasOwn(incoming, property) && incoming[property] === void 0
    ? []
    : deepMerge(original[property] ?? [], incoming[property] ?? []);
}
var mergeHooks = (original = {}, incoming = {}) => ({
  beforeRequest: newHookValue(original, incoming, 'beforeRequest'),
  beforeRetry: newHookValue(original, incoming, 'beforeRetry'),
  afterResponse: newHookValue(original, incoming, 'afterResponse'),
  beforeError: newHookValue(original, incoming, 'beforeError'),
});
var deepMerge = (...sources) => {
  let returnValue = {};
  let headers = {};
  let hooks = {};
  for (const source of sources) {
    if (Array.isArray(source)) {
      if (!Array.isArray(returnValue)) {
        returnValue = [];
      }
      returnValue = [...returnValue, ...source];
    } else if (isObject(source)) {
      for (let [key, value] of Object.entries(source)) {
        if (isObject(value) && key in returnValue) {
          value = deepMerge(returnValue[key], value);
        }
        returnValue = { ...returnValue, [key]: value };
      }
      if (isObject(source.hooks)) {
        hooks = mergeHooks(hooks, source.hooks);
        returnValue.hooks = hooks;
      }
      if (isObject(source.headers)) {
        headers = mergeHeaders(headers, source.headers);
        returnValue.headers = headers;
      }
    }
  }
  return returnValue;
};

// node_modules/ky/distribution/utils/normalize.js
var normalizeRequestMethod = (input) => (requestMethods.includes(input) ? input.toUpperCase() : input);
var retryMethods = ['get', 'put', 'head', 'delete', 'options', 'trace'];
var retryStatusCodes = [408, 413, 429, 500, 502, 503, 504];
var retryAfterStatusCodes = [413, 429, 503];
var defaultRetryOptions = {
  limit: 2,
  methods: retryMethods,
  statusCodes: retryStatusCodes,
  afterStatusCodes: retryAfterStatusCodes,
  maxRetryAfter: Number.POSITIVE_INFINITY,
  backoffLimit: Number.POSITIVE_INFINITY,
  delay: (attemptCount) => 0.3 * 2 ** (attemptCount - 1) * 1e3,
};
var normalizeRetryOptions = (retry = {}) => {
  if (typeof retry === 'number') {
    return {
      ...defaultRetryOptions,
      limit: retry,
    };
  }
  if (retry.methods && !Array.isArray(retry.methods)) {
    throw new Error('retry.methods must be an array');
  }
  if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
    throw new Error('retry.statusCodes must be an array');
  }
  return {
    ...defaultRetryOptions,
    ...retry,
  };
};

// node_modules/ky/distribution/utils/timeout.js
async function timeout(request2, init, abortController, options2) {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      if (abortController) {
        abortController.abort();
      }
      reject(new TimeoutError(request2));
    }, options2.timeout);
    void options2
      .fetch(request2, init)
      .then(resolve)
      .catch(reject)
      .then(() => {
        clearTimeout(timeoutId);
      });
  });
}

// node_modules/ky/distribution/utils/delay.js
async function delay(ms, { signal }) {
  return new Promise((resolve, reject) => {
    if (signal) {
      signal.throwIfAborted();
      signal.addEventListener('abort', abortHandler, { once: true });
    }
    function abortHandler() {
      clearTimeout(timeoutId);
      reject(signal.reason);
    }
    const timeoutId = setTimeout(() => {
      signal?.removeEventListener('abort', abortHandler);
      resolve();
    }, ms);
  });
}

// node_modules/ky/distribution/utils/options.js
var findUnknownOptions = (request2, options2) => {
  const unknownOptions = {};
  for (const key in options2) {
    if (!(key in requestOptionsRegistry) && !(key in kyOptionKeys) && !(key in request2)) {
      unknownOptions[key] = options2[key];
    }
  }
  return unknownOptions;
};

// node_modules/ky/distribution/core/Ky.js
var Ky = class _Ky {
  static create(input, options2) {
    const ky2 = new _Ky(input, options2);
    const function_ = async () => {
      if (typeof ky2._options.timeout === 'number' && ky2._options.timeout > maxSafeTimeout) {
        throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
      }
      await Promise.resolve();
      let response = await ky2._fetch();
      for (const hook2 of ky2._options.hooks.afterResponse) {
        const modifiedResponse = await hook2(ky2.request, ky2._options, ky2._decorateResponse(response.clone()));
        if (modifiedResponse instanceof globalThis.Response) {
          response = modifiedResponse;
        }
      }
      ky2._decorateResponse(response);
      if (!response.ok && ky2._options.throwHttpErrors) {
        let error = new HTTPError(response, ky2.request, ky2._options);
        for (const hook2 of ky2._options.hooks.beforeError) {
          error = await hook2(error);
        }
        throw error;
      }
      if (!ky2.request.bodyUsed) {
        await ky2.request.body?.cancel();
      }
      if (ky2._options.onDownloadProgress) {
        if (typeof ky2._options.onDownloadProgress !== 'function') {
          throw new TypeError('The `onDownloadProgress` option must be a function');
        }
        if (!supportsResponseStreams) {
          throw new Error('Streams are not supported in your environment. `ReadableStream` is missing.');
        }
        return streamResponse(response.clone(), ky2._options.onDownloadProgress);
      }
      return response;
    };
    const isRetriableMethod = ky2._options.retry.methods.includes(ky2.request.method.toLowerCase());
    const result = isRetriableMethod ? ky2._retry(function_) : function_();
    for (const [type, mimeType] of Object.entries(responseTypes)) {
      result[type] = async () => {
        ky2.request.headers.set('accept', ky2.request.headers.get('accept') || mimeType);
        const response = await result;
        if (type === 'json') {
          if (response.status === 204) {
            return '';
          }
          const arrayBuffer = await response.clone().arrayBuffer();
          const responseSize = arrayBuffer.byteLength;
          if (responseSize === 0) {
            return '';
          }
          if (options2.parseJson) {
            return options2.parseJson(await response.text());
          }
        }
        return response[type]();
      };
    }
    return result;
  }
  request;
  abortController;
  _retryCount = 0;
  _input;
  _options;
  // eslint-disable-next-line complexity
  constructor(input, options2 = {}) {
    this._input = input;
    this._options = {
      ...options2,
      headers: mergeHeaders(this._input.headers, options2.headers),
      hooks: mergeHooks(
        {
          beforeRequest: [],
          beforeRetry: [],
          beforeError: [],
          afterResponse: [],
        },
        options2.hooks,
      ),
      method: normalizeRequestMethod(options2.method ?? this._input.method ?? 'GET'),
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      prefixUrl: String(options2.prefixUrl || ''),
      retry: normalizeRetryOptions(options2.retry),
      throwHttpErrors: options2.throwHttpErrors !== false,
      timeout: options2.timeout ?? 1e4,
      fetch: options2.fetch ?? globalThis.fetch.bind(globalThis),
    };
    if (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globalThis.Request)) {
      throw new TypeError('`input` must be a string, URL, or Request');
    }
    if (this._options.prefixUrl && typeof this._input === 'string') {
      if (this._input.startsWith('/')) {
        throw new Error('`input` must not begin with a slash when using `prefixUrl`');
      }
      if (!this._options.prefixUrl.endsWith('/')) {
        this._options.prefixUrl += '/';
      }
      this._input = this._options.prefixUrl + this._input;
    }
    if (supportsAbortController) {
      const originalSignal = this._options.signal ?? this._input.signal;
      this.abortController = new globalThis.AbortController();
      this._options.signal = originalSignal
        ? AbortSignal.any([originalSignal, this.abortController.signal])
        : this.abortController.signal;
    }
    if (supportsRequestStreams) {
      this._options.duplex = 'half';
    }
    if (this._options.json !== void 0) {
      this._options.body = this._options.stringifyJson?.(this._options.json) ?? JSON.stringify(this._options.json);
      this._options.headers.set('content-type', this._options.headers.get('content-type') ?? 'application/json');
    }
    this.request = new globalThis.Request(this._input, this._options);
    if (this._options.searchParams) {
      const textSearchParams =
        typeof this._options.searchParams === 'string'
          ? this._options.searchParams.replace(/^\?/, '')
          : new URLSearchParams(this._options.searchParams).toString();
      const searchParams = '?' + textSearchParams;
      const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);
      if (
        ((supportsFormData && this._options.body instanceof globalThis.FormData) ||
          this._options.body instanceof URLSearchParams) &&
        !(this._options.headers && this._options.headers['content-type'])
      ) {
        this.request.headers.delete('content-type');
      }
      this.request = new globalThis.Request(new globalThis.Request(url, { ...this.request }), this._options);
    }
    if (this._options.onUploadProgress) {
      if (typeof this._options.onUploadProgress !== 'function') {
        throw new TypeError('The `onUploadProgress` option must be a function');
      }
      if (!supportsRequestStreams) {
        throw new Error(
          'Request streams are not supported in your environment. The `duplex` option for `Request` is not available.',
        );
      }
      const originalBody = this.request.body;
      if (originalBody) {
        this.request = streamRequest(this.request, this._options.onUploadProgress);
      }
    }
  }
  _calculateRetryDelay(error) {
    this._retryCount++;
    if (this._retryCount > this._options.retry.limit || error instanceof TimeoutError) {
      throw error;
    }
    if (error instanceof HTTPError) {
      if (!this._options.retry.statusCodes.includes(error.response.status)) {
        throw error;
      }
      const retryAfter =
        error.response.headers.get('Retry-After') ??
        error.response.headers.get('RateLimit-Reset') ??
        error.response.headers.get('X-RateLimit-Reset') ??
        error.response.headers.get('X-Rate-Limit-Reset');
      if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
        let after = Number(retryAfter) * 1e3;
        if (Number.isNaN(after)) {
          after = Date.parse(retryAfter) - Date.now();
        } else if (after >= Date.parse('2024-01-01')) {
          after -= Date.now();
        }
        const max = this._options.retry.maxRetryAfter ?? after;
        return after < max ? after : max;
      }
      if (error.response.status === 413) {
        throw error;
      }
    }
    const retryDelay = this._options.retry.delay(this._retryCount);
    return Math.min(this._options.retry.backoffLimit, retryDelay);
  }
  _decorateResponse(response) {
    if (this._options.parseJson) {
      response.json = async () => this._options.parseJson(await response.text());
    }
    return response;
  }
  async _retry(function_) {
    try {
      return await function_();
    } catch (error) {
      const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);
      if (this._retryCount < 1) {
        throw error;
      }
      await delay(ms, { signal: this._options.signal });
      for (const hook2 of this._options.hooks.beforeRetry) {
        const hookResult = await hook2({
          request: this.request,
          options: this._options,
          error,
          retryCount: this._retryCount,
        });
        if (hookResult === stop) {
          return;
        }
      }
      return this._retry(function_);
    }
  }
  async _fetch() {
    for (const hook2 of this._options.hooks.beforeRequest) {
      const result = await hook2(this.request, this._options);
      if (result instanceof Request) {
        this.request = result;
        break;
      }
      if (result instanceof Response) {
        return result;
      }
    }
    const nonRequestOptions = findUnknownOptions(this.request, this._options);
    const mainRequest = this.request;
    this.request = mainRequest.clone();
    if (this._options.timeout === false) {
      return this._options.fetch(mainRequest, nonRequestOptions);
    }
    return timeout(mainRequest, nonRequestOptions, this.abortController, this._options);
  }
};

// node_modules/ky/distribution/index.js
var createInstance = (defaults) => {
  const ky2 = (input, options2) => Ky.create(input, validateAndMerge(defaults, options2));
  for (const method of requestMethods) {
    ky2[method] = (input, options2) => Ky.create(input, validateAndMerge(defaults, options2, { method }));
  }
  ky2.create = (newDefaults) => createInstance(validateAndMerge(newDefaults));
  ky2.extend = (newDefaults) => {
    if (typeof newDefaults === 'function') {
      newDefaults = newDefaults(defaults ?? {});
    }
    return createInstance(validateAndMerge(defaults, newDefaults));
  };
  ky2.stop = stop;
  return ky2;
};
var ky = createInstance();
var distribution_default = ky;

// node_modules/registry-url/index.js
var import_rc = __toESM(require_rc(), 1);
function registryUrl(scope) {
  const result = (0, import_rc.default)('npm', { registry: 'https://registry.npmjs.org/' });
  const url = result[`${scope}:registry`] || result.config_registry || result.registry;
  return url.slice(-1) === '/' ? url : `${url}/`;
}

// node_modules/package-json/index.js
var import_registry_auth_token = __toESM(require_registry_auth_token(), 1);
var import_semver = __toESM(require_semver2(), 1);
var PackageNotFoundError = class extends Error {
  constructor(packageName) {
    super(`Package \`${packageName}\` could not be found`);
    this.name = 'PackageNotFoundError';
  }
};
var VersionNotFoundError = class extends Error {
  constructor(packageName, version) {
    super(`Version \`${version}\` for package \`${packageName}\` could not be found`);
    this.name = 'VersionNotFoundError';
  }
};
async function packageJson(packageName, options2 = {}) {
  let { version = 'latest' } = options2;
  const { omitDeprecated = true } = options2;
  const scope = packageName.split('/')[0];
  const registryUrl_ = options2.registryUrl ?? registryUrl(scope);
  const packageUrl = new URL(encodeURIComponent(packageName).replace(/^%40/, '@'), registryUrl_);
  const authInfo = (0, import_registry_auth_token.default)(registryUrl_.toString(), { recursive: true });
  const headers = {
    accept: 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*',
  };
  if (options2.fullMetadata) {
    delete headers.accept;
  }
  if (authInfo) {
    headers.authorization = `${authInfo.type} ${authInfo.token}`;
  }
  let data;
  try {
    data = await distribution_default(packageUrl, { headers, keepalive: true }).json();
  } catch (error) {
    if (error?.response?.status === 404) {
      throw new PackageNotFoundError(packageName);
    }
    throw error;
  }
  if (options2.allVersions) {
    return data;
  }
  const versionError = new VersionNotFoundError(packageName, version);
  if (data['dist-tags'][version]) {
    const { time } = data;
    data = data.versions[data['dist-tags'][version]];
    data.time = time;
  } else if (version) {
    const versionExists = Boolean(data.versions[version]);
    if (omitDeprecated && !versionExists) {
      for (const [metadataVersion, metadata] of Object.entries(data.versions)) {
        if (metadata.deprecated) {
          delete data.versions[metadataVersion];
        }
      }
    }
    if (!versionExists) {
      const versions = Object.keys(data.versions);
      version = import_semver.default.maxSatisfying(versions, version);
      if (!version) {
        throw versionError;
      }
    }
    const { time } = data;
    data = data.versions[version];
    data.time = time;
    if (!data) {
      throw versionError;
    }
  }
  return data;
}

// node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === 'object' && 'userAgent' in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === 'object' && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return '<environment undetectable>';
}

// node_modules/before-after-hook/lib/register.js
function register(state, name, method, options2) {
  if (typeof method !== 'function') {
    throw new Error('method for before hook must be a function');
  }
  if (!options2) {
    options2 = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options2);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options2);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options2);
    }, method)();
  });
}

// node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === 'before') {
    hook2 = (method, options2) => {
      return Promise.resolve().then(orig.bind(null, options2)).then(method.bind(null, options2));
    };
  }
  if (kind === 'after') {
    hook2 = (method, options2) => {
      let result;
      return Promise.resolve()
        .then(method.bind(null, options2))
        .then((result_) => {
          result = result_;
          return orig(result, options2);
        })
        .then(() => {
          return result;
        });
    };
  }
  if (kind === 'error') {
    hook2 = (method, options2) => {
      return Promise.resolve()
        .then(method.bind(null, options2))
        .catch((error) => {
          return orig(error, options2);
        });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig,
  });
}

// node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name]
    .map((registered) => {
      return registered.orig;
    })
    .indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ['before', 'error', 'after', 'wrap'].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol('Singular');
  const singularHookState = {
    registry: {},
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {},
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION = '0.0.0-development';
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
var DEFAULTS = {
  method: 'GET',
  baseUrl: 'https://api.github.com',
  headers: {
    accept: 'application/vnd.github.v3+json',
    'user-agent': userAgent,
  },
  mediaType: {
    format: '',
  },
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== 'object' || value === null) return false;
  if (Object.prototype.toString.call(value) !== '[object Object]') return false;
  const proto2 = Object.getPrototypeOf(value);
  if (proto2 === null) return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto2, 'constructor') && proto2.constructor;
  return (
    typeof Ctor === 'function' &&
    Ctor instanceof Ctor &&
    Function.prototype.call(Ctor) === Function.prototype.call(value)
  );
}
function mergeDeep(defaults, options2) {
  const result = Object.assign({}, defaults);
  Object.keys(options2).forEach((key) => {
    if (isPlainObject(options2[key])) {
      if (!(key in defaults)) Object.assign(result, { [key]: options2[key] });
      else result[key] = mergeDeep(defaults[key], options2[key]);
    } else {
      Object.assign(result, { [key]: options2[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options2) {
  if (typeof route === 'string') {
    let [method, url] = route.split(' ');
    options2 = Object.assign(url ? { method, url } : { url: method }, options2);
  } else {
    options2 = Object.assign({}, route);
  }
  options2.headers = lowercaseKeys(options2.headers);
  removeUndefinedProperties(options2);
  removeUndefinedProperties(options2.headers);
  const mergedOptions = mergeDeep(defaults || {}, options2);
  if (options2.url === '/graphql') {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews
        .filter((preview) => !mergedOptions.mediaType.previews.includes(preview))
        .concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) =>
      preview.replace(/-preview/, ''),
    );
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? '&' : '?';
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return (
    url +
    separator +
    names
      .map((name) => {
        if (name === 'q') {
          return 'q=' + parameters.q.split('+').map(encodeURIComponent).join('+');
        }
        return `${name}=${encodeURIComponent(parameters[name])}`;
      })
      .join('&')
  );
}
var urlVariableRegex = /\{[^{}}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, '').split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str
    .split(/(%[0-9A-Fa-f]{2})/g)
    .map(function (part) {
      if (!/%[0-9A-Fa-f]/.test(part)) {
        part = encodeURI(part).replace(/%5B/g, '[').replace(/%5D/g, ']');
      }
      return part;
    })
    .join('');
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + '=' + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ';' || operator === '&' || operator === '?';
}
function getValues(context, operator, key, modifier) {
  var value = context[key],
    result = [];
  if (isDefined(value) && value !== '') {
    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
      value = value.toString();
      if (modifier && modifier !== '*') {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ''));
    } else {
      if (modifier === '*') {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value2) {
            result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ''));
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + '=' + tmp.join(','));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(','));
        }
      }
    }
  } else {
    if (operator === ';') {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === '' && (operator === '&' || operator === '?')) {
      result.push(encodeUnreserved(key) + '=');
    } else if (value === '') {
      result.push('');
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template),
  };
}
function expand(template, context) {
  var operators = ['+', '#', '.', '/', ';', '?', '&'];
  template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
    if (expression) {
      let operator = '';
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function (variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== '+') {
        var separator = ',';
        if (operator === '?') {
          separator = '&';
        } else if (operator !== '#') {
          separator = operator;
        }
        return (values.length !== 0 ? operator : '') + values.join(separator);
      } else {
        return values.join(',');
      }
    } else {
      return encodeReserved(literal);
    }
  });
  if (template === '/') {
    return template;
  } else {
    return template.replace(/\/$/, '');
  }
}
function parse(options2) {
  let method = options2.method.toUpperCase();
  let url = (options2.url || '/').replace(/:([a-z]\w+)/g, '{$1}');
  let headers = Object.assign({}, options2.headers);
  let body;
  let parameters = omit(options2, ['method', 'baseUrl', 'url', 'headers', 'request', 'mediaType']);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options2.baseUrl + url;
  }
  const omittedParameters = Object.keys(options2)
    .filter((option) => urlVariableNames.includes(option))
    .concat('baseUrl');
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options2.mediaType.format) {
      headers.accept = headers.accept
        .split(/,/)
        .map((format) =>
          format.replace(
            /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
            `application/vnd$1$2.${options2.mediaType.format}`,
          ),
        )
        .join(',');
    }
    if (url.endsWith('/graphql')) {
      if (options2.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader
          .concat(options2.mediaType.previews)
          .map((preview) => {
            const format = options2.mediaType.format ? `.${options2.mediaType.format}` : '+json';
            return `application/vnd.github.${preview}-preview${format}`;
          })
          .join(',');
      }
    }
  }
  if (['GET', 'HEAD'].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ('data' in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers['content-type'] && typeof body !== 'undefined') {
    headers['content-type'] = 'application/json; charset=utf-8';
  }
  if (['PATCH', 'PUT'].includes(method) && typeof body === 'undefined') {
    body = '';
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== 'undefined' ? { body } : null,
    options2.request ? { request: options2.request } : null,
  );
}
function endpointWithDefaults(defaults, route, options2) {
  return parse(merge(defaults, route, options2));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse,
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/dist-bundle/index.js
var import_fast_content_type_parse = __toESM(require_fast_content_type_parse(), 1);

// node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
  name;
  /**
   * http status code
   */
  status;
  /**
   * Request options that lead to the error.
   */
  request;
  /**
   * Response object if a response was received
   */
  response;
  constructor(message, statusCode, options2) {
    super(message);
    this.name = 'HttpError';
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ('response' in options2) {
      this.response = options2.response;
    }
    const requestCopy = Object.assign({}, options2.request);
    if (options2.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options2.request.headers, {
        authorization: options2.request.headers.authorization.replace(/(?<! ) .*$/, ' [REDACTED]'),
      });
    }
    requestCopy.url = requestCopy.url
      .replace(/\bclient_secret=\w+/g, 'client_secret=[REDACTED]')
      .replace(/\baccess_token=\w+/g, 'access_token=[REDACTED]');
    this.request = requestCopy;
  }
};

// node_modules/@octokit/request/dist-bundle/index.js
var VERSION2 = '0.0.0-development';
var defaults_default = {
  headers: {
    'user-agent': `octokit-request.js/${VERSION2} ${getUserAgent()}`,
  },
};
function isPlainObject2(value) {
  if (typeof value !== 'object' || value === null) return false;
  if (Object.prototype.toString.call(value) !== '[object Object]') return false;
  const proto2 = Object.getPrototypeOf(value);
  if (proto2 === null) return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto2, 'constructor') && proto2.constructor;
  return (
    typeof Ctor === 'function' &&
    Ctor instanceof Ctor &&
    Function.prototype.call(Ctor) === Function.prototype.call(value)
  );
}
async function fetchWrapper(requestOptions) {
  const fetch = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch) {
    throw new Error(
      'fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing',
    );
  }
  const log = requestOptions.request?.log || console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  const body =
    isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)
      ? JSON.stringify(requestOptions.body)
      : requestOptions.body;
  const requestHeaders = Object.fromEntries(
    Object.entries(requestOptions.headers).map(([name, value]) => [name, String(value)]),
  );
  let fetchResponse;
  try {
    fetchResponse = await fetch(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      // duplex must be set if request.body is ReadableStream or Async Iterables.
      // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
      ...(requestOptions.body && { duplex: 'half' }),
    });
  } catch (error) {
    let message = 'Unknown Error';
    if (error instanceof Error) {
      if (error.name === 'AbortError') {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === 'TypeError' && 'cause' in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === 'string') {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError(message, 500, {
      request: requestOptions,
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: '',
  };
  if ('deprecation' in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log.warn(
      `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ''}`,
    );
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === 'HEAD') {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions,
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError('Not modified', status, {
      response: octokitResponse,
      request: requestOptions,
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError(toErrorMessage(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions,
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData(response) {
  const contentType = response.headers.get('content-type');
  if (!contentType) {
    return response.text().catch(() => '');
  }
  const mimetype = (0, import_fast_content_type_parse.safeParse)(contentType);
  if (isJSONResponse(mimetype)) {
    let text = '';
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith('text/') || mimetype.parameters.charset?.toLowerCase() === 'utf-8') {
    return response.text().catch(() => '');
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse(mimetype) {
  return mimetype.type === 'application/json' || mimetype.type === 'application/scim+json';
}
function toErrorMessage(data) {
  if (typeof data === 'string') {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return 'Unknown error';
  }
  if ('message' in data) {
    const suffix = 'documentation_url' in data ? ` - ${data.documentation_url}` : '';
    return Array.isArray(data.errors)
      ? `${data.message}: ${data.errors.map((v) => JSON.stringify(v)).join(', ')}${suffix}`
      : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function (route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2),
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2),
  });
}
var request = withDefaults2(endpoint, defaults_default);

// node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION3 = '0.0.0-development';
function _buildMessageForResponseErrors(data) {
  return (
    `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join('\n')
  );
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  name = 'GraphqlResponseError';
  errors;
  data;
};
var NON_VARIABLE_OPTIONS = ['method', 'baseUrl', 'url', 'headers', 'request', 'query', 'mediaType', 'operationName'];
var FORBIDDEN_VARIABLE_OPTIONS = ['query', 'method', 'url'];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options2) {
  if (options2) {
    if (typeof query === 'string' && 'query' in options2) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }
    for (const key in options2) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
      return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
    }
  }
  const parsedOptions = typeof query === 'string' ? Object.assign({ query }, options2) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, '/api/graphql');
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(requestOptions, headers, response.data);
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options2) => {
    return graphql(newRequest, query, options2);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint,
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    'user-agent': `octokit-graphql.js/${VERSION3} ${getUserAgent()}`,
  },
  method: 'POST',
  url: '/graphql',
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: 'POST',
    url: '/graphql',
  });
}

// node_modules/@octokit/auth-token/dist-bundle/index.js
var b64url = '(?:[a-zA-Z0-9_-]+)';
var sep = '\\.';
var jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);
var isJWT = jwtRE.test.bind(jwtRE);
async function auth(token) {
  const isApp = isJWT(token);
  const isInstallation = token.startsWith('v1.') || token.startsWith('ghs_');
  const isUserToServer = token.startsWith('ghu_');
  const tokenType = isApp ? 'app' : isInstallation ? 'installation' : isUserToServer ? 'user-to-server' : 'oauth';
  return {
    type: 'token',
    token,
    tokenType,
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(route, parameters);
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error('[@octokit/auth-token] No token passed to createTokenAuth');
  }
  if (typeof token !== 'string') {
    throw new Error('[@octokit/auth-token] Token passed to createTokenAuth is not a string');
  }
  token = token.replace(/^(token|bearer) +/i, '');
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token),
  });
};

// node_modules/@octokit/core/dist-src/version.js
var VERSION4 = '6.1.4';

// node_modules/@octokit/core/dist-src/index.js
var noop = () => {};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
var Octokit = class {
  static VERSION = VERSION4;
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options2 = args[0] || {};
        if (typeof defaults === 'function') {
          super(defaults(options2));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options2,
            options2.userAgent && defaults.userAgent
              ? {
                  userAgent: `${options2.userAgent} ${defaults.userAgent}`,
                }
              : null,
          ),
        );
      }
    };
    return OctokitWithDefaults;
  }
  static plugins = [];
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    const currentPlugins = this.plugins;
    const NewOctokit = class extends this {
      static plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
    };
    return NewOctokit;
  }
  constructor(options2 = {}) {
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options2.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, 'request'),
      }),
      mediaType: {
        previews: [],
        format: '',
      },
    };
    requestDefaults.headers['user-agent'] = options2.userAgent
      ? `${options2.userAgent} ${userAgentTrail}`
      : userAgentTrail;
    if (options2.baseUrl) {
      requestDefaults.baseUrl = options2.baseUrl;
    }
    if (options2.previews) {
      requestDefaults.mediaType.previews = options2.previews;
    }
    if (options2.timeZone) {
      requestDefaults.headers['time-zone'] = options2.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError,
      },
      options2.log,
    );
    this.hook = hook2;
    if (!options2.authStrategy) {
      if (!options2.auth) {
        this.auth = async () => ({
          type: 'unauthenticated',
        });
      } else {
        const auth2 = createTokenAuth(options2.auth);
        hook2.wrap('request', auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options2;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions,
          },
          options2.auth,
        ),
      );
      hook2.wrap('request', auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options2));
    }
  }
  // assigned during constructor
  request;
  graphql;
  log;
  hook;
  // TODO: type `octokit.auth` based on passed options.authStrategy
  auth;
};

// node_modules/@octokit/plugin-request-log/dist-src/version.js
var VERSION5 = '5.3.1';

// node_modules/@octokit/plugin-request-log/dist-src/index.js
function requestLog(octokit2) {
  octokit2.hook.wrap('request', (request2, options2) => {
    octokit2.log.debug('request', options2);
    const start = Date.now();
    const requestOptions = octokit2.request.endpoint.parse(options2);
    const path = requestOptions.url.replace(options2.baseUrl, '');
    return request2(options2)
      .then((response) => {
        const requestId = response.headers['x-github-request-id'];
        octokit2.log.info(
          `${requestOptions.method} ${path} - ${response.status} with id ${requestId} in ${Date.now() - start}ms`,
        );
        return response;
      })
      .catch((error) => {
        const requestId = error.response?.headers['x-github-request-id'] || 'UNKNOWN';
        octokit2.log.error(
          `${requestOptions.method} ${path} - ${error.status} with id ${requestId} in ${Date.now() - start}ms`,
        );
        throw error;
      });
  });
}
requestLog.VERSION = VERSION5;

// node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js
var VERSION6 = '0.0.0-development';
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: [],
    };
  }
  const responseNeedsNormalization = 'total_count' in response.data && !('url' in response.data);
  if (!responseNeedsNormalization) return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;
  if (typeof incompleteResults !== 'undefined') {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== 'undefined') {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  return response;
}
function iterator(octokit2, route, parameters) {
  const options2 =
    typeof route === 'function' ? route.endpoint(parameters) : octokit2.request.endpoint(route, parameters);
  const requestMethod = typeof route === 'function' ? route : octokit2.request;
  const method = options2.method;
  const headers = options2.headers;
  let url = options2.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url) return { done: true };
        try {
          const response = await requestMethod({ method, url, headers });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url = ((normalizedResponse.headers.link || '').match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
          return { value: normalizedResponse };
        } catch (error) {
          if (error.status !== 409) throw error;
          url = '';
          return {
            value: {
              status: 200,
              headers: {},
              data: [],
            },
          };
        }
      },
    }),
  };
}
function paginate(octokit2, route, parameters, mapFn) {
  if (typeof parameters === 'function') {
    mapFn = parameters;
    parameters = void 0;
  }
  return gather(octokit2, [], iterator(octokit2, route, parameters)[Symbol.asyncIterator](), mapFn);
}
function gather(octokit2, results, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
    if (earlyExit) {
      return results;
    }
    return gather(octokit2, results, iterator2, mapFn);
  });
}
var composePaginateRest = Object.assign(paginate, {
  iterator,
});
function paginateRest(octokit2) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit2), {
      iterator: iterator.bind(null, octokit2),
    }),
  };
}
paginateRest.VERSION = VERSION6;

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js
var VERSION7 = '13.5.0';

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js
var Endpoints = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: ['POST /orgs/{org}/actions/runners/{runner_id}/labels'],
    addCustomLabelsToSelfHostedRunnerForRepo: ['POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels'],
    addRepoAccessToSelfHostedRunnerGroupInOrg: [
      'PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}',
    ],
    addSelectedRepoToOrgSecret: ['PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}'],
    addSelectedRepoToOrgVariable: ['PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}'],
    approveWorkflowRun: ['POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve'],
    cancelWorkflowRun: ['POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel'],
    createEnvironmentVariable: ['POST /repos/{owner}/{repo}/environments/{environment_name}/variables'],
    createHostedRunnerForOrg: ['POST /orgs/{org}/actions/hosted-runners'],
    createOrUpdateEnvironmentSecret: [
      'PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}',
    ],
    createOrUpdateOrgSecret: ['PUT /orgs/{org}/actions/secrets/{secret_name}'],
    createOrUpdateRepoSecret: ['PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}'],
    createOrgVariable: ['POST /orgs/{org}/actions/variables'],
    createRegistrationTokenForOrg: ['POST /orgs/{org}/actions/runners/registration-token'],
    createRegistrationTokenForRepo: ['POST /repos/{owner}/{repo}/actions/runners/registration-token'],
    createRemoveTokenForOrg: ['POST /orgs/{org}/actions/runners/remove-token'],
    createRemoveTokenForRepo: ['POST /repos/{owner}/{repo}/actions/runners/remove-token'],
    createRepoVariable: ['POST /repos/{owner}/{repo}/actions/variables'],
    createWorkflowDispatch: ['POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches'],
    deleteActionsCacheById: ['DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}'],
    deleteActionsCacheByKey: ['DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}'],
    deleteArtifact: ['DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}'],
    deleteEnvironmentSecret: ['DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}'],
    deleteEnvironmentVariable: ['DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}'],
    deleteHostedRunnerForOrg: ['DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}'],
    deleteOrgSecret: ['DELETE /orgs/{org}/actions/secrets/{secret_name}'],
    deleteOrgVariable: ['DELETE /orgs/{org}/actions/variables/{name}'],
    deleteRepoSecret: ['DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}'],
    deleteRepoVariable: ['DELETE /repos/{owner}/{repo}/actions/variables/{name}'],
    deleteSelfHostedRunnerFromOrg: ['DELETE /orgs/{org}/actions/runners/{runner_id}'],
    deleteSelfHostedRunnerFromRepo: ['DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}'],
    deleteWorkflowRun: ['DELETE /repos/{owner}/{repo}/actions/runs/{run_id}'],
    deleteWorkflowRunLogs: ['DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs'],
    disableSelectedRepositoryGithubActionsOrganization: [
      'DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}',
    ],
    disableWorkflow: ['PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable'],
    downloadArtifact: ['GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}'],
    downloadJobLogsForWorkflowRun: ['GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs'],
    downloadWorkflowRunAttemptLogs: ['GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs'],
    downloadWorkflowRunLogs: ['GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs'],
    enableSelectedRepositoryGithubActionsOrganization: [
      'PUT /orgs/{org}/actions/permissions/repositories/{repository_id}',
    ],
    enableWorkflow: ['PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable'],
    forceCancelWorkflowRun: ['POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel'],
    generateRunnerJitconfigForOrg: ['POST /orgs/{org}/actions/runners/generate-jitconfig'],
    generateRunnerJitconfigForRepo: ['POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig'],
    getActionsCacheList: ['GET /repos/{owner}/{repo}/actions/caches'],
    getActionsCacheUsage: ['GET /repos/{owner}/{repo}/actions/cache/usage'],
    getActionsCacheUsageByRepoForOrg: ['GET /orgs/{org}/actions/cache/usage-by-repository'],
    getActionsCacheUsageForOrg: ['GET /orgs/{org}/actions/cache/usage'],
    getAllowedActionsOrganization: ['GET /orgs/{org}/actions/permissions/selected-actions'],
    getAllowedActionsRepository: ['GET /repos/{owner}/{repo}/actions/permissions/selected-actions'],
    getArtifact: ['GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}'],
    getCustomOidcSubClaimForRepo: ['GET /repos/{owner}/{repo}/actions/oidc/customization/sub'],
    getEnvironmentPublicKey: ['GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key'],
    getEnvironmentSecret: ['GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}'],
    getEnvironmentVariable: ['GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}'],
    getGithubActionsDefaultWorkflowPermissionsOrganization: ['GET /orgs/{org}/actions/permissions/workflow'],
    getGithubActionsDefaultWorkflowPermissionsRepository: ['GET /repos/{owner}/{repo}/actions/permissions/workflow'],
    getGithubActionsPermissionsOrganization: ['GET /orgs/{org}/actions/permissions'],
    getGithubActionsPermissionsRepository: ['GET /repos/{owner}/{repo}/actions/permissions'],
    getHostedRunnerForOrg: ['GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}'],
    getHostedRunnersGithubOwnedImagesForOrg: ['GET /orgs/{org}/actions/hosted-runners/images/github-owned'],
    getHostedRunnersLimitsForOrg: ['GET /orgs/{org}/actions/hosted-runners/limits'],
    getHostedRunnersMachineSpecsForOrg: ['GET /orgs/{org}/actions/hosted-runners/machine-sizes'],
    getHostedRunnersPartnerImagesForOrg: ['GET /orgs/{org}/actions/hosted-runners/images/partner'],
    getHostedRunnersPlatformsForOrg: ['GET /orgs/{org}/actions/hosted-runners/platforms'],
    getJobForWorkflowRun: ['GET /repos/{owner}/{repo}/actions/jobs/{job_id}'],
    getOrgPublicKey: ['GET /orgs/{org}/actions/secrets/public-key'],
    getOrgSecret: ['GET /orgs/{org}/actions/secrets/{secret_name}'],
    getOrgVariable: ['GET /orgs/{org}/actions/variables/{name}'],
    getPendingDeploymentsForRun: ['GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments'],
    getRepoPermissions: [
      'GET /repos/{owner}/{repo}/actions/permissions',
      {},
      { renamed: ['actions', 'getGithubActionsPermissionsRepository'] },
    ],
    getRepoPublicKey: ['GET /repos/{owner}/{repo}/actions/secrets/public-key'],
    getRepoSecret: ['GET /repos/{owner}/{repo}/actions/secrets/{secret_name}'],
    getRepoVariable: ['GET /repos/{owner}/{repo}/actions/variables/{name}'],
    getReviewsForRun: ['GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals'],
    getSelfHostedRunnerForOrg: ['GET /orgs/{org}/actions/runners/{runner_id}'],
    getSelfHostedRunnerForRepo: ['GET /repos/{owner}/{repo}/actions/runners/{runner_id}'],
    getWorkflow: ['GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}'],
    getWorkflowAccessToRepository: ['GET /repos/{owner}/{repo}/actions/permissions/access'],
    getWorkflowRun: ['GET /repos/{owner}/{repo}/actions/runs/{run_id}'],
    getWorkflowRunAttempt: ['GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}'],
    getWorkflowRunUsage: ['GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing'],
    getWorkflowUsage: ['GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing'],
    listArtifactsForRepo: ['GET /repos/{owner}/{repo}/actions/artifacts'],
    listEnvironmentSecrets: ['GET /repos/{owner}/{repo}/environments/{environment_name}/secrets'],
    listEnvironmentVariables: ['GET /repos/{owner}/{repo}/environments/{environment_name}/variables'],
    listGithubHostedRunnersInGroupForOrg: ['GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners'],
    listHostedRunnersForOrg: ['GET /orgs/{org}/actions/hosted-runners'],
    listJobsForWorkflowRun: ['GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs'],
    listJobsForWorkflowRunAttempt: ['GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs'],
    listLabelsForSelfHostedRunnerForOrg: ['GET /orgs/{org}/actions/runners/{runner_id}/labels'],
    listLabelsForSelfHostedRunnerForRepo: ['GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels'],
    listOrgSecrets: ['GET /orgs/{org}/actions/secrets'],
    listOrgVariables: ['GET /orgs/{org}/actions/variables'],
    listRepoOrganizationSecrets: ['GET /repos/{owner}/{repo}/actions/organization-secrets'],
    listRepoOrganizationVariables: ['GET /repos/{owner}/{repo}/actions/organization-variables'],
    listRepoSecrets: ['GET /repos/{owner}/{repo}/actions/secrets'],
    listRepoVariables: ['GET /repos/{owner}/{repo}/actions/variables'],
    listRepoWorkflows: ['GET /repos/{owner}/{repo}/actions/workflows'],
    listRunnerApplicationsForOrg: ['GET /orgs/{org}/actions/runners/downloads'],
    listRunnerApplicationsForRepo: ['GET /repos/{owner}/{repo}/actions/runners/downloads'],
    listSelectedReposForOrgSecret: ['GET /orgs/{org}/actions/secrets/{secret_name}/repositories'],
    listSelectedReposForOrgVariable: ['GET /orgs/{org}/actions/variables/{name}/repositories'],
    listSelectedRepositoriesEnabledGithubActionsOrganization: ['GET /orgs/{org}/actions/permissions/repositories'],
    listSelfHostedRunnersForOrg: ['GET /orgs/{org}/actions/runners'],
    listSelfHostedRunnersForRepo: ['GET /repos/{owner}/{repo}/actions/runners'],
    listWorkflowRunArtifacts: ['GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts'],
    listWorkflowRuns: ['GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs'],
    listWorkflowRunsForRepo: ['GET /repos/{owner}/{repo}/actions/runs'],
    reRunJobForWorkflowRun: ['POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun'],
    reRunWorkflow: ['POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun'],
    reRunWorkflowFailedJobs: ['POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs'],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: ['DELETE /orgs/{org}/actions/runners/{runner_id}/labels'],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      'DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels',
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: ['DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}'],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      'DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}',
    ],
    removeSelectedRepoFromOrgSecret: ['DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}'],
    removeSelectedRepoFromOrgVariable: ['DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}'],
    reviewCustomGatesForRun: ['POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule'],
    reviewPendingDeploymentsForRun: ['POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments'],
    setAllowedActionsOrganization: ['PUT /orgs/{org}/actions/permissions/selected-actions'],
    setAllowedActionsRepository: ['PUT /repos/{owner}/{repo}/actions/permissions/selected-actions'],
    setCustomLabelsForSelfHostedRunnerForOrg: ['PUT /orgs/{org}/actions/runners/{runner_id}/labels'],
    setCustomLabelsForSelfHostedRunnerForRepo: ['PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels'],
    setCustomOidcSubClaimForRepo: ['PUT /repos/{owner}/{repo}/actions/oidc/customization/sub'],
    setGithubActionsDefaultWorkflowPermissionsOrganization: ['PUT /orgs/{org}/actions/permissions/workflow'],
    setGithubActionsDefaultWorkflowPermissionsRepository: ['PUT /repos/{owner}/{repo}/actions/permissions/workflow'],
    setGithubActionsPermissionsOrganization: ['PUT /orgs/{org}/actions/permissions'],
    setGithubActionsPermissionsRepository: ['PUT /repos/{owner}/{repo}/actions/permissions'],
    setSelectedReposForOrgSecret: ['PUT /orgs/{org}/actions/secrets/{secret_name}/repositories'],
    setSelectedReposForOrgVariable: ['PUT /orgs/{org}/actions/variables/{name}/repositories'],
    setSelectedRepositoriesEnabledGithubActionsOrganization: ['PUT /orgs/{org}/actions/permissions/repositories'],
    setWorkflowAccessToRepository: ['PUT /repos/{owner}/{repo}/actions/permissions/access'],
    updateEnvironmentVariable: ['PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}'],
    updateHostedRunnerForOrg: ['PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}'],
    updateOrgVariable: ['PATCH /orgs/{org}/actions/variables/{name}'],
    updateRepoVariable: ['PATCH /repos/{owner}/{repo}/actions/variables/{name}'],
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ['GET /user/starred/{owner}/{repo}'],
    deleteRepoSubscription: ['DELETE /repos/{owner}/{repo}/subscription'],
    deleteThreadSubscription: ['DELETE /notifications/threads/{thread_id}/subscription'],
    getFeeds: ['GET /feeds'],
    getRepoSubscription: ['GET /repos/{owner}/{repo}/subscription'],
    getThread: ['GET /notifications/threads/{thread_id}'],
    getThreadSubscriptionForAuthenticatedUser: ['GET /notifications/threads/{thread_id}/subscription'],
    listEventsForAuthenticatedUser: ['GET /users/{username}/events'],
    listNotificationsForAuthenticatedUser: ['GET /notifications'],
    listOrgEventsForAuthenticatedUser: ['GET /users/{username}/events/orgs/{org}'],
    listPublicEvents: ['GET /events'],
    listPublicEventsForRepoNetwork: ['GET /networks/{owner}/{repo}/events'],
    listPublicEventsForUser: ['GET /users/{username}/events/public'],
    listPublicOrgEvents: ['GET /orgs/{org}/events'],
    listReceivedEventsForUser: ['GET /users/{username}/received_events'],
    listReceivedPublicEventsForUser: ['GET /users/{username}/received_events/public'],
    listRepoEvents: ['GET /repos/{owner}/{repo}/events'],
    listRepoNotificationsForAuthenticatedUser: ['GET /repos/{owner}/{repo}/notifications'],
    listReposStarredByAuthenticatedUser: ['GET /user/starred'],
    listReposStarredByUser: ['GET /users/{username}/starred'],
    listReposWatchedByUser: ['GET /users/{username}/subscriptions'],
    listStargazersForRepo: ['GET /repos/{owner}/{repo}/stargazers'],
    listWatchedReposForAuthenticatedUser: ['GET /user/subscriptions'],
    listWatchersForRepo: ['GET /repos/{owner}/{repo}/subscribers'],
    markNotificationsAsRead: ['PUT /notifications'],
    markRepoNotificationsAsRead: ['PUT /repos/{owner}/{repo}/notifications'],
    markThreadAsDone: ['DELETE /notifications/threads/{thread_id}'],
    markThreadAsRead: ['PATCH /notifications/threads/{thread_id}'],
    setRepoSubscription: ['PUT /repos/{owner}/{repo}/subscription'],
    setThreadSubscription: ['PUT /notifications/threads/{thread_id}/subscription'],
    starRepoForAuthenticatedUser: ['PUT /user/starred/{owner}/{repo}'],
    unstarRepoForAuthenticatedUser: ['DELETE /user/starred/{owner}/{repo}'],
  },
  apps: {
    addRepoToInstallation: [
      'PUT /user/installations/{installation_id}/repositories/{repository_id}',
      {},
      { renamed: ['apps', 'addRepoToInstallationForAuthenticatedUser'] },
    ],
    addRepoToInstallationForAuthenticatedUser: [
      'PUT /user/installations/{installation_id}/repositories/{repository_id}',
    ],
    checkToken: ['POST /applications/{client_id}/token'],
    createFromManifest: ['POST /app-manifests/{code}/conversions'],
    createInstallationAccessToken: ['POST /app/installations/{installation_id}/access_tokens'],
    deleteAuthorization: ['DELETE /applications/{client_id}/grant'],
    deleteInstallation: ['DELETE /app/installations/{installation_id}'],
    deleteToken: ['DELETE /applications/{client_id}/token'],
    getAuthenticated: ['GET /app'],
    getBySlug: ['GET /apps/{app_slug}'],
    getInstallation: ['GET /app/installations/{installation_id}'],
    getOrgInstallation: ['GET /orgs/{org}/installation'],
    getRepoInstallation: ['GET /repos/{owner}/{repo}/installation'],
    getSubscriptionPlanForAccount: ['GET /marketplace_listing/accounts/{account_id}'],
    getSubscriptionPlanForAccountStubbed: ['GET /marketplace_listing/stubbed/accounts/{account_id}'],
    getUserInstallation: ['GET /users/{username}/installation'],
    getWebhookConfigForApp: ['GET /app/hook/config'],
    getWebhookDelivery: ['GET /app/hook/deliveries/{delivery_id}'],
    listAccountsForPlan: ['GET /marketplace_listing/plans/{plan_id}/accounts'],
    listAccountsForPlanStubbed: ['GET /marketplace_listing/stubbed/plans/{plan_id}/accounts'],
    listInstallationReposForAuthenticatedUser: ['GET /user/installations/{installation_id}/repositories'],
    listInstallationRequestsForAuthenticatedApp: ['GET /app/installation-requests'],
    listInstallations: ['GET /app/installations'],
    listInstallationsForAuthenticatedUser: ['GET /user/installations'],
    listPlans: ['GET /marketplace_listing/plans'],
    listPlansStubbed: ['GET /marketplace_listing/stubbed/plans'],
    listReposAccessibleToInstallation: ['GET /installation/repositories'],
    listSubscriptionsForAuthenticatedUser: ['GET /user/marketplace_purchases'],
    listSubscriptionsForAuthenticatedUserStubbed: ['GET /user/marketplace_purchases/stubbed'],
    listWebhookDeliveries: ['GET /app/hook/deliveries'],
    redeliverWebhookDelivery: ['POST /app/hook/deliveries/{delivery_id}/attempts'],
    removeRepoFromInstallation: [
      'DELETE /user/installations/{installation_id}/repositories/{repository_id}',
      {},
      { renamed: ['apps', 'removeRepoFromInstallationForAuthenticatedUser'] },
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      'DELETE /user/installations/{installation_id}/repositories/{repository_id}',
    ],
    resetToken: ['PATCH /applications/{client_id}/token'],
    revokeInstallationAccessToken: ['DELETE /installation/token'],
    scopeToken: ['POST /applications/{client_id}/token/scoped'],
    suspendInstallation: ['PUT /app/installations/{installation_id}/suspended'],
    unsuspendInstallation: ['DELETE /app/installations/{installation_id}/suspended'],
    updateWebhookConfigForApp: ['PATCH /app/hook/config'],
  },
  billing: {
    getGithubActionsBillingOrg: ['GET /orgs/{org}/settings/billing/actions'],
    getGithubActionsBillingUser: ['GET /users/{username}/settings/billing/actions'],
    getGithubBillingUsageReportOrg: ['GET /organizations/{org}/settings/billing/usage'],
    getGithubPackagesBillingOrg: ['GET /orgs/{org}/settings/billing/packages'],
    getGithubPackagesBillingUser: ['GET /users/{username}/settings/billing/packages'],
    getSharedStorageBillingOrg: ['GET /orgs/{org}/settings/billing/shared-storage'],
    getSharedStorageBillingUser: ['GET /users/{username}/settings/billing/shared-storage'],
  },
  checks: {
    create: ['POST /repos/{owner}/{repo}/check-runs'],
    createSuite: ['POST /repos/{owner}/{repo}/check-suites'],
    get: ['GET /repos/{owner}/{repo}/check-runs/{check_run_id}'],
    getSuite: ['GET /repos/{owner}/{repo}/check-suites/{check_suite_id}'],
    listAnnotations: ['GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations'],
    listForRef: ['GET /repos/{owner}/{repo}/commits/{ref}/check-runs'],
    listForSuite: ['GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs'],
    listSuitesForRef: ['GET /repos/{owner}/{repo}/commits/{ref}/check-suites'],
    rerequestRun: ['POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest'],
    rerequestSuite: ['POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest'],
    setSuitesPreferences: ['PATCH /repos/{owner}/{repo}/check-suites/preferences'],
    update: ['PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}'],
  },
  codeScanning: {
    commitAutofix: ['POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits'],
    createAutofix: ['POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix'],
    createVariantAnalysis: ['POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses'],
    deleteAnalysis: ['DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}'],
    deleteCodeqlDatabase: ['DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}'],
    getAlert: [
      'GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}',
      {},
      { renamedParameters: { alert_id: 'alert_number' } },
    ],
    getAnalysis: ['GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}'],
    getAutofix: ['GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix'],
    getCodeqlDatabase: ['GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}'],
    getDefaultSetup: ['GET /repos/{owner}/{repo}/code-scanning/default-setup'],
    getSarif: ['GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}'],
    getVariantAnalysis: [
      'GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}',
    ],
    getVariantAnalysisRepoTask: [
      'GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}',
    ],
    listAlertInstances: ['GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances'],
    listAlertsForOrg: ['GET /orgs/{org}/code-scanning/alerts'],
    listAlertsForRepo: ['GET /repos/{owner}/{repo}/code-scanning/alerts'],
    listAlertsInstances: [
      'GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances',
      {},
      { renamed: ['codeScanning', 'listAlertInstances'] },
    ],
    listCodeqlDatabases: ['GET /repos/{owner}/{repo}/code-scanning/codeql/databases'],
    listRecentAnalyses: ['GET /repos/{owner}/{repo}/code-scanning/analyses'],
    updateAlert: ['PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}'],
    updateDefaultSetup: ['PATCH /repos/{owner}/{repo}/code-scanning/default-setup'],
    uploadSarif: ['POST /repos/{owner}/{repo}/code-scanning/sarifs'],
  },
  codeSecurity: {
    attachConfiguration: ['POST /orgs/{org}/code-security/configurations/{configuration_id}/attach'],
    attachEnterpriseConfiguration: [
      'POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach',
    ],
    createConfiguration: ['POST /orgs/{org}/code-security/configurations'],
    createConfigurationForEnterprise: ['POST /enterprises/{enterprise}/code-security/configurations'],
    deleteConfiguration: ['DELETE /orgs/{org}/code-security/configurations/{configuration_id}'],
    deleteConfigurationForEnterprise: [
      'DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}',
    ],
    detachConfiguration: ['DELETE /orgs/{org}/code-security/configurations/detach'],
    getConfiguration: ['GET /orgs/{org}/code-security/configurations/{configuration_id}'],
    getConfigurationForRepository: ['GET /repos/{owner}/{repo}/code-security-configuration'],
    getConfigurationsForEnterprise: ['GET /enterprises/{enterprise}/code-security/configurations'],
    getConfigurationsForOrg: ['GET /orgs/{org}/code-security/configurations'],
    getDefaultConfigurations: ['GET /orgs/{org}/code-security/configurations/defaults'],
    getDefaultConfigurationsForEnterprise: ['GET /enterprises/{enterprise}/code-security/configurations/defaults'],
    getRepositoriesForConfiguration: ['GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories'],
    getRepositoriesForEnterpriseConfiguration: [
      'GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories',
    ],
    getSingleConfigurationForEnterprise: [
      'GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}',
    ],
    setConfigurationAsDefault: ['PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults'],
    setConfigurationAsDefaultForEnterprise: [
      'PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults',
    ],
    updateConfiguration: ['PATCH /orgs/{org}/code-security/configurations/{configuration_id}'],
    updateEnterpriseConfiguration: ['PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}'],
  },
  codesOfConduct: {
    getAllCodesOfConduct: ['GET /codes_of_conduct'],
    getConductCode: ['GET /codes_of_conduct/{key}'],
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      'PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}',
    ],
    addSelectedRepoToOrgSecret: ['PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}'],
    checkPermissionsForDevcontainer: ['GET /repos/{owner}/{repo}/codespaces/permissions_check'],
    codespaceMachinesForAuthenticatedUser: ['GET /user/codespaces/{codespace_name}/machines'],
    createForAuthenticatedUser: ['POST /user/codespaces'],
    createOrUpdateOrgSecret: ['PUT /orgs/{org}/codespaces/secrets/{secret_name}'],
    createOrUpdateRepoSecret: ['PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}'],
    createOrUpdateSecretForAuthenticatedUser: ['PUT /user/codespaces/secrets/{secret_name}'],
    createWithPrForAuthenticatedUser: ['POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces'],
    createWithRepoForAuthenticatedUser: ['POST /repos/{owner}/{repo}/codespaces'],
    deleteForAuthenticatedUser: ['DELETE /user/codespaces/{codespace_name}'],
    deleteFromOrganization: ['DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}'],
    deleteOrgSecret: ['DELETE /orgs/{org}/codespaces/secrets/{secret_name}'],
    deleteRepoSecret: ['DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}'],
    deleteSecretForAuthenticatedUser: ['DELETE /user/codespaces/secrets/{secret_name}'],
    exportForAuthenticatedUser: ['POST /user/codespaces/{codespace_name}/exports'],
    getCodespacesForUserInOrg: ['GET /orgs/{org}/members/{username}/codespaces'],
    getExportDetailsForAuthenticatedUser: ['GET /user/codespaces/{codespace_name}/exports/{export_id}'],
    getForAuthenticatedUser: ['GET /user/codespaces/{codespace_name}'],
    getOrgPublicKey: ['GET /orgs/{org}/codespaces/secrets/public-key'],
    getOrgSecret: ['GET /orgs/{org}/codespaces/secrets/{secret_name}'],
    getPublicKeyForAuthenticatedUser: ['GET /user/codespaces/secrets/public-key'],
    getRepoPublicKey: ['GET /repos/{owner}/{repo}/codespaces/secrets/public-key'],
    getRepoSecret: ['GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}'],
    getSecretForAuthenticatedUser: ['GET /user/codespaces/secrets/{secret_name}'],
    listDevcontainersInRepositoryForAuthenticatedUser: ['GET /repos/{owner}/{repo}/codespaces/devcontainers'],
    listForAuthenticatedUser: ['GET /user/codespaces'],
    listInOrganization: ['GET /orgs/{org}/codespaces', {}, { renamedParameters: { org_id: 'org' } }],
    listInRepositoryForAuthenticatedUser: ['GET /repos/{owner}/{repo}/codespaces'],
    listOrgSecrets: ['GET /orgs/{org}/codespaces/secrets'],
    listRepoSecrets: ['GET /repos/{owner}/{repo}/codespaces/secrets'],
    listRepositoriesForSecretForAuthenticatedUser: ['GET /user/codespaces/secrets/{secret_name}/repositories'],
    listSecretsForAuthenticatedUser: ['GET /user/codespaces/secrets'],
    listSelectedReposForOrgSecret: ['GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories'],
    preFlightWithRepoForAuthenticatedUser: ['GET /repos/{owner}/{repo}/codespaces/new'],
    publishForAuthenticatedUser: ['POST /user/codespaces/{codespace_name}/publish'],
    removeRepositoryForSecretForAuthenticatedUser: [
      'DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}',
    ],
    removeSelectedRepoFromOrgSecret: [
      'DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}',
    ],
    repoMachinesForAuthenticatedUser: ['GET /repos/{owner}/{repo}/codespaces/machines'],
    setRepositoriesForSecretForAuthenticatedUser: ['PUT /user/codespaces/secrets/{secret_name}/repositories'],
    setSelectedReposForOrgSecret: ['PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories'],
    startForAuthenticatedUser: ['POST /user/codespaces/{codespace_name}/start'],
    stopForAuthenticatedUser: ['POST /user/codespaces/{codespace_name}/stop'],
    stopInOrganization: ['POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop'],
    updateForAuthenticatedUser: ['PATCH /user/codespaces/{codespace_name}'],
  },
  copilot: {
    addCopilotSeatsForTeams: ['POST /orgs/{org}/copilot/billing/selected_teams'],
    addCopilotSeatsForUsers: ['POST /orgs/{org}/copilot/billing/selected_users'],
    cancelCopilotSeatAssignmentForTeams: ['DELETE /orgs/{org}/copilot/billing/selected_teams'],
    cancelCopilotSeatAssignmentForUsers: ['DELETE /orgs/{org}/copilot/billing/selected_users'],
    copilotMetricsForOrganization: ['GET /orgs/{org}/copilot/metrics'],
    copilotMetricsForTeam: ['GET /orgs/{org}/team/{team_slug}/copilot/metrics'],
    getCopilotOrganizationDetails: ['GET /orgs/{org}/copilot/billing'],
    getCopilotSeatDetailsForUser: ['GET /orgs/{org}/members/{username}/copilot'],
    listCopilotSeats: ['GET /orgs/{org}/copilot/billing/seats'],
    usageMetricsForOrg: ['GET /orgs/{org}/copilot/usage'],
    usageMetricsForTeam: ['GET /orgs/{org}/team/{team_slug}/copilot/usage'],
  },
  dependabot: {
    addSelectedRepoToOrgSecret: ['PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}'],
    createOrUpdateOrgSecret: ['PUT /orgs/{org}/dependabot/secrets/{secret_name}'],
    createOrUpdateRepoSecret: ['PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}'],
    deleteOrgSecret: ['DELETE /orgs/{org}/dependabot/secrets/{secret_name}'],
    deleteRepoSecret: ['DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}'],
    getAlert: ['GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}'],
    getOrgPublicKey: ['GET /orgs/{org}/dependabot/secrets/public-key'],
    getOrgSecret: ['GET /orgs/{org}/dependabot/secrets/{secret_name}'],
    getRepoPublicKey: ['GET /repos/{owner}/{repo}/dependabot/secrets/public-key'],
    getRepoSecret: ['GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}'],
    listAlertsForEnterprise: ['GET /enterprises/{enterprise}/dependabot/alerts'],
    listAlertsForOrg: ['GET /orgs/{org}/dependabot/alerts'],
    listAlertsForRepo: ['GET /repos/{owner}/{repo}/dependabot/alerts'],
    listOrgSecrets: ['GET /orgs/{org}/dependabot/secrets'],
    listRepoSecrets: ['GET /repos/{owner}/{repo}/dependabot/secrets'],
    listSelectedReposForOrgSecret: ['GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories'],
    removeSelectedRepoFromOrgSecret: [
      'DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}',
    ],
    setSelectedReposForOrgSecret: ['PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories'],
    updateAlert: ['PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}'],
  },
  dependencyGraph: {
    createRepositorySnapshot: ['POST /repos/{owner}/{repo}/dependency-graph/snapshots'],
    diffRange: ['GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}'],
    exportSbom: ['GET /repos/{owner}/{repo}/dependency-graph/sbom'],
  },
  emojis: { get: ['GET /emojis'] },
  gists: {
    checkIsStarred: ['GET /gists/{gist_id}/star'],
    create: ['POST /gists'],
    createComment: ['POST /gists/{gist_id}/comments'],
    delete: ['DELETE /gists/{gist_id}'],
    deleteComment: ['DELETE /gists/{gist_id}/comments/{comment_id}'],
    fork: ['POST /gists/{gist_id}/forks'],
    get: ['GET /gists/{gist_id}'],
    getComment: ['GET /gists/{gist_id}/comments/{comment_id}'],
    getRevision: ['GET /gists/{gist_id}/{sha}'],
    list: ['GET /gists'],
    listComments: ['GET /gists/{gist_id}/comments'],
    listCommits: ['GET /gists/{gist_id}/commits'],
    listForUser: ['GET /users/{username}/gists'],
    listForks: ['GET /gists/{gist_id}/forks'],
    listPublic: ['GET /gists/public'],
    listStarred: ['GET /gists/starred'],
    star: ['PUT /gists/{gist_id}/star'],
    unstar: ['DELETE /gists/{gist_id}/star'],
    update: ['PATCH /gists/{gist_id}'],
    updateComment: ['PATCH /gists/{gist_id}/comments/{comment_id}'],
  },
  git: {
    createBlob: ['POST /repos/{owner}/{repo}/git/blobs'],
    createCommit: ['POST /repos/{owner}/{repo}/git/commits'],
    createRef: ['POST /repos/{owner}/{repo}/git/refs'],
    createTag: ['POST /repos/{owner}/{repo}/git/tags'],
    createTree: ['POST /repos/{owner}/{repo}/git/trees'],
    deleteRef: ['DELETE /repos/{owner}/{repo}/git/refs/{ref}'],
    getBlob: ['GET /repos/{owner}/{repo}/git/blobs/{file_sha}'],
    getCommit: ['GET /repos/{owner}/{repo}/git/commits/{commit_sha}'],
    getRef: ['GET /repos/{owner}/{repo}/git/ref/{ref}'],
    getTag: ['GET /repos/{owner}/{repo}/git/tags/{tag_sha}'],
    getTree: ['GET /repos/{owner}/{repo}/git/trees/{tree_sha}'],
    listMatchingRefs: ['GET /repos/{owner}/{repo}/git/matching-refs/{ref}'],
    updateRef: ['PATCH /repos/{owner}/{repo}/git/refs/{ref}'],
  },
  gitignore: {
    getAllTemplates: ['GET /gitignore/templates'],
    getTemplate: ['GET /gitignore/templates/{name}'],
  },
  hostedCompute: {
    createNetworkConfigurationForOrg: ['POST /orgs/{org}/settings/network-configurations'],
    deleteNetworkConfigurationFromOrg: [
      'DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}',
    ],
    getNetworkConfigurationForOrg: ['GET /orgs/{org}/settings/network-configurations/{network_configuration_id}'],
    getNetworkSettingsForOrg: ['GET /orgs/{org}/settings/network-settings/{network_settings_id}'],
    listNetworkConfigurationsForOrg: ['GET /orgs/{org}/settings/network-configurations'],
    updateNetworkConfigurationForOrg: ['PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}'],
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ['GET /user/interaction-limits'],
    getRestrictionsForOrg: ['GET /orgs/{org}/interaction-limits'],
    getRestrictionsForRepo: ['GET /repos/{owner}/{repo}/interaction-limits'],
    getRestrictionsForYourPublicRepos: [
      'GET /user/interaction-limits',
      {},
      { renamed: ['interactions', 'getRestrictionsForAuthenticatedUser'] },
    ],
    removeRestrictionsForAuthenticatedUser: ['DELETE /user/interaction-limits'],
    removeRestrictionsForOrg: ['DELETE /orgs/{org}/interaction-limits'],
    removeRestrictionsForRepo: ['DELETE /repos/{owner}/{repo}/interaction-limits'],
    removeRestrictionsForYourPublicRepos: [
      'DELETE /user/interaction-limits',
      {},
      { renamed: ['interactions', 'removeRestrictionsForAuthenticatedUser'] },
    ],
    setRestrictionsForAuthenticatedUser: ['PUT /user/interaction-limits'],
    setRestrictionsForOrg: ['PUT /orgs/{org}/interaction-limits'],
    setRestrictionsForRepo: ['PUT /repos/{owner}/{repo}/interaction-limits'],
    setRestrictionsForYourPublicRepos: [
      'PUT /user/interaction-limits',
      {},
      { renamed: ['interactions', 'setRestrictionsForAuthenticatedUser'] },
    ],
  },
  issues: {
    addAssignees: ['POST /repos/{owner}/{repo}/issues/{issue_number}/assignees'],
    addLabels: ['POST /repos/{owner}/{repo}/issues/{issue_number}/labels'],
    addSubIssue: ['POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues'],
    checkUserCanBeAssigned: ['GET /repos/{owner}/{repo}/assignees/{assignee}'],
    checkUserCanBeAssignedToIssue: ['GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}'],
    create: ['POST /repos/{owner}/{repo}/issues'],
    createComment: ['POST /repos/{owner}/{repo}/issues/{issue_number}/comments'],
    createLabel: ['POST /repos/{owner}/{repo}/labels'],
    createMilestone: ['POST /repos/{owner}/{repo}/milestones'],
    deleteComment: ['DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}'],
    deleteLabel: ['DELETE /repos/{owner}/{repo}/labels/{name}'],
    deleteMilestone: ['DELETE /repos/{owner}/{repo}/milestones/{milestone_number}'],
    get: ['GET /repos/{owner}/{repo}/issues/{issue_number}'],
    getComment: ['GET /repos/{owner}/{repo}/issues/comments/{comment_id}'],
    getEvent: ['GET /repos/{owner}/{repo}/issues/events/{event_id}'],
    getLabel: ['GET /repos/{owner}/{repo}/labels/{name}'],
    getMilestone: ['GET /repos/{owner}/{repo}/milestones/{milestone_number}'],
    list: ['GET /issues'],
    listAssignees: ['GET /repos/{owner}/{repo}/assignees'],
    listComments: ['GET /repos/{owner}/{repo}/issues/{issue_number}/comments'],
    listCommentsForRepo: ['GET /repos/{owner}/{repo}/issues/comments'],
    listEvents: ['GET /repos/{owner}/{repo}/issues/{issue_number}/events'],
    listEventsForRepo: ['GET /repos/{owner}/{repo}/issues/events'],
    listEventsForTimeline: ['GET /repos/{owner}/{repo}/issues/{issue_number}/timeline'],
    listForAuthenticatedUser: ['GET /user/issues'],
    listForOrg: ['GET /orgs/{org}/issues'],
    listForRepo: ['GET /repos/{owner}/{repo}/issues'],
    listLabelsForMilestone: ['GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels'],
    listLabelsForRepo: ['GET /repos/{owner}/{repo}/labels'],
    listLabelsOnIssue: ['GET /repos/{owner}/{repo}/issues/{issue_number}/labels'],
    listMilestones: ['GET /repos/{owner}/{repo}/milestones'],
    listSubIssues: ['GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues'],
    lock: ['PUT /repos/{owner}/{repo}/issues/{issue_number}/lock'],
    removeAllLabels: ['DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels'],
    removeAssignees: ['DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees'],
    removeLabel: ['DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}'],
    removeSubIssue: ['DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue'],
    reprioritizeSubIssue: ['PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority'],
    setLabels: ['PUT /repos/{owner}/{repo}/issues/{issue_number}/labels'],
    unlock: ['DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock'],
    update: ['PATCH /repos/{owner}/{repo}/issues/{issue_number}'],
    updateComment: ['PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}'],
    updateLabel: ['PATCH /repos/{owner}/{repo}/labels/{name}'],
    updateMilestone: ['PATCH /repos/{owner}/{repo}/milestones/{milestone_number}'],
  },
  licenses: {
    get: ['GET /licenses/{license}'],
    getAllCommonlyUsed: ['GET /licenses'],
    getForRepo: ['GET /repos/{owner}/{repo}/license'],
  },
  markdown: {
    render: ['POST /markdown'],
    renderRaw: ['POST /markdown/raw', { headers: { 'content-type': 'text/plain; charset=utf-8' } }],
  },
  meta: {
    get: ['GET /meta'],
    getAllVersions: ['GET /versions'],
    getOctocat: ['GET /octocat'],
    getZen: ['GET /zen'],
    root: ['GET /'],
  },
  migrations: {
    deleteArchiveForAuthenticatedUser: ['DELETE /user/migrations/{migration_id}/archive'],
    deleteArchiveForOrg: ['DELETE /orgs/{org}/migrations/{migration_id}/archive'],
    downloadArchiveForOrg: ['GET /orgs/{org}/migrations/{migration_id}/archive'],
    getArchiveForAuthenticatedUser: ['GET /user/migrations/{migration_id}/archive'],
    getStatusForAuthenticatedUser: ['GET /user/migrations/{migration_id}'],
    getStatusForOrg: ['GET /orgs/{org}/migrations/{migration_id}'],
    listForAuthenticatedUser: ['GET /user/migrations'],
    listForOrg: ['GET /orgs/{org}/migrations'],
    listReposForAuthenticatedUser: ['GET /user/migrations/{migration_id}/repositories'],
    listReposForOrg: ['GET /orgs/{org}/migrations/{migration_id}/repositories'],
    listReposForUser: [
      'GET /user/migrations/{migration_id}/repositories',
      {},
      { renamed: ['migrations', 'listReposForAuthenticatedUser'] },
    ],
    startForAuthenticatedUser: ['POST /user/migrations'],
    startForOrg: ['POST /orgs/{org}/migrations'],
    unlockRepoForAuthenticatedUser: ['DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock'],
    unlockRepoForOrg: ['DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock'],
  },
  oidc: {
    getOidcCustomSubTemplateForOrg: ['GET /orgs/{org}/actions/oidc/customization/sub'],
    updateOidcCustomSubTemplateForOrg: ['PUT /orgs/{org}/actions/oidc/customization/sub'],
  },
  orgs: {
    addSecurityManagerTeam: [
      'PUT /orgs/{org}/security-managers/teams/{team_slug}',
      {},
      {
        deprecated:
          'octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team',
      },
    ],
    assignTeamToOrgRole: ['PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}'],
    assignUserToOrgRole: ['PUT /orgs/{org}/organization-roles/users/{username}/{role_id}'],
    blockUser: ['PUT /orgs/{org}/blocks/{username}'],
    cancelInvitation: ['DELETE /orgs/{org}/invitations/{invitation_id}'],
    checkBlockedUser: ['GET /orgs/{org}/blocks/{username}'],
    checkMembershipForUser: ['GET /orgs/{org}/members/{username}'],
    checkPublicMembershipForUser: ['GET /orgs/{org}/public_members/{username}'],
    convertMemberToOutsideCollaborator: ['PUT /orgs/{org}/outside_collaborators/{username}'],
    createInvitation: ['POST /orgs/{org}/invitations'],
    createIssueType: ['POST /orgs/{org}/issue-types'],
    createOrUpdateCustomProperties: ['PATCH /orgs/{org}/properties/schema'],
    createOrUpdateCustomPropertiesValuesForRepos: ['PATCH /orgs/{org}/properties/values'],
    createOrUpdateCustomProperty: ['PUT /orgs/{org}/properties/schema/{custom_property_name}'],
    createWebhook: ['POST /orgs/{org}/hooks'],
    delete: ['DELETE /orgs/{org}'],
    deleteIssueType: ['DELETE /orgs/{org}/issue-types/{issue_type_id}'],
    deleteWebhook: ['DELETE /orgs/{org}/hooks/{hook_id}'],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      'POST /orgs/{org}/{security_product}/{enablement}',
      {},
      {
        deprecated:
          'octokit.rest.orgs.enableOrDisableSecurityProductOnAllOrgRepos() is deprecated, see https://docs.github.com/rest/orgs/orgs#enable-or-disable-a-security-feature-for-an-organization',
      },
    ],
    get: ['GET /orgs/{org}'],
    getAllCustomProperties: ['GET /orgs/{org}/properties/schema'],
    getCustomProperty: ['GET /orgs/{org}/properties/schema/{custom_property_name}'],
    getMembershipForAuthenticatedUser: ['GET /user/memberships/orgs/{org}'],
    getMembershipForUser: ['GET /orgs/{org}/memberships/{username}'],
    getOrgRole: ['GET /orgs/{org}/organization-roles/{role_id}'],
    getOrgRulesetHistory: ['GET /orgs/{org}/rulesets/{ruleset_id}/history'],
    getOrgRulesetVersion: ['GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}'],
    getWebhook: ['GET /orgs/{org}/hooks/{hook_id}'],
    getWebhookConfigForOrg: ['GET /orgs/{org}/hooks/{hook_id}/config'],
    getWebhookDelivery: ['GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}'],
    list: ['GET /organizations'],
    listAppInstallations: ['GET /orgs/{org}/installations'],
    listAttestations: ['GET /orgs/{org}/attestations/{subject_digest}'],
    listBlockedUsers: ['GET /orgs/{org}/blocks'],
    listCustomPropertiesValuesForRepos: ['GET /orgs/{org}/properties/values'],
    listFailedInvitations: ['GET /orgs/{org}/failed_invitations'],
    listForAuthenticatedUser: ['GET /user/orgs'],
    listForUser: ['GET /users/{username}/orgs'],
    listInvitationTeams: ['GET /orgs/{org}/invitations/{invitation_id}/teams'],
    listIssueTypes: ['GET /orgs/{org}/issue-types'],
    listMembers: ['GET /orgs/{org}/members'],
    listMembershipsForAuthenticatedUser: ['GET /user/memberships/orgs'],
    listOrgRoleTeams: ['GET /orgs/{org}/organization-roles/{role_id}/teams'],
    listOrgRoleUsers: ['GET /orgs/{org}/organization-roles/{role_id}/users'],
    listOrgRoles: ['GET /orgs/{org}/organization-roles'],
    listOrganizationFineGrainedPermissions: ['GET /orgs/{org}/organization-fine-grained-permissions'],
    listOutsideCollaborators: ['GET /orgs/{org}/outside_collaborators'],
    listPatGrantRepositories: ['GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories'],
    listPatGrantRequestRepositories: ['GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories'],
    listPatGrantRequests: ['GET /orgs/{org}/personal-access-token-requests'],
    listPatGrants: ['GET /orgs/{org}/personal-access-tokens'],
    listPendingInvitations: ['GET /orgs/{org}/invitations'],
    listPublicMembers: ['GET /orgs/{org}/public_members'],
    listSecurityManagerTeams: [
      'GET /orgs/{org}/security-managers',
      {},
      {
        deprecated:
          'octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams',
      },
    ],
    listWebhookDeliveries: ['GET /orgs/{org}/hooks/{hook_id}/deliveries'],
    listWebhooks: ['GET /orgs/{org}/hooks'],
    pingWebhook: ['POST /orgs/{org}/hooks/{hook_id}/pings'],
    redeliverWebhookDelivery: ['POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts'],
    removeCustomProperty: ['DELETE /orgs/{org}/properties/schema/{custom_property_name}'],
    removeMember: ['DELETE /orgs/{org}/members/{username}'],
    removeMembershipForUser: ['DELETE /orgs/{org}/memberships/{username}'],
    removeOutsideCollaborator: ['DELETE /orgs/{org}/outside_collaborators/{username}'],
    removePublicMembershipForAuthenticatedUser: ['DELETE /orgs/{org}/public_members/{username}'],
    removeSecurityManagerTeam: [
      'DELETE /orgs/{org}/security-managers/teams/{team_slug}',
      {},
      {
        deprecated:
          'octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team',
      },
    ],
    reviewPatGrantRequest: ['POST /orgs/{org}/personal-access-token-requests/{pat_request_id}'],
    reviewPatGrantRequestsInBulk: ['POST /orgs/{org}/personal-access-token-requests'],
    revokeAllOrgRolesTeam: ['DELETE /orgs/{org}/organization-roles/teams/{team_slug}'],
    revokeAllOrgRolesUser: ['DELETE /orgs/{org}/organization-roles/users/{username}'],
    revokeOrgRoleTeam: ['DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}'],
    revokeOrgRoleUser: ['DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}'],
    setMembershipForUser: ['PUT /orgs/{org}/memberships/{username}'],
    setPublicMembershipForAuthenticatedUser: ['PUT /orgs/{org}/public_members/{username}'],
    unblockUser: ['DELETE /orgs/{org}/blocks/{username}'],
    update: ['PATCH /orgs/{org}'],
    updateIssueType: ['PUT /orgs/{org}/issue-types/{issue_type_id}'],
    updateMembershipForAuthenticatedUser: ['PATCH /user/memberships/orgs/{org}'],
    updatePatAccess: ['POST /orgs/{org}/personal-access-tokens/{pat_id}'],
    updatePatAccesses: ['POST /orgs/{org}/personal-access-tokens'],
    updateWebhook: ['PATCH /orgs/{org}/hooks/{hook_id}'],
    updateWebhookConfigForOrg: ['PATCH /orgs/{org}/hooks/{hook_id}/config'],
  },
  packages: {
    deletePackageForAuthenticatedUser: ['DELETE /user/packages/{package_type}/{package_name}'],
    deletePackageForOrg: ['DELETE /orgs/{org}/packages/{package_type}/{package_name}'],
    deletePackageForUser: ['DELETE /users/{username}/packages/{package_type}/{package_name}'],
    deletePackageVersionForAuthenticatedUser: [
      'DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}',
    ],
    deletePackageVersionForOrg: [
      'DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}',
    ],
    deletePackageVersionForUser: [
      'DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}',
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      'GET /orgs/{org}/packages/{package_type}/{package_name}/versions',
      {},
      { renamed: ['packages', 'getAllPackageVersionsForPackageOwnedByOrg'] },
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      'GET /user/packages/{package_type}/{package_name}/versions',
      {},
      {
        renamed: ['packages', 'getAllPackageVersionsForPackageOwnedByAuthenticatedUser'],
      },
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      'GET /user/packages/{package_type}/{package_name}/versions',
    ],
    getAllPackageVersionsForPackageOwnedByOrg: ['GET /orgs/{org}/packages/{package_type}/{package_name}/versions'],
    getAllPackageVersionsForPackageOwnedByUser: [
      'GET /users/{username}/packages/{package_type}/{package_name}/versions',
    ],
    getPackageForAuthenticatedUser: ['GET /user/packages/{package_type}/{package_name}'],
    getPackageForOrganization: ['GET /orgs/{org}/packages/{package_type}/{package_name}'],
    getPackageForUser: ['GET /users/{username}/packages/{package_type}/{package_name}'],
    getPackageVersionForAuthenticatedUser: [
      'GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}',
    ],
    getPackageVersionForOrganization: [
      'GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}',
    ],
    getPackageVersionForUser: [
      'GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}',
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: ['GET /user/docker/conflicts'],
    listDockerMigrationConflictingPackagesForOrganization: ['GET /orgs/{org}/docker/conflicts'],
    listDockerMigrationConflictingPackagesForUser: ['GET /users/{username}/docker/conflicts'],
    listPackagesForAuthenticatedUser: ['GET /user/packages'],
    listPackagesForOrganization: ['GET /orgs/{org}/packages'],
    listPackagesForUser: ['GET /users/{username}/packages'],
    restorePackageForAuthenticatedUser: ['POST /user/packages/{package_type}/{package_name}/restore{?token}'],
    restorePackageForOrg: ['POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}'],
    restorePackageForUser: ['POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}'],
    restorePackageVersionForAuthenticatedUser: [
      'POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore',
    ],
    restorePackageVersionForOrg: [
      'POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore',
    ],
    restorePackageVersionForUser: [
      'POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore',
    ],
  },
  privateRegistries: {
    createOrgPrivateRegistry: ['POST /orgs/{org}/private-registries'],
    deleteOrgPrivateRegistry: ['DELETE /orgs/{org}/private-registries/{secret_name}'],
    getOrgPrivateRegistry: ['GET /orgs/{org}/private-registries/{secret_name}'],
    getOrgPublicKey: ['GET /orgs/{org}/private-registries/public-key'],
    listOrgPrivateRegistries: ['GET /orgs/{org}/private-registries'],
    updateOrgPrivateRegistry: ['PATCH /orgs/{org}/private-registries/{secret_name}'],
  },
  projects: {
    addCollaborator: [
      'PUT /projects/{project_id}/collaborators/{username}',
      {},
      {
        deprecated:
          'octokit.rest.projects.addCollaborator() is deprecated, see https://docs.github.com/rest/projects/collaborators#add-project-collaborator',
      },
    ],
    createCard: [
      'POST /projects/columns/{column_id}/cards',
      {},
      {
        deprecated:
          'octokit.rest.projects.createCard() is deprecated, see https://docs.github.com/rest/projects/cards#create-a-project-card',
      },
    ],
    createColumn: [
      'POST /projects/{project_id}/columns',
      {},
      {
        deprecated:
          'octokit.rest.projects.createColumn() is deprecated, see https://docs.github.com/rest/projects/columns#create-a-project-column',
      },
    ],
    createForAuthenticatedUser: [
      'POST /user/projects',
      {},
      {
        deprecated:
          'octokit.rest.projects.createForAuthenticatedUser() is deprecated, see https://docs.github.com/rest/projects/projects#create-a-user-project',
      },
    ],
    createForOrg: [
      'POST /orgs/{org}/projects',
      {},
      {
        deprecated:
          'octokit.rest.projects.createForOrg() is deprecated, see https://docs.github.com/rest/projects/projects#create-an-organization-project',
      },
    ],
    createForRepo: [
      'POST /repos/{owner}/{repo}/projects',
      {},
      {
        deprecated:
          'octokit.rest.projects.createForRepo() is deprecated, see https://docs.github.com/rest/projects/projects#create-a-repository-project',
      },
    ],
    delete: [
      'DELETE /projects/{project_id}',
      {},
      {
        deprecated:
          'octokit.rest.projects.delete() is deprecated, see https://docs.github.com/rest/projects/projects#delete-a-project',
      },
    ],
    deleteCard: [
      'DELETE /projects/columns/cards/{card_id}',
      {},
      {
        deprecated:
          'octokit.rest.projects.deleteCard() is deprecated, see https://docs.github.com/rest/projects/cards#delete-a-project-card',
      },
    ],
    deleteColumn: [
      'DELETE /projects/columns/{column_id}',
      {},
      {
        deprecated:
          'octokit.rest.projects.deleteColumn() is deprecated, see https://docs.github.com/rest/projects/columns#delete-a-project-column',
      },
    ],
    get: [
      'GET /projects/{project_id}',
      {},
      {
        deprecated:
          'octokit.rest.projects.get() is deprecated, see https://docs.github.com/rest/projects/projects#get-a-project',
      },
    ],
    getCard: [
      'GET /projects/columns/cards/{card_id}',
      {},
      {
        deprecated:
          'octokit.rest.projects.getCard() is deprecated, see https://docs.github.com/rest/projects/cards#get-a-project-card',
      },
    ],
    getColumn: [
      'GET /projects/columns/{column_id}',
      {},
      {
        deprecated:
          'octokit.rest.projects.getColumn() is deprecated, see https://docs.github.com/rest/projects/columns#get-a-project-column',
      },
    ],
    getPermissionForUser: [
      'GET /projects/{project_id}/collaborators/{username}/permission',
      {},
      {
        deprecated:
          'octokit.rest.projects.getPermissionForUser() is deprecated, see https://docs.github.com/rest/projects/collaborators#get-project-permission-for-a-user',
      },
    ],
    listCards: [
      'GET /projects/columns/{column_id}/cards',
      {},
      {
        deprecated:
          'octokit.rest.projects.listCards() is deprecated, see https://docs.github.com/rest/projects/cards#list-project-cards',
      },
    ],
    listCollaborators: [
      'GET /projects/{project_id}/collaborators',
      {},
      {
        deprecated:
          'octokit.rest.projects.listCollaborators() is deprecated, see https://docs.github.com/rest/projects/collaborators#list-project-collaborators',
      },
    ],
    listColumns: [
      'GET /projects/{project_id}/columns',
      {},
      {
        deprecated:
          'octokit.rest.projects.listColumns() is deprecated, see https://docs.github.com/rest/projects/columns#list-project-columns',
      },
    ],
    listForOrg: [
      'GET /orgs/{org}/projects',
      {},
      {
        deprecated:
          'octokit.rest.projects.listForOrg() is deprecated, see https://docs.github.com/rest/projects/projects#list-organization-projects',
      },
    ],
    listForRepo: [
      'GET /repos/{owner}/{repo}/projects',
      {},
      {
        deprecated:
          'octokit.rest.projects.listForRepo() is deprecated, see https://docs.github.com/rest/projects/projects#list-repository-projects',
      },
    ],
    listForUser: [
      'GET /users/{username}/projects',
      {},
      {
        deprecated:
          'octokit.rest.projects.listForUser() is deprecated, see https://docs.github.com/rest/projects/projects#list-user-projects',
      },
    ],
    moveCard: [
      'POST /projects/columns/cards/{card_id}/moves',
      {},
      {
        deprecated:
          'octokit.rest.projects.moveCard() is deprecated, see https://docs.github.com/rest/projects/cards#move-a-project-card',
      },
    ],
    moveColumn: [
      'POST /projects/columns/{column_id}/moves',
      {},
      {
        deprecated:
          'octokit.rest.projects.moveColumn() is deprecated, see https://docs.github.com/rest/projects/columns#move-a-project-column',
      },
    ],
    removeCollaborator: [
      'DELETE /projects/{project_id}/collaborators/{username}',
      {},
      {
        deprecated:
          'octokit.rest.projects.removeCollaborator() is deprecated, see https://docs.github.com/rest/projects/collaborators#remove-user-as-a-collaborator',
      },
    ],
    update: [
      'PATCH /projects/{project_id}',
      {},
      {
        deprecated:
          'octokit.rest.projects.update() is deprecated, see https://docs.github.com/rest/projects/projects#update-a-project',
      },
    ],
    updateCard: [
      'PATCH /projects/columns/cards/{card_id}',
      {},
      {
        deprecated:
          'octokit.rest.projects.updateCard() is deprecated, see https://docs.github.com/rest/projects/cards#update-an-existing-project-card',
      },
    ],
    updateColumn: [
      'PATCH /projects/columns/{column_id}',
      {},
      {
        deprecated:
          'octokit.rest.projects.updateColumn() is deprecated, see https://docs.github.com/rest/projects/columns#update-an-existing-project-column',
      },
    ],
  },
  pulls: {
    checkIfMerged: ['GET /repos/{owner}/{repo}/pulls/{pull_number}/merge'],
    create: ['POST /repos/{owner}/{repo}/pulls'],
    createReplyForReviewComment: ['POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies'],
    createReview: ['POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews'],
    createReviewComment: ['POST /repos/{owner}/{repo}/pulls/{pull_number}/comments'],
    deletePendingReview: ['DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}'],
    deleteReviewComment: ['DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}'],
    dismissReview: ['PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals'],
    get: ['GET /repos/{owner}/{repo}/pulls/{pull_number}'],
    getReview: ['GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}'],
    getReviewComment: ['GET /repos/{owner}/{repo}/pulls/comments/{comment_id}'],
    list: ['GET /repos/{owner}/{repo}/pulls'],
    listCommentsForReview: ['GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments'],
    listCommits: ['GET /repos/{owner}/{repo}/pulls/{pull_number}/commits'],
    listFiles: ['GET /repos/{owner}/{repo}/pulls/{pull_number}/files'],
    listRequestedReviewers: ['GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers'],
    listReviewComments: ['GET /repos/{owner}/{repo}/pulls/{pull_number}/comments'],
    listReviewCommentsForRepo: ['GET /repos/{owner}/{repo}/pulls/comments'],
    listReviews: ['GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews'],
    merge: ['PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge'],
    removeRequestedReviewers: ['DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers'],
    requestReviewers: ['POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers'],
    submitReview: ['POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events'],
    update: ['PATCH /repos/{owner}/{repo}/pulls/{pull_number}'],
    updateBranch: ['PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch'],
    updateReview: ['PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}'],
    updateReviewComment: ['PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}'],
  },
  rateLimit: { get: ['GET /rate_limit'] },
  reactions: {
    createForCommitComment: ['POST /repos/{owner}/{repo}/comments/{comment_id}/reactions'],
    createForIssue: ['POST /repos/{owner}/{repo}/issues/{issue_number}/reactions'],
    createForIssueComment: ['POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions'],
    createForPullRequestReviewComment: ['POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions'],
    createForRelease: ['POST /repos/{owner}/{repo}/releases/{release_id}/reactions'],
    createForTeamDiscussionCommentInOrg: [
      'POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions',
    ],
    createForTeamDiscussionInOrg: ['POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions'],
    deleteForCommitComment: ['DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}'],
    deleteForIssue: ['DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}'],
    deleteForIssueComment: ['DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}'],
    deleteForPullRequestComment: ['DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}'],
    deleteForRelease: ['DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}'],
    deleteForTeamDiscussion: [
      'DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}',
    ],
    deleteForTeamDiscussionComment: [
      'DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}',
    ],
    listForCommitComment: ['GET /repos/{owner}/{repo}/comments/{comment_id}/reactions'],
    listForIssue: ['GET /repos/{owner}/{repo}/issues/{issue_number}/reactions'],
    listForIssueComment: ['GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions'],
    listForPullRequestReviewComment: ['GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions'],
    listForRelease: ['GET /repos/{owner}/{repo}/releases/{release_id}/reactions'],
    listForTeamDiscussionCommentInOrg: [
      'GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions',
    ],
    listForTeamDiscussionInOrg: ['GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions'],
  },
  repos: {
    acceptInvitation: [
      'PATCH /user/repository_invitations/{invitation_id}',
      {},
      { renamed: ['repos', 'acceptInvitationForAuthenticatedUser'] },
    ],
    acceptInvitationForAuthenticatedUser: ['PATCH /user/repository_invitations/{invitation_id}'],
    addAppAccessRestrictions: [
      'POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps',
      {},
      { mapToData: 'apps' },
    ],
    addCollaborator: ['PUT /repos/{owner}/{repo}/collaborators/{username}'],
    addStatusCheckContexts: [
      'POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
      {},
      { mapToData: 'contexts' },
    ],
    addTeamAccessRestrictions: [
      'POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams',
      {},
      { mapToData: 'teams' },
    ],
    addUserAccessRestrictions: [
      'POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users',
      {},
      { mapToData: 'users' },
    ],
    cancelPagesDeployment: ['POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel'],
    checkAutomatedSecurityFixes: ['GET /repos/{owner}/{repo}/automated-security-fixes'],
    checkCollaborator: ['GET /repos/{owner}/{repo}/collaborators/{username}'],
    checkPrivateVulnerabilityReporting: ['GET /repos/{owner}/{repo}/private-vulnerability-reporting'],
    checkVulnerabilityAlerts: ['GET /repos/{owner}/{repo}/vulnerability-alerts'],
    codeownersErrors: ['GET /repos/{owner}/{repo}/codeowners/errors'],
    compareCommits: ['GET /repos/{owner}/{repo}/compare/{base}...{head}'],
    compareCommitsWithBasehead: ['GET /repos/{owner}/{repo}/compare/{basehead}'],
    createAttestation: ['POST /repos/{owner}/{repo}/attestations'],
    createAutolink: ['POST /repos/{owner}/{repo}/autolinks'],
    createCommitComment: ['POST /repos/{owner}/{repo}/commits/{commit_sha}/comments'],
    createCommitSignatureProtection: ['POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures'],
    createCommitStatus: ['POST /repos/{owner}/{repo}/statuses/{sha}'],
    createDeployKey: ['POST /repos/{owner}/{repo}/keys'],
    createDeployment: ['POST /repos/{owner}/{repo}/deployments'],
    createDeploymentBranchPolicy: [
      'POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies',
    ],
    createDeploymentProtectionRule: [
      'POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules',
    ],
    createDeploymentStatus: ['POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses'],
    createDispatchEvent: ['POST /repos/{owner}/{repo}/dispatches'],
    createForAuthenticatedUser: ['POST /user/repos'],
    createFork: ['POST /repos/{owner}/{repo}/forks'],
    createInOrg: ['POST /orgs/{org}/repos'],
    createOrUpdateCustomPropertiesValues: ['PATCH /repos/{owner}/{repo}/properties/values'],
    createOrUpdateEnvironment: ['PUT /repos/{owner}/{repo}/environments/{environment_name}'],
    createOrUpdateFileContents: ['PUT /repos/{owner}/{repo}/contents/{path}'],
    createOrgRuleset: ['POST /orgs/{org}/rulesets'],
    createPagesDeployment: ['POST /repos/{owner}/{repo}/pages/deployments'],
    createPagesSite: ['POST /repos/{owner}/{repo}/pages'],
    createRelease: ['POST /repos/{owner}/{repo}/releases'],
    createRepoRuleset: ['POST /repos/{owner}/{repo}/rulesets'],
    createUsingTemplate: ['POST /repos/{template_owner}/{template_repo}/generate'],
    createWebhook: ['POST /repos/{owner}/{repo}/hooks'],
    declineInvitation: [
      'DELETE /user/repository_invitations/{invitation_id}',
      {},
      { renamed: ['repos', 'declineInvitationForAuthenticatedUser'] },
    ],
    declineInvitationForAuthenticatedUser: ['DELETE /user/repository_invitations/{invitation_id}'],
    delete: ['DELETE /repos/{owner}/{repo}'],
    deleteAccessRestrictions: ['DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions'],
    deleteAdminBranchProtection: ['DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins'],
    deleteAnEnvironment: ['DELETE /repos/{owner}/{repo}/environments/{environment_name}'],
    deleteAutolink: ['DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}'],
    deleteBranchProtection: ['DELETE /repos/{owner}/{repo}/branches/{branch}/protection'],
    deleteCommitComment: ['DELETE /repos/{owner}/{repo}/comments/{comment_id}'],
    deleteCommitSignatureProtection: ['DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures'],
    deleteDeployKey: ['DELETE /repos/{owner}/{repo}/keys/{key_id}'],
    deleteDeployment: ['DELETE /repos/{owner}/{repo}/deployments/{deployment_id}'],
    deleteDeploymentBranchPolicy: [
      'DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}',
    ],
    deleteFile: ['DELETE /repos/{owner}/{repo}/contents/{path}'],
    deleteInvitation: ['DELETE /repos/{owner}/{repo}/invitations/{invitation_id}'],
    deleteOrgRuleset: ['DELETE /orgs/{org}/rulesets/{ruleset_id}'],
    deletePagesSite: ['DELETE /repos/{owner}/{repo}/pages'],
    deletePullRequestReviewProtection: [
      'DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews',
    ],
    deleteRelease: ['DELETE /repos/{owner}/{repo}/releases/{release_id}'],
    deleteReleaseAsset: ['DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}'],
    deleteRepoRuleset: ['DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}'],
    deleteWebhook: ['DELETE /repos/{owner}/{repo}/hooks/{hook_id}'],
    disableAutomatedSecurityFixes: ['DELETE /repos/{owner}/{repo}/automated-security-fixes'],
    disableDeploymentProtectionRule: [
      'DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}',
    ],
    disablePrivateVulnerabilityReporting: ['DELETE /repos/{owner}/{repo}/private-vulnerability-reporting'],
    disableVulnerabilityAlerts: ['DELETE /repos/{owner}/{repo}/vulnerability-alerts'],
    downloadArchive: ['GET /repos/{owner}/{repo}/zipball/{ref}', {}, { renamed: ['repos', 'downloadZipballArchive'] }],
    downloadTarballArchive: ['GET /repos/{owner}/{repo}/tarball/{ref}'],
    downloadZipballArchive: ['GET /repos/{owner}/{repo}/zipball/{ref}'],
    enableAutomatedSecurityFixes: ['PUT /repos/{owner}/{repo}/automated-security-fixes'],
    enablePrivateVulnerabilityReporting: ['PUT /repos/{owner}/{repo}/private-vulnerability-reporting'],
    enableVulnerabilityAlerts: ['PUT /repos/{owner}/{repo}/vulnerability-alerts'],
    generateReleaseNotes: ['POST /repos/{owner}/{repo}/releases/generate-notes'],
    get: ['GET /repos/{owner}/{repo}'],
    getAccessRestrictions: ['GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions'],
    getAdminBranchProtection: ['GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins'],
    getAllDeploymentProtectionRules: [
      'GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules',
    ],
    getAllEnvironments: ['GET /repos/{owner}/{repo}/environments'],
    getAllStatusCheckContexts: [
      'GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
    ],
    getAllTopics: ['GET /repos/{owner}/{repo}/topics'],
    getAppsWithAccessToProtectedBranch: ['GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps'],
    getAutolink: ['GET /repos/{owner}/{repo}/autolinks/{autolink_id}'],
    getBranch: ['GET /repos/{owner}/{repo}/branches/{branch}'],
    getBranchProtection: ['GET /repos/{owner}/{repo}/branches/{branch}/protection'],
    getBranchRules: ['GET /repos/{owner}/{repo}/rules/branches/{branch}'],
    getClones: ['GET /repos/{owner}/{repo}/traffic/clones'],
    getCodeFrequencyStats: ['GET /repos/{owner}/{repo}/stats/code_frequency'],
    getCollaboratorPermissionLevel: ['GET /repos/{owner}/{repo}/collaborators/{username}/permission'],
    getCombinedStatusForRef: ['GET /repos/{owner}/{repo}/commits/{ref}/status'],
    getCommit: ['GET /repos/{owner}/{repo}/commits/{ref}'],
    getCommitActivityStats: ['GET /repos/{owner}/{repo}/stats/commit_activity'],
    getCommitComment: ['GET /repos/{owner}/{repo}/comments/{comment_id}'],
    getCommitSignatureProtection: ['GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures'],
    getCommunityProfileMetrics: ['GET /repos/{owner}/{repo}/community/profile'],
    getContent: ['GET /repos/{owner}/{repo}/contents/{path}'],
    getContributorsStats: ['GET /repos/{owner}/{repo}/stats/contributors'],
    getCustomDeploymentProtectionRule: [
      'GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}',
    ],
    getCustomPropertiesValues: ['GET /repos/{owner}/{repo}/properties/values'],
    getDeployKey: ['GET /repos/{owner}/{repo}/keys/{key_id}'],
    getDeployment: ['GET /repos/{owner}/{repo}/deployments/{deployment_id}'],
    getDeploymentBranchPolicy: [
      'GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}',
    ],
    getDeploymentStatus: ['GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}'],
    getEnvironment: ['GET /repos/{owner}/{repo}/environments/{environment_name}'],
    getLatestPagesBuild: ['GET /repos/{owner}/{repo}/pages/builds/latest'],
    getLatestRelease: ['GET /repos/{owner}/{repo}/releases/latest'],
    getOrgRuleSuite: ['GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}'],
    getOrgRuleSuites: ['GET /orgs/{org}/rulesets/rule-suites'],
    getOrgRuleset: ['GET /orgs/{org}/rulesets/{ruleset_id}'],
    getOrgRulesets: ['GET /orgs/{org}/rulesets'],
    getPages: ['GET /repos/{owner}/{repo}/pages'],
    getPagesBuild: ['GET /repos/{owner}/{repo}/pages/builds/{build_id}'],
    getPagesDeployment: ['GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}'],
    getPagesHealthCheck: ['GET /repos/{owner}/{repo}/pages/health'],
    getParticipationStats: ['GET /repos/{owner}/{repo}/stats/participation'],
    getPullRequestReviewProtection: [
      'GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews',
    ],
    getPunchCardStats: ['GET /repos/{owner}/{repo}/stats/punch_card'],
    getReadme: ['GET /repos/{owner}/{repo}/readme'],
    getReadmeInDirectory: ['GET /repos/{owner}/{repo}/readme/{dir}'],
    getRelease: ['GET /repos/{owner}/{repo}/releases/{release_id}'],
    getReleaseAsset: ['GET /repos/{owner}/{repo}/releases/assets/{asset_id}'],
    getReleaseByTag: ['GET /repos/{owner}/{repo}/releases/tags/{tag}'],
    getRepoRuleSuite: ['GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}'],
    getRepoRuleSuites: ['GET /repos/{owner}/{repo}/rulesets/rule-suites'],
    getRepoRuleset: ['GET /repos/{owner}/{repo}/rulesets/{ruleset_id}'],
    getRepoRulesetHistory: ['GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history'],
    getRepoRulesetVersion: ['GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}'],
    getRepoRulesets: ['GET /repos/{owner}/{repo}/rulesets'],
    getStatusChecksProtection: ['GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks'],
    getTeamsWithAccessToProtectedBranch: ['GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams'],
    getTopPaths: ['GET /repos/{owner}/{repo}/traffic/popular/paths'],
    getTopReferrers: ['GET /repos/{owner}/{repo}/traffic/popular/referrers'],
    getUsersWithAccessToProtectedBranch: ['GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users'],
    getViews: ['GET /repos/{owner}/{repo}/traffic/views'],
    getWebhook: ['GET /repos/{owner}/{repo}/hooks/{hook_id}'],
    getWebhookConfigForRepo: ['GET /repos/{owner}/{repo}/hooks/{hook_id}/config'],
    getWebhookDelivery: ['GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}'],
    listActivities: ['GET /repos/{owner}/{repo}/activity'],
    listAttestations: ['GET /repos/{owner}/{repo}/attestations/{subject_digest}'],
    listAutolinks: ['GET /repos/{owner}/{repo}/autolinks'],
    listBranches: ['GET /repos/{owner}/{repo}/branches'],
    listBranchesForHeadCommit: ['GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head'],
    listCollaborators: ['GET /repos/{owner}/{repo}/collaborators'],
    listCommentsForCommit: ['GET /repos/{owner}/{repo}/commits/{commit_sha}/comments'],
    listCommitCommentsForRepo: ['GET /repos/{owner}/{repo}/comments'],
    listCommitStatusesForRef: ['GET /repos/{owner}/{repo}/commits/{ref}/statuses'],
    listCommits: ['GET /repos/{owner}/{repo}/commits'],
    listContributors: ['GET /repos/{owner}/{repo}/contributors'],
    listCustomDeploymentRuleIntegrations: [
      'GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps',
    ],
    listDeployKeys: ['GET /repos/{owner}/{repo}/keys'],
    listDeploymentBranchPolicies: [
      'GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies',
    ],
    listDeploymentStatuses: ['GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses'],
    listDeployments: ['GET /repos/{owner}/{repo}/deployments'],
    listForAuthenticatedUser: ['GET /user/repos'],
    listForOrg: ['GET /orgs/{org}/repos'],
    listForUser: ['GET /users/{username}/repos'],
    listForks: ['GET /repos/{owner}/{repo}/forks'],
    listInvitations: ['GET /repos/{owner}/{repo}/invitations'],
    listInvitationsForAuthenticatedUser: ['GET /user/repository_invitations'],
    listLanguages: ['GET /repos/{owner}/{repo}/languages'],
    listPagesBuilds: ['GET /repos/{owner}/{repo}/pages/builds'],
    listPublic: ['GET /repositories'],
    listPullRequestsAssociatedWithCommit: ['GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls'],
    listReleaseAssets: ['GET /repos/{owner}/{repo}/releases/{release_id}/assets'],
    listReleases: ['GET /repos/{owner}/{repo}/releases'],
    listTags: ['GET /repos/{owner}/{repo}/tags'],
    listTeams: ['GET /repos/{owner}/{repo}/teams'],
    listWebhookDeliveries: ['GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries'],
    listWebhooks: ['GET /repos/{owner}/{repo}/hooks'],
    merge: ['POST /repos/{owner}/{repo}/merges'],
    mergeUpstream: ['POST /repos/{owner}/{repo}/merge-upstream'],
    pingWebhook: ['POST /repos/{owner}/{repo}/hooks/{hook_id}/pings'],
    redeliverWebhookDelivery: ['POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts'],
    removeAppAccessRestrictions: [
      'DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps',
      {},
      { mapToData: 'apps' },
    ],
    removeCollaborator: ['DELETE /repos/{owner}/{repo}/collaborators/{username}'],
    removeStatusCheckContexts: [
      'DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
      {},
      { mapToData: 'contexts' },
    ],
    removeStatusCheckProtection: ['DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks'],
    removeTeamAccessRestrictions: [
      'DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams',
      {},
      { mapToData: 'teams' },
    ],
    removeUserAccessRestrictions: [
      'DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users',
      {},
      { mapToData: 'users' },
    ],
    renameBranch: ['POST /repos/{owner}/{repo}/branches/{branch}/rename'],
    replaceAllTopics: ['PUT /repos/{owner}/{repo}/topics'],
    requestPagesBuild: ['POST /repos/{owner}/{repo}/pages/builds'],
    setAdminBranchProtection: ['POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins'],
    setAppAccessRestrictions: [
      'PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps',
      {},
      { mapToData: 'apps' },
    ],
    setStatusCheckContexts: [
      'PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts',
      {},
      { mapToData: 'contexts' },
    ],
    setTeamAccessRestrictions: [
      'PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams',
      {},
      { mapToData: 'teams' },
    ],
    setUserAccessRestrictions: [
      'PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users',
      {},
      { mapToData: 'users' },
    ],
    testPushWebhook: ['POST /repos/{owner}/{repo}/hooks/{hook_id}/tests'],
    transfer: ['POST /repos/{owner}/{repo}/transfer'],
    update: ['PATCH /repos/{owner}/{repo}'],
    updateBranchProtection: ['PUT /repos/{owner}/{repo}/branches/{branch}/protection'],
    updateCommitComment: ['PATCH /repos/{owner}/{repo}/comments/{comment_id}'],
    updateDeploymentBranchPolicy: [
      'PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}',
    ],
    updateInformationAboutPagesSite: ['PUT /repos/{owner}/{repo}/pages'],
    updateInvitation: ['PATCH /repos/{owner}/{repo}/invitations/{invitation_id}'],
    updateOrgRuleset: ['PUT /orgs/{org}/rulesets/{ruleset_id}'],
    updatePullRequestReviewProtection: [
      'PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews',
    ],
    updateRelease: ['PATCH /repos/{owner}/{repo}/releases/{release_id}'],
    updateReleaseAsset: ['PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}'],
    updateRepoRuleset: ['PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}'],
    updateStatusCheckPotection: [
      'PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks',
      {},
      { renamed: ['repos', 'updateStatusCheckProtection'] },
    ],
    updateStatusCheckProtection: ['PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks'],
    updateWebhook: ['PATCH /repos/{owner}/{repo}/hooks/{hook_id}'],
    updateWebhookConfigForRepo: ['PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config'],
    uploadReleaseAsset: [
      'POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}',
      { baseUrl: 'https://uploads.github.com' },
    ],
  },
  search: {
    code: ['GET /search/code'],
    commits: ['GET /search/commits'],
    issuesAndPullRequests: [
      'GET /search/issues',
      {},
      {
        deprecated:
          'octokit.rest.search.issuesAndPullRequests() is deprecated, see https://docs.github.com/rest/search/search#search-issues-and-pull-requests',
      },
    ],
    labels: ['GET /search/labels'],
    repos: ['GET /search/repositories'],
    topics: ['GET /search/topics'],
    users: ['GET /search/users'],
  },
  secretScanning: {
    createPushProtectionBypass: ['POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses'],
    getAlert: ['GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}'],
    getScanHistory: ['GET /repos/{owner}/{repo}/secret-scanning/scan-history'],
    listAlertsForEnterprise: ['GET /enterprises/{enterprise}/secret-scanning/alerts'],
    listAlertsForOrg: ['GET /orgs/{org}/secret-scanning/alerts'],
    listAlertsForRepo: ['GET /repos/{owner}/{repo}/secret-scanning/alerts'],
    listLocationsForAlert: ['GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations'],
    updateAlert: ['PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}'],
  },
  securityAdvisories: {
    createFork: ['POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks'],
    createPrivateVulnerabilityReport: ['POST /repos/{owner}/{repo}/security-advisories/reports'],
    createRepositoryAdvisory: ['POST /repos/{owner}/{repo}/security-advisories'],
    createRepositoryAdvisoryCveRequest: ['POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve'],
    getGlobalAdvisory: ['GET /advisories/{ghsa_id}'],
    getRepositoryAdvisory: ['GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}'],
    listGlobalAdvisories: ['GET /advisories'],
    listOrgRepositoryAdvisories: ['GET /orgs/{org}/security-advisories'],
    listRepositoryAdvisories: ['GET /repos/{owner}/{repo}/security-advisories'],
    updateRepositoryAdvisory: ['PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}'],
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: ['PUT /orgs/{org}/teams/{team_slug}/memberships/{username}'],
    addOrUpdateProjectPermissionsInOrg: [
      'PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}',
      {},
      {
        deprecated:
          'octokit.rest.teams.addOrUpdateProjectPermissionsInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#add-or-update-team-project-permissions',
      },
    ],
    addOrUpdateProjectPermissionsLegacy: [
      'PUT /teams/{team_id}/projects/{project_id}',
      {},
      {
        deprecated:
          'octokit.rest.teams.addOrUpdateProjectPermissionsLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#add-or-update-team-project-permissions-legacy',
      },
    ],
    addOrUpdateRepoPermissionsInOrg: ['PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}'],
    checkPermissionsForProjectInOrg: [
      'GET /orgs/{org}/teams/{team_slug}/projects/{project_id}',
      {},
      {
        deprecated:
          'octokit.rest.teams.checkPermissionsForProjectInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-project',
      },
    ],
    checkPermissionsForProjectLegacy: [
      'GET /teams/{team_id}/projects/{project_id}',
      {},
      {
        deprecated:
          'octokit.rest.teams.checkPermissionsForProjectLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-project-legacy',
      },
    ],
    checkPermissionsForRepoInOrg: ['GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}'],
    create: ['POST /orgs/{org}/teams'],
    createDiscussionCommentInOrg: ['POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments'],
    createDiscussionInOrg: ['POST /orgs/{org}/teams/{team_slug}/discussions'],
    deleteDiscussionCommentInOrg: [
      'DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}',
    ],
    deleteDiscussionInOrg: ['DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}'],
    deleteInOrg: ['DELETE /orgs/{org}/teams/{team_slug}'],
    getByName: ['GET /orgs/{org}/teams/{team_slug}'],
    getDiscussionCommentInOrg: [
      'GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}',
    ],
    getDiscussionInOrg: ['GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}'],
    getMembershipForUserInOrg: ['GET /orgs/{org}/teams/{team_slug}/memberships/{username}'],
    list: ['GET /orgs/{org}/teams'],
    listChildInOrg: ['GET /orgs/{org}/teams/{team_slug}/teams'],
    listDiscussionCommentsInOrg: ['GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments'],
    listDiscussionsInOrg: ['GET /orgs/{org}/teams/{team_slug}/discussions'],
    listForAuthenticatedUser: ['GET /user/teams'],
    listMembersInOrg: ['GET /orgs/{org}/teams/{team_slug}/members'],
    listPendingInvitationsInOrg: ['GET /orgs/{org}/teams/{team_slug}/invitations'],
    listProjectsInOrg: [
      'GET /orgs/{org}/teams/{team_slug}/projects',
      {},
      {
        deprecated:
          'octokit.rest.teams.listProjectsInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#list-team-projects',
      },
    ],
    listProjectsLegacy: [
      'GET /teams/{team_id}/projects',
      {},
      {
        deprecated:
          'octokit.rest.teams.listProjectsLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#list-team-projects-legacy',
      },
    ],
    listReposInOrg: ['GET /orgs/{org}/teams/{team_slug}/repos'],
    removeMembershipForUserInOrg: ['DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}'],
    removeProjectInOrg: [
      'DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}',
      {},
      {
        deprecated:
          'octokit.rest.teams.removeProjectInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#remove-a-project-from-a-team',
      },
    ],
    removeProjectLegacy: [
      'DELETE /teams/{team_id}/projects/{project_id}',
      {},
      {
        deprecated:
          'octokit.rest.teams.removeProjectLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#remove-a-project-from-a-team-legacy',
      },
    ],
    removeRepoInOrg: ['DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}'],
    updateDiscussionCommentInOrg: [
      'PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}',
    ],
    updateDiscussionInOrg: ['PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}'],
    updateInOrg: ['PATCH /orgs/{org}/teams/{team_slug}'],
  },
  users: {
    addEmailForAuthenticated: ['POST /user/emails', {}, { renamed: ['users', 'addEmailForAuthenticatedUser'] }],
    addEmailForAuthenticatedUser: ['POST /user/emails'],
    addSocialAccountForAuthenticatedUser: ['POST /user/social_accounts'],
    block: ['PUT /user/blocks/{username}'],
    checkBlocked: ['GET /user/blocks/{username}'],
    checkFollowingForUser: ['GET /users/{username}/following/{target_user}'],
    checkPersonIsFollowedByAuthenticated: ['GET /user/following/{username}'],
    createGpgKeyForAuthenticated: [
      'POST /user/gpg_keys',
      {},
      { renamed: ['users', 'createGpgKeyForAuthenticatedUser'] },
    ],
    createGpgKeyForAuthenticatedUser: ['POST /user/gpg_keys'],
    createPublicSshKeyForAuthenticated: [
      'POST /user/keys',
      {},
      { renamed: ['users', 'createPublicSshKeyForAuthenticatedUser'] },
    ],
    createPublicSshKeyForAuthenticatedUser: ['POST /user/keys'],
    createSshSigningKeyForAuthenticatedUser: ['POST /user/ssh_signing_keys'],
    deleteEmailForAuthenticated: ['DELETE /user/emails', {}, { renamed: ['users', 'deleteEmailForAuthenticatedUser'] }],
    deleteEmailForAuthenticatedUser: ['DELETE /user/emails'],
    deleteGpgKeyForAuthenticated: [
      'DELETE /user/gpg_keys/{gpg_key_id}',
      {},
      { renamed: ['users', 'deleteGpgKeyForAuthenticatedUser'] },
    ],
    deleteGpgKeyForAuthenticatedUser: ['DELETE /user/gpg_keys/{gpg_key_id}'],
    deletePublicSshKeyForAuthenticated: [
      'DELETE /user/keys/{key_id}',
      {},
      { renamed: ['users', 'deletePublicSshKeyForAuthenticatedUser'] },
    ],
    deletePublicSshKeyForAuthenticatedUser: ['DELETE /user/keys/{key_id}'],
    deleteSocialAccountForAuthenticatedUser: ['DELETE /user/social_accounts'],
    deleteSshSigningKeyForAuthenticatedUser: ['DELETE /user/ssh_signing_keys/{ssh_signing_key_id}'],
    follow: ['PUT /user/following/{username}'],
    getAuthenticated: ['GET /user'],
    getById: ['GET /user/{account_id}'],
    getByUsername: ['GET /users/{username}'],
    getContextForUser: ['GET /users/{username}/hovercard'],
    getGpgKeyForAuthenticated: [
      'GET /user/gpg_keys/{gpg_key_id}',
      {},
      { renamed: ['users', 'getGpgKeyForAuthenticatedUser'] },
    ],
    getGpgKeyForAuthenticatedUser: ['GET /user/gpg_keys/{gpg_key_id}'],
    getPublicSshKeyForAuthenticated: [
      'GET /user/keys/{key_id}',
      {},
      { renamed: ['users', 'getPublicSshKeyForAuthenticatedUser'] },
    ],
    getPublicSshKeyForAuthenticatedUser: ['GET /user/keys/{key_id}'],
    getSshSigningKeyForAuthenticatedUser: ['GET /user/ssh_signing_keys/{ssh_signing_key_id}'],
    list: ['GET /users'],
    listAttestations: ['GET /users/{username}/attestations/{subject_digest}'],
    listBlockedByAuthenticated: ['GET /user/blocks', {}, { renamed: ['users', 'listBlockedByAuthenticatedUser'] }],
    listBlockedByAuthenticatedUser: ['GET /user/blocks'],
    listEmailsForAuthenticated: ['GET /user/emails', {}, { renamed: ['users', 'listEmailsForAuthenticatedUser'] }],
    listEmailsForAuthenticatedUser: ['GET /user/emails'],
    listFollowedByAuthenticated: ['GET /user/following', {}, { renamed: ['users', 'listFollowedByAuthenticatedUser'] }],
    listFollowedByAuthenticatedUser: ['GET /user/following'],
    listFollowersForAuthenticatedUser: ['GET /user/followers'],
    listFollowersForUser: ['GET /users/{username}/followers'],
    listFollowingForUser: ['GET /users/{username}/following'],
    listGpgKeysForAuthenticated: ['GET /user/gpg_keys', {}, { renamed: ['users', 'listGpgKeysForAuthenticatedUser'] }],
    listGpgKeysForAuthenticatedUser: ['GET /user/gpg_keys'],
    listGpgKeysForUser: ['GET /users/{username}/gpg_keys'],
    listPublicEmailsForAuthenticated: [
      'GET /user/public_emails',
      {},
      { renamed: ['users', 'listPublicEmailsForAuthenticatedUser'] },
    ],
    listPublicEmailsForAuthenticatedUser: ['GET /user/public_emails'],
    listPublicKeysForUser: ['GET /users/{username}/keys'],
    listPublicSshKeysForAuthenticated: [
      'GET /user/keys',
      {},
      { renamed: ['users', 'listPublicSshKeysForAuthenticatedUser'] },
    ],
    listPublicSshKeysForAuthenticatedUser: ['GET /user/keys'],
    listSocialAccountsForAuthenticatedUser: ['GET /user/social_accounts'],
    listSocialAccountsForUser: ['GET /users/{username}/social_accounts'],
    listSshSigningKeysForAuthenticatedUser: ['GET /user/ssh_signing_keys'],
    listSshSigningKeysForUser: ['GET /users/{username}/ssh_signing_keys'],
    setPrimaryEmailVisibilityForAuthenticated: [
      'PATCH /user/email/visibility',
      {},
      { renamed: ['users', 'setPrimaryEmailVisibilityForAuthenticatedUser'] },
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: ['PATCH /user/email/visibility'],
    unblock: ['DELETE /user/blocks/{username}'],
    unfollow: ['DELETE /user/following/{username}'],
    updateAuthenticated: ['PATCH /user'],
  },
};
var endpoints_default = Endpoints;

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js
var endpointMethodsMap = /* @__PURE__ */ new Map();
for (const [scope, endpoints] of Object.entries(endpoints_default)) {
  for (const [methodName, endpoint2] of Object.entries(endpoints)) {
    const [route, defaults, decorations] = endpoint2;
    const [method, url] = route.split(/ /);
    const endpointDefaults = Object.assign(
      {
        method,
        url,
      },
      defaults,
    );
    if (!endpointMethodsMap.has(scope)) {
      endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
    }
    endpointMethodsMap.get(scope).set(methodName, {
      scope,
      methodName,
      endpointDefaults,
      decorations,
    });
  }
}
var handler = {
  has({ scope }, methodName) {
    return endpointMethodsMap.get(scope).has(methodName);
  },
  getOwnPropertyDescriptor(target, methodName) {
    return {
      value: this.get(target, methodName),
      // ensures method is in the cache
      configurable: true,
      writable: true,
      enumerable: true,
    };
  },
  defineProperty(target, methodName, descriptor) {
    Object.defineProperty(target.cache, methodName, descriptor);
    return true;
  },
  deleteProperty(target, methodName) {
    delete target.cache[methodName];
    return true;
  },
  ownKeys({ scope }) {
    return [...endpointMethodsMap.get(scope).keys()];
  },
  set(target, methodName, value) {
    return (target.cache[methodName] = value);
  },
  get({ octokit: octokit2, scope, cache }, methodName) {
    if (cache[methodName]) {
      return cache[methodName];
    }
    const method = endpointMethodsMap.get(scope).get(methodName);
    if (!method) {
      return void 0;
    }
    const { endpointDefaults, decorations } = method;
    if (decorations) {
      cache[methodName] = decorate(octokit2, scope, methodName, endpointDefaults, decorations);
    } else {
      cache[methodName] = octokit2.request.defaults(endpointDefaults);
    }
    return cache[methodName];
  },
};
function endpointsToMethods(octokit2) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({ octokit: octokit2, scope, cache: {} }, handler);
  }
  return newMethods;
}
function decorate(octokit2, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit2.request.defaults(defaults);
  function withDecorations(...args) {
    let options2 = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options2 = Object.assign({}, options2, {
        data: options2[decorations.mapToData],
        [decorations.mapToData]: void 0,
      });
      return requestWithDefaults(options2);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit2.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
    }
    if (decorations.deprecated) {
      octokit2.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options22 = requestWithDefaults.endpoint.merge(...args);
      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
        if (name in options22) {
          octokit2.log.warn(
            `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`,
          );
          if (!(alias in options22)) {
            options22[alias] = options22[name];
          }
          delete options22[name];
        }
      }
      return requestWithDefaults(options22);
    }
    return requestWithDefaults(...args);
  }
  return Object.assign(withDecorations, requestWithDefaults);
}

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js
function restEndpointMethods(octokit2) {
  const api = endpointsToMethods(octokit2);
  return {
    rest: api,
  };
}
restEndpointMethods.VERSION = VERSION7;
function legacyRestEndpointMethods(octokit2) {
  const api = endpointsToMethods(octokit2);
  return {
    ...api,
    rest: api,
  };
}
legacyRestEndpointMethods.VERSION = VERSION7;

// node_modules/@octokit/rest/dist-src/version.js
var VERSION8 = '21.1.1';

// node_modules/@octokit/rest/dist-src/index.js
var Octokit2 = Octokit.plugin(requestLog, legacyRestEndpointMethods, paginateRest).defaults({
  userAgent: `octokit-rest.js/${VERSION8}`,
});

// node_modules/commander/esm.mjs
var import_index = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  // deprecated old name
  Command,
  Argument,
  Option,
  Help,
} = import_index.default;

// node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 =
  (offset = 0) =>
  (code) =>
    `\x1B[${code + offset}m`;
var wrapAnsi256 =
  (offset = 0) =>
  (code) =>
    `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m =
  (offset = 0) =>
  (red, green, blue) =>
    `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39],
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49],
  },
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`,
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false,
    });
  }
  Object.defineProperty(styles, 'codes', {
    value: codes,
    enumerable: false,
  });
  styles.color.close = '\x1B[39m';
  styles.bgColor.close = '\x1B[49m';
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round(((red - 8) / 247) * 24) + 232;
        }
        return 16 + 36 * Math.round((red / 255) * 5) + 6 * Math.round((green / 255) * 5) + Math.round((blue / 255) * 5);
      },
      enumerable: false,
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join('');
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          (integer >> 16) & 255,
          (integer >> 8) & 255,
          integer & 255,
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false,
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false,
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = (remainder % 6) / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false,
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false,
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false,
    },
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/chalk/source/vendor/supports-color/index.js
var import_node_process = __toESM(require('node:process'), 1);
var import_node_os = __toESM(require('node:os'), 1);
var import_node_tty = __toESM(require('node:tty'), 1);
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv) {
  const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf('--');
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = import_node_process.default;
var flagForceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
  flagForceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
  flagForceColor = 1;
}
function envForceColor() {
  if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
      return 1;
    }
    if (env.FORCE_COLOR === 'false') {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3,
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
      return 3;
    }
    if (hasFlag('color=256')) {
      return 2;
    }
  }
  if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === 'dumb') {
    return min;
  }
  if (import_node_process.default.platform === 'win32') {
    const osRelease = import_node_os.default.release().split('.');
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ('CI' in env) {
    if (['GITHUB_ACTIONS', 'GITEA_ACTIONS', 'CIRCLECI'].some((key) => key in env)) {
      return 3;
    }
    if (
      ['TRAVIS', 'APPVEYOR', 'GITLAB_CI', 'BUILDKITE', 'DRONE'].some((sign) => sign in env) ||
      env.CI_NAME === 'codeship'
    ) {
      return 1;
    }
    return min;
  }
  if ('TEAMCITY_VERSION' in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === 'truecolor') {
    return 3;
  }
  if (env.TERM === 'xterm-kitty') {
    return 3;
  }
  if ('TERM_PROGRAM' in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
    switch (env.TERM_PROGRAM) {
      case 'iTerm.app': {
        return version >= 3 ? 3 : 2;
      }
      case 'Apple_Terminal': {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ('COLORTERM' in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options2 = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options2,
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) }),
};
var supports_color_default = supportsColor;

// node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = '';
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = '';
  do {
    const gotCR = string[index - 1] === '\r';
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
    endIndex = index + 1;
    index = string.indexOf('\n', endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol('GENERATOR');
var STYLER = Symbol('STYLER');
var IS_EMPTY = Symbol('IS_EMPTY');
var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options2 = {}) => {
  if (options2.level && !(Number.isInteger(options2.level) && options2.level >= 0 && options2.level <= 3)) {
    throw new Error('The `level` option should be an integer from 0 to 3');
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options2.level === void 0 ? colorLevel : options2.level;
};
var chalkFactory = (options2) => {
  const chalk2 = (...strings) => strings.join(' ');
  applyOptions(chalk2, options2);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options2) {
  return chalkFactory(options2);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    },
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, 'visible', { value: builder });
    return builder;
  },
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === 'rgb') {
    if (level === 'ansi16m') {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === 'ansi256') {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === 'hex') {
    return getModelAnsi('rgb', level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ['rgb', 'hex', 'ansi256'];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function (...arguments_) {
        const styler = createStyler(
          getModelAnsi(model, levelMapping[level], 'color', ...arguments_),
          ansi_styles_default.color.close,
          this[STYLER],
        );
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    },
  };
  const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function (...arguments_) {
        const styler = createStyler(
          getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_),
          ansi_styles_default.bgColor.close,
          this[STYLER],
        );
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    },
  };
}
var proto = Object.defineProperties(() => {}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    },
  },
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent,
  };
};
var createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) =>
    applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self[IS_EMPTY] ? '' : string;
  }
  let styler = self[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes('\x1B')) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf('\n');
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// node_modules/ora/index.js
var import_node_process7 = __toESM(require('node:process'), 1);

// node_modules/cli-cursor/index.js
var import_node_process3 = __toESM(require('node:process'), 1);

// node_modules/restore-cursor/index.js
var import_node_process2 = __toESM(require('node:process'), 1);

// node_modules/mimic-function/index.js
var copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === 'length' || property === 'prototype') {
    return;
  }
  if (property === 'arguments' || property === 'caller') {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
var canCopyProperty = function (toDescriptor, fromDescriptor) {
  return (
    toDescriptor === void 0 ||
    toDescriptor.configurable ||
    (toDescriptor.writable === fromDescriptor.writable &&
      toDescriptor.enumerable === fromDescriptor.enumerable &&
      toDescriptor.configurable === fromDescriptor.configurable &&
      (toDescriptor.writable || toDescriptor.value === fromDescriptor.value))
  );
};
var changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');
var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');
var changeToString = (to, from, name) => {
  const withName = name === '' ? '' : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, 'name', toStringName);
  const { writable, enumerable, configurable } = toStringDescriptor;
  Object.defineProperty(to, 'toString', { value: newToString, writable, enumerable, configurable });
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}

// node_modules/restore-cursor/node_modules/onetime/index.js
var calledFunctions = /* @__PURE__ */ new WeakMap();
var onetime = (function_, options2 = {}) => {
  if (typeof function_ !== 'function') {
    throw new TypeError('Expected a function');
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || '<anonymous>';
  const onetime2 = function (...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = void 0;
    } else if (options2.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFunction(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetime_default = onetime;

// node_modules/restore-cursor/node_modules/signal-exit/dist/mjs/signals.js
var signals = [];
signals.push('SIGHUP', 'SIGINT', 'SIGTERM');
if (process.platform !== 'win32') {
  signals.push(
    'SIGALRM',
    'SIGABRT',
    'SIGVTALRM',
    'SIGXCPU',
    'SIGXFSZ',
    'SIGUSR2',
    'SIGTRAP',
    'SIGSYS',
    'SIGQUIT',
    'SIGIOT',
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
  );
}
if (process.platform === 'linux') {
  signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT');
}

// node_modules/restore-cursor/node_modules/signal-exit/dist/mjs/index.js
var processOk = (process10) =>
  !!process10 &&
  typeof process10 === 'object' &&
  typeof process10.removeListener === 'function' &&
  typeof process10.emit === 'function' &&
  typeof process10.reallyExit === 'function' &&
  typeof process10.listeners === 'function' &&
  typeof process10.kill === 'function' &&
  typeof process10.pid === 'number' &&
  typeof process10.on === 'function';
var kExitEmitter = Symbol.for('signal-exit emitter');
var global2 = globalThis;
var ObjectDefineProperty = Object.defineProperty.bind(Object);
var Emitter = class {
  emitted = {
    afterExit: false,
    exit: false,
  };
  listeners = {
    afterExit: [],
    exit: [],
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (global2[kExitEmitter]) {
      return global2[kExitEmitter];
    }
    ObjectDefineProperty(global2, kExitEmitter, {
      value: this,
      writable: false,
      enumerable: false,
      configurable: false,
    });
  }
  on(ev, fn) {
    this.listeners[ev].push(fn);
  }
  removeListener(ev, fn) {
    const list = this.listeners[ev];
    const i = list.indexOf(fn);
    if (i === -1) {
      return;
    }
    if (i === 0 && list.length === 1) {
      list.length = 0;
    } else {
      list.splice(i, 1);
    }
  }
  emit(ev, code, signal) {
    if (this.emitted[ev]) {
      return false;
    }
    this.emitted[ev] = true;
    let ret = false;
    for (const fn of this.listeners[ev]) {
      ret = fn(code, signal) === true || ret;
    }
    if (ev === 'exit') {
      ret = this.emit('afterExit', code, signal) || ret;
    }
    return ret;
  }
};
var SignalExitBase = class {};
var signalExitWrap = (handler2) => {
  return {
    onExit(cb, opts) {
      return handler2.onExit(cb, opts);
    },
    load() {
      return handler2.load();
    },
    unload() {
      return handler2.unload();
    },
  };
};
var SignalExitFallback = class extends SignalExitBase {
  onExit() {
    return () => {};
  }
  load() {}
  unload() {}
};
var SignalExit = class extends SignalExitBase {
  // "SIGHUP" throws an `ENOSYS` error on Windows,
  // so use a supported signal instead
  /* c8 ignore start */
  #hupSig = process3.platform === 'win32' ? 'SIGINT' : 'SIGHUP';
  /* c8 ignore stop */
  #emitter = new Emitter();
  #process;
  #originalProcessEmit;
  #originalProcessReallyExit;
  #sigListeners = {};
  #loaded = false;
  constructor(process10) {
    super();
    this.#process = process10;
    this.#sigListeners = {};
    for (const sig of signals) {
      this.#sigListeners[sig] = () => {
        const listeners = this.#process.listeners(sig);
        let { count } = this.#emitter;
        const p = process10;
        if (typeof p.__signal_exit_emitter__ === 'object' && typeof p.__signal_exit_emitter__.count === 'number') {
          count += p.__signal_exit_emitter__.count;
        }
        if (listeners.length === count) {
          this.unload();
          const ret = this.#emitter.emit('exit', null, sig);
          const s = sig === 'SIGHUP' ? this.#hupSig : sig;
          if (!ret) process10.kill(process10.pid, s);
        }
      };
    }
    this.#originalProcessReallyExit = process10.reallyExit;
    this.#originalProcessEmit = process10.emit;
  }
  onExit(cb, opts) {
    if (!processOk(this.#process)) {
      return () => {};
    }
    if (this.#loaded === false) {
      this.load();
    }
    const ev = opts?.alwaysLast ? 'afterExit' : 'exit';
    this.#emitter.on(ev, cb);
    return () => {
      this.#emitter.removeListener(ev, cb);
      if (this.#emitter.listeners['exit'].length === 0 && this.#emitter.listeners['afterExit'].length === 0) {
        this.unload();
      }
    };
  }
  load() {
    if (this.#loaded) {
      return;
    }
    this.#loaded = true;
    this.#emitter.count += 1;
    for (const sig of signals) {
      try {
        const fn = this.#sigListeners[sig];
        if (fn) this.#process.on(sig, fn);
      } catch (_) {}
    }
    this.#process.emit = (ev, ...a) => {
      return this.#processEmit(ev, ...a);
    };
    this.#process.reallyExit = (code) => {
      return this.#processReallyExit(code);
    };
  }
  unload() {
    if (!this.#loaded) {
      return;
    }
    this.#loaded = false;
    signals.forEach((sig) => {
      const listener = this.#sigListeners[sig];
      if (!listener) {
        throw new Error('Listener not defined for signal: ' + sig);
      }
      try {
        this.#process.removeListener(sig, listener);
      } catch (_) {}
    });
    this.#process.emit = this.#originalProcessEmit;
    this.#process.reallyExit = this.#originalProcessReallyExit;
    this.#emitter.count -= 1;
  }
  #processReallyExit(code) {
    if (!processOk(this.#process)) {
      return 0;
    }
    this.#process.exitCode = code || 0;
    this.#emitter.emit('exit', this.#process.exitCode, null);
    return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
  }
  #processEmit(ev, ...args) {
    const og = this.#originalProcessEmit;
    if (ev === 'exit' && processOk(this.#process)) {
      if (typeof args[0] === 'number') {
        this.#process.exitCode = args[0];
      }
      const ret = og.call(this.#process, ev, ...args);
      this.#emitter.emit('exit', this.#process.exitCode, null);
      return ret;
    } else {
      return og.call(this.#process, ev, ...args);
    }
  }
};
var process3 = globalThis.process;
var {
  /**
   * Called when the process is exiting, whether via signal, explicit
   * exit, or running out of stuff to do.
   *
   * If the global process object is not suitable for instrumentation,
   * then this will be a no-op.
   *
   * Returns a function that may be used to unload signal-exit.
   */
  onExit,
  /**
   * Load the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  load,
  /**
   * Unload the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  unload,
} = signalExitWrap(processOk(process3) ? new SignalExit(process3) : new SignalExitFallback());

// node_modules/restore-cursor/index.js
var terminal = import_node_process2.default.stderr.isTTY
  ? import_node_process2.default.stderr
  : import_node_process2.default.stdout.isTTY
    ? import_node_process2.default.stdout
    : void 0;
var restoreCursor = terminal
  ? onetime_default(() => {
      onExit(
        () => {
          terminal.write('\x1B[?25h');
        },
        { alwaysLast: true },
      );
    })
  : () => {};
var restore_cursor_default = restoreCursor;

// node_modules/cli-cursor/index.js
var isHidden = false;
var cliCursor = {};
cliCursor.show = (writableStream = import_node_process3.default.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  isHidden = false;
  writableStream.write('\x1B[?25h');
};
cliCursor.hide = (writableStream = import_node_process3.default.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  restore_cursor_default();
  isHidden = true;
  writableStream.write('\x1B[?25l');
};
cliCursor.toggle = (force, writableStream) => {
  if (force !== void 0) {
    isHidden = force;
  }
  if (isHidden) {
    cliCursor.show(writableStream);
  } else {
    cliCursor.hide(writableStream);
  }
};
var cli_cursor_default = cliCursor;

// node_modules/ora/index.js
var import_cli_spinners = __toESM(require_cli_spinners(), 1);

// node_modules/log-symbols/node_modules/is-unicode-supported/index.js
var import_node_process4 = __toESM(require('node:process'), 1);
function isUnicodeSupported() {
  if (import_node_process4.default.platform !== 'win32') {
    return import_node_process4.default.env.TERM !== 'linux';
  }
  return (
    Boolean(import_node_process4.default.env.CI) ||
    Boolean(import_node_process4.default.env.WT_SESSION) ||
    Boolean(import_node_process4.default.env.TERMINUS_SUBLIME) ||
    import_node_process4.default.env.ConEmuTask === '{cmd::Cmder}' ||
    import_node_process4.default.env.TERM_PROGRAM === 'Terminus-Sublime' ||
    import_node_process4.default.env.TERM_PROGRAM === 'vscode' ||
    import_node_process4.default.env.TERM === 'xterm-256color' ||
    import_node_process4.default.env.TERM === 'alacritty' ||
    import_node_process4.default.env.TERMINAL_EMULATOR === 'JetBrains-JediTerm'
  );
}

// node_modules/log-symbols/index.js
var main = {
  info: source_default.blue('\u2139'),
  success: source_default.green('\u2714'),
  warning: source_default.yellow('\u26A0'),
  error: source_default.red('\u2716'),
};
var fallback = {
  info: source_default.blue('i'),
  success: source_default.green('\u221A'),
  warning: source_default.yellow('\u203C'),
  error: source_default.red('\xD7'),
};
var logSymbols = isUnicodeSupported() ? main : fallback;
var log_symbols_default = logSymbols;

// node_modules/ora/node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
  const pattern = [
    `[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
    '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))',
  ].join('|');
  return new RegExp(pattern, onlyFirst ? void 0 : 'g');
}

// node_modules/ora/node_modules/strip-ansi/index.js
var regex = ansiRegex();
function stripAnsi(string) {
  if (typeof string !== 'string') {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(regex, '');
}

// node_modules/get-east-asian-width/lookup.js
function isAmbiguous(x) {
  return (
    x === 161 ||
    x === 164 ||
    x === 167 ||
    x === 168 ||
    x === 170 ||
    x === 173 ||
    x === 174 ||
    (x >= 176 && x <= 180) ||
    (x >= 182 && x <= 186) ||
    (x >= 188 && x <= 191) ||
    x === 198 ||
    x === 208 ||
    x === 215 ||
    x === 216 ||
    (x >= 222 && x <= 225) ||
    x === 230 ||
    (x >= 232 && x <= 234) ||
    x === 236 ||
    x === 237 ||
    x === 240 ||
    x === 242 ||
    x === 243 ||
    (x >= 247 && x <= 250) ||
    x === 252 ||
    x === 254 ||
    x === 257 ||
    x === 273 ||
    x === 275 ||
    x === 283 ||
    x === 294 ||
    x === 295 ||
    x === 299 ||
    (x >= 305 && x <= 307) ||
    x === 312 ||
    (x >= 319 && x <= 322) ||
    x === 324 ||
    (x >= 328 && x <= 331) ||
    x === 333 ||
    x === 338 ||
    x === 339 ||
    x === 358 ||
    x === 359 ||
    x === 363 ||
    x === 462 ||
    x === 464 ||
    x === 466 ||
    x === 468 ||
    x === 470 ||
    x === 472 ||
    x === 474 ||
    x === 476 ||
    x === 593 ||
    x === 609 ||
    x === 708 ||
    x === 711 ||
    (x >= 713 && x <= 715) ||
    x === 717 ||
    x === 720 ||
    (x >= 728 && x <= 731) ||
    x === 733 ||
    x === 735 ||
    (x >= 768 && x <= 879) ||
    (x >= 913 && x <= 929) ||
    (x >= 931 && x <= 937) ||
    (x >= 945 && x <= 961) ||
    (x >= 963 && x <= 969) ||
    x === 1025 ||
    (x >= 1040 && x <= 1103) ||
    x === 1105 ||
    x === 8208 ||
    (x >= 8211 && x <= 8214) ||
    x === 8216 ||
    x === 8217 ||
    x === 8220 ||
    x === 8221 ||
    (x >= 8224 && x <= 8226) ||
    (x >= 8228 && x <= 8231) ||
    x === 8240 ||
    x === 8242 ||
    x === 8243 ||
    x === 8245 ||
    x === 8251 ||
    x === 8254 ||
    x === 8308 ||
    x === 8319 ||
    (x >= 8321 && x <= 8324) ||
    x === 8364 ||
    x === 8451 ||
    x === 8453 ||
    x === 8457 ||
    x === 8467 ||
    x === 8470 ||
    x === 8481 ||
    x === 8482 ||
    x === 8486 ||
    x === 8491 ||
    x === 8531 ||
    x === 8532 ||
    (x >= 8539 && x <= 8542) ||
    (x >= 8544 && x <= 8555) ||
    (x >= 8560 && x <= 8569) ||
    x === 8585 ||
    (x >= 8592 && x <= 8601) ||
    x === 8632 ||
    x === 8633 ||
    x === 8658 ||
    x === 8660 ||
    x === 8679 ||
    x === 8704 ||
    x === 8706 ||
    x === 8707 ||
    x === 8711 ||
    x === 8712 ||
    x === 8715 ||
    x === 8719 ||
    x === 8721 ||
    x === 8725 ||
    x === 8730 ||
    (x >= 8733 && x <= 8736) ||
    x === 8739 ||
    x === 8741 ||
    (x >= 8743 && x <= 8748) ||
    x === 8750 ||
    (x >= 8756 && x <= 8759) ||
    x === 8764 ||
    x === 8765 ||
    x === 8776 ||
    x === 8780 ||
    x === 8786 ||
    x === 8800 ||
    x === 8801 ||
    (x >= 8804 && x <= 8807) ||
    x === 8810 ||
    x === 8811 ||
    x === 8814 ||
    x === 8815 ||
    x === 8834 ||
    x === 8835 ||
    x === 8838 ||
    x === 8839 ||
    x === 8853 ||
    x === 8857 ||
    x === 8869 ||
    x === 8895 ||
    x === 8978 ||
    (x >= 9312 && x <= 9449) ||
    (x >= 9451 && x <= 9547) ||
    (x >= 9552 && x <= 9587) ||
    (x >= 9600 && x <= 9615) ||
    (x >= 9618 && x <= 9621) ||
    x === 9632 ||
    x === 9633 ||
    (x >= 9635 && x <= 9641) ||
    x === 9650 ||
    x === 9651 ||
    x === 9654 ||
    x === 9655 ||
    x === 9660 ||
    x === 9661 ||
    x === 9664 ||
    x === 9665 ||
    (x >= 9670 && x <= 9672) ||
    x === 9675 ||
    (x >= 9678 && x <= 9681) ||
    (x >= 9698 && x <= 9701) ||
    x === 9711 ||
    x === 9733 ||
    x === 9734 ||
    x === 9737 ||
    x === 9742 ||
    x === 9743 ||
    x === 9756 ||
    x === 9758 ||
    x === 9792 ||
    x === 9794 ||
    x === 9824 ||
    x === 9825 ||
    (x >= 9827 && x <= 9829) ||
    (x >= 9831 && x <= 9834) ||
    x === 9836 ||
    x === 9837 ||
    x === 9839 ||
    x === 9886 ||
    x === 9887 ||
    x === 9919 ||
    (x >= 9926 && x <= 9933) ||
    (x >= 9935 && x <= 9939) ||
    (x >= 9941 && x <= 9953) ||
    x === 9955 ||
    x === 9960 ||
    x === 9961 ||
    (x >= 9963 && x <= 9969) ||
    x === 9972 ||
    (x >= 9974 && x <= 9977) ||
    x === 9979 ||
    x === 9980 ||
    x === 9982 ||
    x === 9983 ||
    x === 10045 ||
    (x >= 10102 && x <= 10111) ||
    (x >= 11094 && x <= 11097) ||
    (x >= 12872 && x <= 12879) ||
    (x >= 57344 && x <= 63743) ||
    (x >= 65024 && x <= 65039) ||
    x === 65533 ||
    (x >= 127232 && x <= 127242) ||
    (x >= 127248 && x <= 127277) ||
    (x >= 127280 && x <= 127337) ||
    (x >= 127344 && x <= 127373) ||
    x === 127375 ||
    x === 127376 ||
    (x >= 127387 && x <= 127404) ||
    (x >= 917760 && x <= 917999) ||
    (x >= 983040 && x <= 1048573) ||
    (x >= 1048576 && x <= 1114109)
  );
}
function isFullWidth(x) {
  return x === 12288 || (x >= 65281 && x <= 65376) || (x >= 65504 && x <= 65510);
}
function isWide(x) {
  return (
    (x >= 4352 && x <= 4447) ||
    x === 8986 ||
    x === 8987 ||
    x === 9001 ||
    x === 9002 ||
    (x >= 9193 && x <= 9196) ||
    x === 9200 ||
    x === 9203 ||
    x === 9725 ||
    x === 9726 ||
    x === 9748 ||
    x === 9749 ||
    (x >= 9776 && x <= 9783) ||
    (x >= 9800 && x <= 9811) ||
    x === 9855 ||
    (x >= 9866 && x <= 9871) ||
    x === 9875 ||
    x === 9889 ||
    x === 9898 ||
    x === 9899 ||
    x === 9917 ||
    x === 9918 ||
    x === 9924 ||
    x === 9925 ||
    x === 9934 ||
    x === 9940 ||
    x === 9962 ||
    x === 9970 ||
    x === 9971 ||
    x === 9973 ||
    x === 9978 ||
    x === 9981 ||
    x === 9989 ||
    x === 9994 ||
    x === 9995 ||
    x === 10024 ||
    x === 10060 ||
    x === 10062 ||
    (x >= 10067 && x <= 10069) ||
    x === 10071 ||
    (x >= 10133 && x <= 10135) ||
    x === 10160 ||
    x === 10175 ||
    x === 11035 ||
    x === 11036 ||
    x === 11088 ||
    x === 11093 ||
    (x >= 11904 && x <= 11929) ||
    (x >= 11931 && x <= 12019) ||
    (x >= 12032 && x <= 12245) ||
    (x >= 12272 && x <= 12287) ||
    (x >= 12289 && x <= 12350) ||
    (x >= 12353 && x <= 12438) ||
    (x >= 12441 && x <= 12543) ||
    (x >= 12549 && x <= 12591) ||
    (x >= 12593 && x <= 12686) ||
    (x >= 12688 && x <= 12773) ||
    (x >= 12783 && x <= 12830) ||
    (x >= 12832 && x <= 12871) ||
    (x >= 12880 && x <= 42124) ||
    (x >= 42128 && x <= 42182) ||
    (x >= 43360 && x <= 43388) ||
    (x >= 44032 && x <= 55203) ||
    (x >= 63744 && x <= 64255) ||
    (x >= 65040 && x <= 65049) ||
    (x >= 65072 && x <= 65106) ||
    (x >= 65108 && x <= 65126) ||
    (x >= 65128 && x <= 65131) ||
    (x >= 94176 && x <= 94180) ||
    x === 94192 ||
    x === 94193 ||
    (x >= 94208 && x <= 100343) ||
    (x >= 100352 && x <= 101589) ||
    (x >= 101631 && x <= 101640) ||
    (x >= 110576 && x <= 110579) ||
    (x >= 110581 && x <= 110587) ||
    x === 110589 ||
    x === 110590 ||
    (x >= 110592 && x <= 110882) ||
    x === 110898 ||
    (x >= 110928 && x <= 110930) ||
    x === 110933 ||
    (x >= 110948 && x <= 110951) ||
    (x >= 110960 && x <= 111355) ||
    (x >= 119552 && x <= 119638) ||
    (x >= 119648 && x <= 119670) ||
    x === 126980 ||
    x === 127183 ||
    x === 127374 ||
    (x >= 127377 && x <= 127386) ||
    (x >= 127488 && x <= 127490) ||
    (x >= 127504 && x <= 127547) ||
    (x >= 127552 && x <= 127560) ||
    x === 127568 ||
    x === 127569 ||
    (x >= 127584 && x <= 127589) ||
    (x >= 127744 && x <= 127776) ||
    (x >= 127789 && x <= 127797) ||
    (x >= 127799 && x <= 127868) ||
    (x >= 127870 && x <= 127891) ||
    (x >= 127904 && x <= 127946) ||
    (x >= 127951 && x <= 127955) ||
    (x >= 127968 && x <= 127984) ||
    x === 127988 ||
    (x >= 127992 && x <= 128062) ||
    x === 128064 ||
    (x >= 128066 && x <= 128252) ||
    (x >= 128255 && x <= 128317) ||
    (x >= 128331 && x <= 128334) ||
    (x >= 128336 && x <= 128359) ||
    x === 128378 ||
    x === 128405 ||
    x === 128406 ||
    x === 128420 ||
    (x >= 128507 && x <= 128591) ||
    (x >= 128640 && x <= 128709) ||
    x === 128716 ||
    (x >= 128720 && x <= 128722) ||
    (x >= 128725 && x <= 128727) ||
    (x >= 128732 && x <= 128735) ||
    x === 128747 ||
    x === 128748 ||
    (x >= 128756 && x <= 128764) ||
    (x >= 128992 && x <= 129003) ||
    x === 129008 ||
    (x >= 129292 && x <= 129338) ||
    (x >= 129340 && x <= 129349) ||
    (x >= 129351 && x <= 129535) ||
    (x >= 129648 && x <= 129660) ||
    (x >= 129664 && x <= 129673) ||
    (x >= 129679 && x <= 129734) ||
    (x >= 129742 && x <= 129756) ||
    (x >= 129759 && x <= 129769) ||
    (x >= 129776 && x <= 129784) ||
    (x >= 131072 && x <= 196605) ||
    (x >= 196608 && x <= 262141)
  );
}

// node_modules/get-east-asian-width/index.js
function validate2(codePoint) {
  if (!Number.isSafeInteger(codePoint)) {
    throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
  }
}
function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
  validate2(codePoint);
  if (isFullWidth(codePoint) || isWide(codePoint) || (ambiguousAsWide && isAmbiguous(codePoint))) {
    return 2;
  }
  return 1;
}

// node_modules/ora/node_modules/string-width/index.js
var import_emoji_regex = __toESM(require_emoji_regex(), 1);
var segmenter = new Intl.Segmenter();
var defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
function stringWidth(string, options2 = {}) {
  if (typeof string !== 'string' || string.length === 0) {
    return 0;
  }
  const { ambiguousIsNarrow = true, countAnsiEscapeCodes = false } = options2;
  if (!countAnsiEscapeCodes) {
    string = stripAnsi(string);
  }
  if (string.length === 0) {
    return 0;
  }
  let width = 0;
  const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
  for (const { segment: character } of segmenter.segment(string)) {
    const codePoint = character.codePointAt(0);
    if (codePoint <= 31 || (codePoint >= 127 && codePoint <= 159)) {
      continue;
    }
    if ((codePoint >= 8203 && codePoint <= 8207) || codePoint === 65279) {
      continue;
    }
    if (
      (codePoint >= 768 && codePoint <= 879) ||
      (codePoint >= 6832 && codePoint <= 6911) ||
      (codePoint >= 7616 && codePoint <= 7679) ||
      (codePoint >= 8400 && codePoint <= 8447) ||
      (codePoint >= 65056 && codePoint <= 65071)
    ) {
      continue;
    }
    if (codePoint >= 55296 && codePoint <= 57343) {
      continue;
    }
    if (codePoint >= 65024 && codePoint <= 65039) {
      continue;
    }
    if (defaultIgnorableCodePointRegex.test(character)) {
      continue;
    }
    if ((0, import_emoji_regex.default)().test(character)) {
      width += 2;
      continue;
    }
    width += eastAsianWidth(codePoint, eastAsianWidthOptions);
  }
  return width;
}

// node_modules/is-interactive/index.js
function isInteractive({ stream = process.stdout } = {}) {
  return Boolean(stream && stream.isTTY && process.env.TERM !== 'dumb' && !('CI' in process.env));
}

// node_modules/is-unicode-supported/index.js
var import_node_process5 = __toESM(require('node:process'), 1);
function isUnicodeSupported2() {
  const { env: env2 } = import_node_process5.default;
  const { TERM, TERM_PROGRAM } = env2;
  if (import_node_process5.default.platform !== 'win32') {
    return TERM !== 'linux';
  }
  return (
    Boolean(env2.WT_SESSION) ||
    Boolean(env2.TERMINUS_SUBLIME) ||
    env2.ConEmuTask === '{cmd::Cmder}' ||
    TERM_PROGRAM === 'Terminus-Sublime' ||
    TERM_PROGRAM === 'vscode' ||
    TERM === 'xterm-256color' ||
    TERM === 'alacritty' ||
    TERM === 'rxvt-unicode' ||
    TERM === 'rxvt-unicode-256color' ||
    env2.TERMINAL_EMULATOR === 'JetBrains-JediTerm'
  );
}

// node_modules/stdin-discarder/index.js
var import_node_process6 = __toESM(require('node:process'), 1);
var ASCII_ETX_CODE = 3;
var StdinDiscarder = class {
  #activeCount = 0;
  start() {
    this.#activeCount++;
    if (this.#activeCount === 1) {
      this.#realStart();
    }
  }
  stop() {
    if (this.#activeCount <= 0) {
      throw new Error('`stop` called more times than `start`');
    }
    this.#activeCount--;
    if (this.#activeCount === 0) {
      this.#realStop();
    }
  }
  #realStart() {
    if (import_node_process6.default.platform === 'win32' || !import_node_process6.default.stdin.isTTY) {
      return;
    }
    import_node_process6.default.stdin.setRawMode(true);
    import_node_process6.default.stdin.on('data', this.#handleInput);
    import_node_process6.default.stdin.resume();
  }
  #realStop() {
    if (!import_node_process6.default.stdin.isTTY) {
      return;
    }
    import_node_process6.default.stdin.off('data', this.#handleInput);
    import_node_process6.default.stdin.pause();
    import_node_process6.default.stdin.setRawMode(false);
  }
  #handleInput(chunk) {
    if (chunk[0] === ASCII_ETX_CODE) {
      import_node_process6.default.emit('SIGINT');
    }
  }
};
var stdinDiscarder = new StdinDiscarder();
var stdin_discarder_default = stdinDiscarder;

// node_modules/ora/index.js
var import_cli_spinners2 = __toESM(require_cli_spinners(), 1);
var Ora = class {
  #linesToClear = 0;
  #isDiscardingStdin = false;
  #lineCount = 0;
  #frameIndex = -1;
  #lastSpinnerFrameTime = 0;
  #options;
  #spinner;
  #stream;
  #id;
  #initialInterval;
  #isEnabled;
  #isSilent;
  #indent;
  #text;
  #prefixText;
  #suffixText;
  color;
  constructor(options2) {
    if (typeof options2 === 'string') {
      options2 = {
        text: options2,
      };
    }
    this.#options = {
      color: 'cyan',
      stream: import_node_process7.default.stderr,
      discardStdin: true,
      hideCursor: true,
      ...options2,
    };
    this.color = this.#options.color;
    this.spinner = this.#options.spinner;
    this.#initialInterval = this.#options.interval;
    this.#stream = this.#options.stream;
    this.#isEnabled =
      typeof this.#options.isEnabled === 'boolean' ? this.#options.isEnabled : isInteractive({ stream: this.#stream });
    this.#isSilent = typeof this.#options.isSilent === 'boolean' ? this.#options.isSilent : false;
    this.text = this.#options.text;
    this.prefixText = this.#options.prefixText;
    this.suffixText = this.#options.suffixText;
    this.indent = this.#options.indent;
    if (import_node_process7.default.env.NODE_ENV === 'test') {
      this._stream = this.#stream;
      this._isEnabled = this.#isEnabled;
      Object.defineProperty(this, '_linesToClear', {
        get() {
          return this.#linesToClear;
        },
        set(newValue) {
          this.#linesToClear = newValue;
        },
      });
      Object.defineProperty(this, '_frameIndex', {
        get() {
          return this.#frameIndex;
        },
      });
      Object.defineProperty(this, '_lineCount', {
        get() {
          return this.#lineCount;
        },
      });
    }
  }
  get indent() {
    return this.#indent;
  }
  set indent(indent = 0) {
    if (!(indent >= 0 && Number.isInteger(indent))) {
      throw new Error('The `indent` option must be an integer from 0 and up');
    }
    this.#indent = indent;
    this.#updateLineCount();
  }
  get interval() {
    return this.#initialInterval ?? this.#spinner.interval ?? 100;
  }
  get spinner() {
    return this.#spinner;
  }
  set spinner(spinner) {
    this.#frameIndex = -1;
    this.#initialInterval = void 0;
    if (typeof spinner === 'object') {
      if (spinner.frames === void 0) {
        throw new Error('The given spinner must have a `frames` property');
      }
      this.#spinner = spinner;
    } else if (!isUnicodeSupported2()) {
      this.#spinner = import_cli_spinners.default.line;
    } else if (spinner === void 0) {
      this.#spinner = import_cli_spinners.default.dots;
    } else if (spinner !== 'default' && import_cli_spinners.default[spinner]) {
      this.#spinner = import_cli_spinners.default[spinner];
    } else {
      throw new Error(
        `There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`,
      );
    }
  }
  get text() {
    return this.#text;
  }
  set text(value = '') {
    this.#text = value;
    this.#updateLineCount();
  }
  get prefixText() {
    return this.#prefixText;
  }
  set prefixText(value = '') {
    this.#prefixText = value;
    this.#updateLineCount();
  }
  get suffixText() {
    return this.#suffixText;
  }
  set suffixText(value = '') {
    this.#suffixText = value;
    this.#updateLineCount();
  }
  get isSpinning() {
    return this.#id !== void 0;
  }
  #getFullPrefixText(prefixText = this.#prefixText, postfix = ' ') {
    if (typeof prefixText === 'string' && prefixText !== '') {
      return prefixText + postfix;
    }
    if (typeof prefixText === 'function') {
      return prefixText() + postfix;
    }
    return '';
  }
  #getFullSuffixText(suffixText = this.#suffixText, prefix = ' ') {
    if (typeof suffixText === 'string' && suffixText !== '') {
      return prefix + suffixText;
    }
    if (typeof suffixText === 'function') {
      return prefix + suffixText();
    }
    return '';
  }
  #updateLineCount() {
    const columns = this.#stream.columns ?? 80;
    const fullPrefixText = this.#getFullPrefixText(this.#prefixText, '-');
    const fullSuffixText = this.#getFullSuffixText(this.#suffixText, '-');
    const fullText = ' '.repeat(this.#indent) + fullPrefixText + '--' + this.#text + '--' + fullSuffixText;
    this.#lineCount = 0;
    for (const line of stripAnsi(fullText).split('\n')) {
      this.#lineCount += Math.max(1, Math.ceil(stringWidth(line, { countAnsiEscapeCodes: true }) / columns));
    }
  }
  get isEnabled() {
    return this.#isEnabled && !this.#isSilent;
  }
  set isEnabled(value) {
    if (typeof value !== 'boolean') {
      throw new TypeError('The `isEnabled` option must be a boolean');
    }
    this.#isEnabled = value;
  }
  get isSilent() {
    return this.#isSilent;
  }
  set isSilent(value) {
    if (typeof value !== 'boolean') {
      throw new TypeError('The `isSilent` option must be a boolean');
    }
    this.#isSilent = value;
  }
  frame() {
    const now = Date.now();
    if (this.#frameIndex === -1 || now - this.#lastSpinnerFrameTime >= this.interval) {
      this.#frameIndex = ++this.#frameIndex % this.#spinner.frames.length;
      this.#lastSpinnerFrameTime = now;
    }
    const { frames } = this.#spinner;
    let frame = frames[this.#frameIndex];
    if (this.color) {
      frame = source_default[this.color](frame);
    }
    const fullPrefixText =
      typeof this.#prefixText === 'string' && this.#prefixText !== '' ? this.#prefixText + ' ' : '';
    const fullText = typeof this.text === 'string' ? ' ' + this.text : '';
    const fullSuffixText =
      typeof this.#suffixText === 'string' && this.#suffixText !== '' ? ' ' + this.#suffixText : '';
    return fullPrefixText + frame + fullText + fullSuffixText;
  }
  clear() {
    if (!this.#isEnabled || !this.#stream.isTTY) {
      return this;
    }
    this.#stream.cursorTo(0);
    for (let index = 0; index < this.#linesToClear; index++) {
      if (index > 0) {
        this.#stream.moveCursor(0, -1);
      }
      this.#stream.clearLine(1);
    }
    if (this.#indent || this.lastIndent !== this.#indent) {
      this.#stream.cursorTo(this.#indent);
    }
    this.lastIndent = this.#indent;
    this.#linesToClear = 0;
    return this;
  }
  render() {
    if (this.#isSilent) {
      return this;
    }
    this.clear();
    this.#stream.write(this.frame());
    this.#linesToClear = this.#lineCount;
    return this;
  }
  start(text) {
    if (text) {
      this.text = text;
    }
    if (this.#isSilent) {
      return this;
    }
    if (!this.#isEnabled) {
      if (this.text) {
        this.#stream.write(`- ${this.text}
`);
      }
      return this;
    }
    if (this.isSpinning) {
      return this;
    }
    if (this.#options.hideCursor) {
      cli_cursor_default.hide(this.#stream);
    }
    if (this.#options.discardStdin && import_node_process7.default.stdin.isTTY) {
      this.#isDiscardingStdin = true;
      stdin_discarder_default.start();
    }
    this.render();
    this.#id = setInterval(this.render.bind(this), this.interval);
    return this;
  }
  stop() {
    if (!this.#isEnabled) {
      return this;
    }
    clearInterval(this.#id);
    this.#id = void 0;
    this.#frameIndex = 0;
    this.clear();
    if (this.#options.hideCursor) {
      cli_cursor_default.show(this.#stream);
    }
    if (this.#options.discardStdin && import_node_process7.default.stdin.isTTY && this.#isDiscardingStdin) {
      stdin_discarder_default.stop();
      this.#isDiscardingStdin = false;
    }
    return this;
  }
  succeed(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.success, text });
  }
  fail(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.error, text });
  }
  warn(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.warning, text });
  }
  info(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.info, text });
  }
  stopAndPersist(options2 = {}) {
    if (this.#isSilent) {
      return this;
    }
    const prefixText = options2.prefixText ?? this.#prefixText;
    const fullPrefixText = this.#getFullPrefixText(prefixText, ' ');
    const symbolText = options2.symbol ?? ' ';
    const text = options2.text ?? this.text;
    const separatorText = symbolText ? ' ' : '';
    const fullText = typeof text === 'string' ? separatorText + text : '';
    const suffixText = options2.suffixText ?? this.#suffixText;
    const fullSuffixText = this.#getFullSuffixText(suffixText, ' ');
    const textToWrite = fullPrefixText + symbolText + fullText + fullSuffixText + '\n';
    this.stop();
    this.#stream.write(textToWrite);
    return this;
  }
};
function ora(options2) {
  return new Ora(options2);
}

// scripts/update-changelog/update-changelog.mjs
var import_turndown = __toESM(require_turndown_cjs(), 1);
program.option('--all', 'Process all dependency bumps (not only in the latest release entry)').parse(process.argv);
var options = program.opts();
var updateAll = options.all || false;
var changelogPath = './CHANGELOG.md';
var GITHUB_TOKEN = process.env['INPUT_GITHUB-TOKEN'] || null;
var CHANGELOG_REPO = { owner: 'jayree', repo: 'sfdx-plugin-manifest' };
var octokit = new Octokit2({
  auth: GITHUB_TOKEN,
  userAgent: 'release-injector',
});
function normalizeVersion(version) {
  return import_semver2.default.valid(version) || (import_semver2.default.coerce(version) || {}).version || null;
}
async function logApiLimits() {
  try {
    const {
      data: { rate },
    } = await octokit.rest.rateLimit.get();
    console.log(
      source_default.yellow(
        `\u26A0\uFE0F  API Rate Limits: Total: ${rate.limit}, Remaining: ${rate.remaining}, Resets at: ${new Date(
          rate.reset * 1e3,
        ).toLocaleString()}`,
      ),
    );
  } catch (error) {
    console.warn(source_default.red(`\u26A0\uFE0F  Error fetching API limits: ${error.message}`));
  }
}
function extractPRNumber(line) {
  const match = line.match(/\[#(\d+)\]/);
  return match ? match[1] : null;
}
async function getPullRequestTitle(owner, repo, prNumber) {
  try {
    const { data } = await octokit.rest.pulls.get({
      owner,
      repo,
      pull_number: prNumber,
    });
    return data.title;
  } catch (error) {
    throw new Error(`Failed to fetch PR #${prNumber}: ${error.message}`);
  }
}
async function getRepoInfo(packageName) {
  const pkg = await packageJson(packageName, { fullMetadata: true });
  const repoUrl = pkg.repository?.url;
  if (!repoUrl) throw new Error(`No repository URL for ${packageName}`);
  const parsedUrl = new import_url.URL(repoUrl);
  const allowedHosts = ['github.com', 'www.github.com'];
  if (!allowedHosts.includes(parsedUrl.host)) throw new Error(`No GitHub repository for ${packageName}`);
  const match = parsedUrl.pathname.match(/^\/(.+?)\/(.+?)(\.git)?$/);
  if (!match) throw new Error(`Invalid repository URL: ${repoUrl}`);
  return { owner: match[1], repo: match[2] };
}
async function getAllTags(owner, repo) {
  try {
    const tags = await octokit.paginate(octokit.rest.repos.listTags, {
      owner,
      repo,
      per_page: 100,
    });
    return tags.map((t) => t.name);
  } catch (error) {
    throw new Error(`Failed to fetch tags for ${repo}: ${error.message}`);
  }
}
function parseReleaseSections(text = '') {
  const sections = { features: [], fixes: [], other: [] };
  let current = 'other';
  for (const line of text.split('\n')) {
    const trimmed = line.trim();
    if (/^#{1,3} \[?\d+\.\d+\.\d+\]?.*?\(.*?\)/.test(trimmed)) continue;
    const lower = trimmed.toLowerCase();
    if (lower.includes('### features')) {
      current = 'features';
      continue;
    }
    if (lower.includes('### bug') || lower.includes('### fix')) {
      current = 'fixes';
      continue;
    }
    if (!trimmed.startsWith('* ')) {
      continue;
    }
    if (trimmed) sections[current].push(trimmed);
  }
  return sections;
}
async function getGroupedReleaseNotes(owner, repo, from, to) {
  const rawTags = await getAllTags(owner, repo);
  const tagObjects = rawTags
    .map((tag) => {
      const versionStr = tag.startsWith('v') ? tag.slice(1) : tag;
      const normalized = import_semver2.default.coerce(versionStr);
      return { original: tag, version: normalized ? normalized.version : null };
    })
    .filter((t) => t.version !== null);
  tagObjects.sort((a, b) => import_semver2.default.compare(a.version, b.version));
  const rangeTags = tagObjects.filter(
    (t) => import_semver2.default.gt(t.version, from) && import_semver2.default.lte(t.version, to),
  );
  const grouped = { features: [], fixes: [], other: [] };
  await Promise.all(
    rangeTags.map(async (t) => {
      try {
        const { data: release } = await octokit.rest.repos.getReleaseByTag({
          owner,
          repo,
          tag: t.original,
        });
        const parsed = parseReleaseSections(release.body || '');
        grouped.features.push(...parsed.features);
        grouped.fixes.push(...parsed.fixes);
        grouped.other.push(...parsed.other);
      } catch (error) {}
    }),
  );
  return grouped;
}
function formatGroupedAsMarkdown(grouped) {
  const format = (title, list) => (list.length ? `${list.map((l) => `  ${l}`).join('\n')}` : '');
  return (
    format('\u{1F680} Features', grouped.features) +
    (grouped.features.length && grouped.fixes.length ? '\n' : '') +
    format('\u{1F41B} Bug Fixes', grouped.fixes) +
    (grouped.fixes.length && grouped.other.length ? '\n' : '') +
    format('\u{1F4C4} Other Changes', grouped.other)
  );
}
async function getDependabotChangelogFromPR(owner, repo, prNumber, normalizedFrom, normalizedTo) {
  const { data: pr } = await octokit.rest.pulls.get({
    owner,
    repo,
    pull_number: prNumber,
  });
  const turndownService = new import_turndown.default();
  const body = pr.body || '';
  let lines = turndownService
    .turndown(body)
    .split('\n')
    .filter((line) => line.startsWith('>'))
    .map((line) => line.replace(/^> /, ''))
    .join('\n');
  if (lines.includes(normalizedFrom)) {
    lines = lines.split('\n');
    const startIndex = lines.findIndex((line) => line.includes(normalizedTo));
    const endIndex = lines.findIndex((line) => line.includes(normalizedFrom));
    if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
      lines = lines.slice(startIndex + 1, endIndex).join('\n');
    } else {
      return null;
    }
  }
  const parsed = parseReleaseSections(lines);
  return Object.values(parsed).some((arr) => arr.length > 0) ? parsed : null;
}
async function processDependencyBump(line) {
  const depsPatternFull = /^\* \*\*deps:\*\* bump ([\w@/.\-]+) from ([^\s]+) to ([^\s]+).*$/;
  const depsPatternPartial = /^\* \*\*deps:\*\* bump ([\w@/.\-]+).*$/;
  const matchFull = line.match(depsPatternFull);
  if (matchFull) {
    if (matchFull.length < 4) {
      console.warn(source_default.red(`\u26A0\uFE0F Full pattern match did not capture all groups: ${matchFull}`));
      return null;
    }
    const [, pkg, fromVersion, toVersion] = matchFull;
    return { pkg, fromVersion, toVersion };
  }
  const matchPartial = line.match(depsPatternPartial);
  if (matchPartial) {
    if (matchPartial.length < 2) {
      console.warn(source_default.red(`\u26A0\uFE0F Partial pattern match did not capture package: ${matchPartial}`));
      return null;
    }
    const pkg = matchPartial[1];
    console.warn(source_default.yellow(`\u{1F50D} Partial match for ${pkg}`));
    const prNumber = extractPRNumber(line);
    if (!prNumber) {
      console.warn(source_default.red(`\u26A0\uFE0F No PR number for ${pkg}`));
      return null;
    }
    const { owner: prOwner, repo: prRepo } = CHANGELOG_REPO;
    const prTitle = await getPullRequestTitle(prOwner, prRepo, prNumber);
    const versionMatch = prTitle.match(/bump .* from ([^\s]+) to ([^\s]+)/i);
    if (!versionMatch || versionMatch.length < 3) {
      console.warn(source_default.red(`\u26A0\uFE0F No version info in PR title for ${pkg}`));
      return null;
    }
    const [, fromVersion, toVersion] = versionMatch;
    return { pkg, fromVersion, toVersion };
  }
  return null;
}
function getLatestEntryIndices(lines) {
  const releaseHeaderRegex = /^#{1,3} \[?\d+\.\d+\.\d+\]?.*?\(.*?\)/;
  let start = -1,
    end = lines.length;
  for (let i = 0; i < lines.length; i++) {
    if (releaseHeaderRegex.test(lines[i])) {
      if (start === -1) start = i;
      else {
        end = i;
        break;
      }
    }
  }
  return { start: start === -1 ? 0 : start, end };
}
async function preCommit(props) {
  const rateSpinner = ora('Fetching API rate limits...').start();
  await logApiLimits();
  rateSpinner.succeed('API rate limits fetched.');
  const content = import_fs.default.readFileSync(changelogPath, 'utf-8');
  const lines = content.split('\n');
  const { start: latestStart, end: latestEnd } = getLatestEntryIndices(lines);
  const newLines = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    newLines.push(line);
    if (!updateAll && (i < latestStart || i >= latestEnd)) continue;
    if (!line.startsWith('* ')) continue;
    const bump = await processDependencyBump(line);
    if (!bump) continue;
    const { pkg, fromVersion, toVersion } = bump;
    const normalizedFrom = normalizeVersion(fromVersion);
    const normalizedTo = normalizeVersion(toVersion);
    if (!normalizedFrom || !normalizedTo) {
      console.warn(source_default.red(`Invalid versions for ${pkg}: ${fromVersion} \u2192 ${toVersion}`));
      continue;
    }
    const depSpinner = ora(`Processing dependency bump for ${pkg}...`).start();
    try {
      const { owner, repo } = await getRepoInfo(pkg);
      const grouped = await getGroupedReleaseNotes(owner, repo, normalizedFrom, normalizedTo);
      const markdown = formatGroupedAsMarkdown(grouped);
      if (markdown.trim()) {
        newLines.push(markdown);
        depSpinner.succeed(source_default.green(`Inserted notes for ${pkg}: ${normalizedFrom} \u2192 ${normalizedTo}`));
      } else {
        console.warn(source_default.yellow(`\u{1F50D} Attempting to fetch changelog from Dependabot PR for ${pkg}`));
        const { owner: prOwner, repo: prRepo } = CHANGELOG_REPO;
        const prNumber = extractPRNumber(line);
        const dependabotChangeLog = await getDependabotChangelogFromPR(
          prOwner,
          prRepo,
          prNumber,
          normalizedFrom,
          normalizedTo,
        );
        if (dependabotChangeLog) {
          const markdown2 = formatGroupedAsMarkdown(dependabotChangeLog);
          newLines.push(markdown2);
          depSpinner.succeed(
            source_default.green(`Inserted notes for ${pkg}: ${normalizedFrom} \u2192 ${normalizedTo}`),
          );
        } else {
          depSpinner.info(source_default.blue(`No notes found for ${pkg}: ${normalizedFrom} \u2192 ${normalizedTo}`));
        }
      }
    } catch (err) {
      depSpinner.fail(source_default.red(`Skipped ${pkg}: ${err.message}`));
    }
  }
  import_fs.default.writeFileSync(changelogPath, newLines.join('\n'), 'utf-8');
  console.log(source_default.green('CHANGELOG.md updated'));
}
// Annotate the CommonJS export names for ESM import in node:
0 &&
  (module.exports = {
    preCommit,
  });
/*! Bundled license information:

deep-extend/lib/deep-extend.js:
  (*!
   * @description Recursive object extending
   * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
   * @license MIT
   *
   * The MIT License (MIT)
   *
   * Copyright (c) 2013-2018 Viacheslav Lotsmanov
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the "Software"), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   * the Software, and to permit persons to whom the Software is furnished to do so,
   * subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *)

@mixmark-io/domino/lib/style_parser.js:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

ky/distribution/index.js:
  (*! MIT License © Sindre Sorhus *)
*/
